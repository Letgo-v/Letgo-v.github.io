<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2017-10661 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2017-10661</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2017/12/29</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Android_Kernel"> Android_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="CVE-2018-10661"><a href="#CVE-2018-10661" class="headerlink" title="CVE-2018-10661"></a>CVE-2018-10661</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="测试内核"><a href="#测试内核" class="headerlink" title="测试内核"></a>测试内核</h3><p>测试时使用的linux内核是MI 5C的内核(3.10.58-03548-gc670b5a)</p>
<h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>在4.10.15之前的linux内核中fs/timerfd.c中存在条件竞争漏洞,允许本地用户通过使用不合适的might_cancel列表的文件描述符操作获取特权或导致拒绝服务(list corruption or use-after-free)</p>
<h3 id="Google修复链接"><a href="#Google修复链接" class="headerlink" title="Google修复链接"></a>Google修复链接</h3><p><a href="https://android.googlesource.com/kernel/goldfish/+/95cb006041c2f53060f4decffc7ef27f60aa1d39" target="_blank" rel="external">https://android.googlesource.com/kernel/goldfish/+/95cb006041c2f53060f4decffc7ef27f60aa1d39</a></p>
<h3 id="存在漏洞的Nexus内核版本"><a href="#存在漏洞的Nexus内核版本" class="headerlink" title="存在漏洞的Nexus内核版本"></a>存在漏洞的Nexus内核版本</h3><p>Nexus 6P :Linux version 3.10.73-geac7d674 (android-build@wpef26.hot.corp.google.com) (gcc version 4.9.x-google 20140827 (prerelease) (GCC) ) #1 SMP PREEMPT Tue Dec 13 10:11:12 UTC 2016<br>Nexus 5X :Linux version 3.10.73-gf97f123 (android-build@wpiu4.hot.corp.google.com) (gcc version 4.9.x-google 20140827 (prerelease) (GCC) ) #1 SMP PREEMPT Mon Nov 2 20:10:58 UTC 2015</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="红米4A-崩溃日志"><a href="#红米4A-崩溃日志" class="headerlink" title="红米4A_崩溃日志"></a>红米4A_崩溃日志</h3><pre><code>[  259.810287] Unable to handle kernel paging request at virtual address dead000000000200
[  259.810331] pgd = ffffffc06b967000
[  259.810339] [dead000000000200] *pgd=00000000a1fb1003, *pud=00000000a1fb1003, *pmd=0000000000000000
[  259.810360] Internal error: Oops: 96000044 [#1] PREEMPT SMP
[  259.810367] Modules linked in: wlan(O)
[  259.810386] CPU: 2 PID: 6022 Comm: main Tainted: G        W  O   3.18.24-perf-gdcca0a6 #1
[  259.810394] Hardware name: Qualcomm Technologies, Inc. MSM8917-PMI8937 QRD SKU5 (DT)
[  259.810403] task: ffffffc053611900 ti: ffffffc035e48000 task.ti: ffffffc035e48000
[  259.810418] PC is at do_timerfd_settime+0x124/0x384
[  259.810427] LR is at do_timerfd_settime+0x118/0x384
[  259.810435] pc : [&lt;ffffffc0001eb300&gt;] lr : [&lt;ffffffc0001eb2f4&gt;] pstate: 80000145
[  259.810442] sp : ffffffc035e4bdd0
[  259.810448] x29: ffffffc035e4bdd0 x28: ffffffc035e48000
[  259.810461] x27: ffffffc035e4bea8 x26: 0000000000000056
[  259.810474] x25: ffffffc0111f3300 x24: ffffffc0111f3301
[  259.810486] x23: 0000000000000001 x22: ffffffc035e4be88
[  259.810498] x21: 0000000000000000 x20: ffffffc0015ebb90
[  259.810511] x19: ffffffc0111f3b00 x18: 0000000000000000
[  259.810523] x17: 0000000000000001 x16: ffffffc0001ebb54
[  259.810535] x15: 0000007f995ff838 x14: 000000002b63a2d4
[  259.810547] x13: ffffffffa5cce430 x12: 0000000000000000
[  259.810559] x11: 00000000041cdaeb x10: 00000000000f4240
[  259.810571] x9 : 00000000000003e8 x8 : 0000000000000056
[  259.810583] x7 : 0000000000000000 x6 : 0000010624dd2fb8
[  259.810594] x5 : 0000000000000000 x4 : ffffffc035e4bda0
[  259.810606] x3 : 0000000000000000 x2 : 0000000000000000
[  259.810617] x1 : ffffffc0111f3be0 x0 : dead000000000200
...
[  259.812135]
[  259.812143] Process main (pid: 6022, stack limit = 0xffffffc035e48058)
[  259.812149] Call trace:
[  259.812160] [&lt;ffffffc0001eb300&gt;] do_timerfd_settime+0x124/0x384
[  259.812170] [&lt;ffffffc0001ebbe0&gt;] SyS_timerfd_settime+0x8c/0x108
[  259.812181] Code: 9429cf30 f9407261 f9407660 f9000420 (f9000001)
[  259.812295] ---[ end trace 10b0993cfa7a40d0 ]---
[  259.874037] Kernel panic - not syncing: Fatal exception
[  259.874050] CPU3: stopping
</code></pre><h3 id="MI-5C崩溃日志"><a href="#MI-5C崩溃日志" class="headerlink" title="MI 5C崩溃日志"></a>MI 5C崩溃日志</h3><pre><code>[   72.679105] Unable to handle kernel paging request at virtual address 00200200
[   72.679130] pgd = ffffffc03603a000
[   72.679136] [00200200] *pgd=0000000054a8a003, *pmd=0000000000000000
[   72.679152] Internal error: Oops: 96000046 [#1] PREEMPT SMP
[   72.679159] Modules linked in:
[   72.679172] CPU: 5 PID: 3907 Comm: main Not tainted 3.10.58-03548-gc670b5a #1
[   72.679179] task: ffffffc006d18b00 ti: ffffffc030464000 task.ti: ffffffc030464000
[   72.679198] PC is at do_timerfd_settime+0x13c/0x384
[   72.679204] LR is at do_timerfd_settime+0x124/0x384
[   72.679210] pc : [&lt;ffffffc0001fe99c&gt;] lr : [&lt;ffffffc0001fe984&gt;] pstate: 80000145
[   72.679215] sp : ffffffc030467dc0
[   72.679220] x29: ffffffc030467dc0 x28: ffffffc030464000
[   72.679230] x27: ffffffc000e2e000 x26: ffffffc030467eb0
[   72.679239] x25: 0000000000000001 x24: ffffffc04ab4c200
[   72.679249] x23: 0000000000000000 x22: 0000000000000001
[   72.679258] x21: ffffffc030467e90 x20: ffffffc0010fa350
[   72.679268] x19: ffffffc04ab4d700 x18: 0000000000000000
[   72.679277] x17: 0000000000000001 x16: ffffffc0001ff204
[   72.679286] x15: 00000073aacff838 x14: 00000000322852a5
[   72.679297] x13: ffffffffa5cce228 x12: 0000000000000000
[   72.679306] x11: 000000002d2614c5 x10: 00000000000f4240
[   72.679315] x9 : 00000000000003e8 x8 : 0000000000000056
[   72.679325] x7 : 0000000000000000 x6 : 0000010624dd2fb8
[   72.679334] x5 : 0000000000000000 x4 : 0000000000000003
[   72.679344] x3 : ffffffc04ab4d7c0 x2 : 0000000000200200
[   72.679353] x1 : 0000000000200200 x0 : ffffffc0010fa350
...
[   72.679516] Call trace:
[   72.679524] [&lt;ffffffc0001fe99c&gt;] do_timerfd_settime+0x13c/0x384
[   72.679532] [&lt;ffffffc0001ff284&gt;] SyS_timerfd_settime+0x80/0x100
[   72.679539] Code: f9406662 f2a00401 aa1403e0 f9000462 (f9000043)
[   72.679588] ---[ end trace 4bf3b843607c1053 ]---
[   72.704005] Kernel panic - not syncing: Fatal exception
[   72.704028] CPU4: stopping
</code></pre><p>我们通过分析不同手机的内核崩溃日志可以看到是存在两种不同崩溃的，这取决于当前内核的LIST_POISON2宏的值（0xdead000000200200 或 0x00200200）当LIST_POISON2等于0xdead000000200200因为无法使用mmap对其进行映射，导致触发漏洞时会稳定崩溃在对该地址进行写入的位置，没想到如何避免该崩溃，而当LIST_POISON2等与0x00200200时我们可以通过mmap函数在exploit程序中对其进行映射，当触发漏洞的时候也就不会造成内核崩溃，也就可以进行我们下一步的利用操作，以下的操作都是基于LIST_POISON2等于0x00200200</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>首先看下官方给的补丁<br><img src="patch.png" alt="">左边属于打补丁之前的代码，右边属于打补丁之后的代码<br>可以看到主要是新添加了一个__timerfd_remove_cancel函数，该函数是在对timerfd_remove_cancel函数做调用的时候进行锁操作，<br>在timerfd_setup_cancel函数中也加了锁操作，所以我们着重分析没打补丁之前的timerfd_setup_canceled函数和timerfd_remove_cancel函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timerfd_setup_cancel</span><span class="params">(<span class="keyword">struct</span> timerfd_ctx *ctx, <span class="keyword">int</span> flags)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ((ctx-&gt;clockid == CLOCK_REALTIME ||</div><div class="line">         ctx-&gt;clockid == CLOCK_REALTIME_ALARM) &amp;&amp;</div><div class="line">        (flags &amp; TFD_TIMER_ABSTIME) &amp;&amp; (flags &amp; TFD_TIMER_CANCEL_ON_SET)) &#123;</div><div class="line">        <span class="keyword">if</span> (!ctx-&gt;might_cancel) &#123;</div><div class="line">            ctx-&gt;might_cancel = <span class="literal">true</span>;</div><div class="line">            spin_lock(&amp;cancel_lock);</div><div class="line">            list_add_rcu(&amp;ctx-&gt;clist, &amp;cancel_list);     <span class="comment">/* 对ctx-&gt;clist做添加操作 */</span></div><div class="line">            spin_unlock(&amp;cancel_lock);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;might_cancel) &#123;</div><div class="line">        timerfd_remove_cancel(ctx);                      <span class="comment">/* 对ctx-&gt;clist做删除操作 */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_rcu</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="keyword">new</span>, <span class="keyword">struct</span> list_head *head)</span></span></div><div class="line">&#123;</div><div class="line">    __list_add_rcu(<span class="keyword">new</span>, head, head-&gt;next);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timerfd_remove_cancel</span><span class="params">(<span class="keyword">struct</span> timerfd_ctx *ctx)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (ctx-&gt;might_cancel) &#123;</div><div class="line">        ctx-&gt;might_cancel = <span class="literal">false</span>;</div><div class="line">        spin_lock(&amp;cancel_lock);</div><div class="line">        list_del_rcu(&amp;ctx-&gt;clist);                      <span class="comment">/* 对ctx-&gt;clist做删除操作*/</span></div><div class="line">        spin_unlock(&amp;cancel_lock);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_rcu</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span></div><div class="line">&#123;</div><div class="line">    __list_del_entry(entry);</div><div class="line">    entry-&gt;prev = LIST_POISON2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先来熟悉下timerfd_setup_cancel函数的逻辑,该函数存在两条分支,而这两条分支又都是通过判断ctx-&gt;might_cancel变量的值来控制应该执行哪条分支</p>
<pre><code>1.ctx-&gt;might_cancel == false, call -&gt; list_add_rcu函数
2.ctx-&gt;might_cancel == true, call -&gt; timerfd_remove_cancel函数
</code></pre><p>第一次调用timerfd_setup_cancel函数时,当ctx-&gt;might_cancel等于false的时候,内核会走分支1,然后把ctx-&gt;might_cancel设置为true,然后调用list_add_rcu函数对cancel_list进行添加操作。<br>再次调用timerfd_setup_cancel函数的时候,因为第一次已经把ctx-&gt;might_cancel设置为true了,所以会进入分支2执行,然后调用timerfd_remove_cancel函数,把ctx-&gt;might_cancel设置为false,并且调用list_del_rcu函数对cancel_list进行删除操作。<br>    弄清楚该函数逻辑后再回头看看补丁,也就明白为什么官方要增加两个锁操作了,猜测是因为这里的ctx-&gt;might_cancel在没打补丁之前是允许被别的进程修改的,一加一减本来是没什么问题,如果是单线程对timerfd_setup_cancel函数做调用的话,但是如果是两个线程或多个线程同时调用timerfd_setup_cancel函数那么会怎么样呢?可能就会出现线程同步问题,存在下面3种情况。<br><img src="thread_case.png" alt=""><br>为什么说两个不同的线程修改的会是同一个ctx结构体呢?<br>那么我们可以先来看看ctx这个变量是怎么来的,在系统调用timerfd_create处可以看到ctx是在我们创建计时器对象时申请的,ctx在timerfd_create函数中被创建后,后续函数中的ctx都是以结构体指针(struct timerfd_ctx *)的方式对最开始创建的ctx进行访问,也就是说每个函数中操作的ctx-&gt;might_cancel其实也都是同一个变量,这也证明我们之前的猜测是没毛病的,这样的话我们完全可以创建多个线程与主线程做竞争改变ctx-&gt;might_cancel变量的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE2(timerfd_create, <span class="keyword">int</span>, clockid, <span class="keyword">int</span>, flags)&#123;</div><div class="line">    <span class="keyword">int</span> ufd;</div><div class="line">    <span class="keyword">struct</span> timerfd_ctx *ctx;</div><div class="line">    <span class="keyword">enum</span> alarmtimer_type type;</div><div class="line"></div><div class="line">    <span class="comment">/* Check the TFD_* constants for consistency.  */</span></div><div class="line">    BUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);</div><div class="line">    BUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((flags &amp; ~TFD_CREATE_FLAGS) ||</div><div class="line">        (clockid != CLOCK_MONOTONIC &amp;&amp;</div><div class="line">         clockid != CLOCK_REALTIME &amp;&amp;</div><div class="line">         clockid != CLOCK_REALTIME_ALARM &amp;&amp;</div><div class="line">         clockid != CLOCK_BOOTTIME &amp;&amp;</div><div class="line">         clockid != CLOCK_BOOTTIME_ALARM &amp;&amp;</div><div class="line">         clockid != CLOCK_POWEROFF_ALARM))</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">    ctx = kzalloc(<span class="keyword">sizeof</span>(*ctx), GFP_KERNEL);      <span class="comment">/* ctx在此处被创建,并会被用于后续的操作 */</span></div><div class="line">    <span class="keyword">if</span> (!ctx)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">    init_waitqueue_head(&amp;ctx-&gt;wqh);</div><div class="line">    ctx-&gt;clockid = clockid;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isalarm(ctx)) &#123;</div><div class="line">        type = clock2alarm(ctx-&gt;clockid);</div><div class="line">        alarm_init(&amp;ctx-&gt;t.alarm, type, timerfd_alarmproc);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        hrtimer_init(&amp;ctx-&gt;t.tmr, clockid, HRTIMER_MODE_ABS);</div><div class="line">    &#125;</div><div class="line">    ctx-&gt;moffs = ktime_mono_to_real((<span class="keyword">ktime_t</span>)&#123; .tv64 = <span class="number">0</span> &#125;);</div><div class="line">    ufd = anon_inode_getfd(<span class="string">"[timerfd]"</span>, &amp;timerfd_fops, ctx,</div><div class="line">                   O_RDWR | (flags &amp; TFD_SHARED_FCNTL_FLAGS));</div><div class="line">    <span class="keyword">if</span> (ufd &lt; <span class="number">0</span>)</div><div class="line">        kfree(ctx);</div><div class="line">    <span class="keyword">return</span> ufd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该漏洞属于多线程并行造成的条件竞争问题,从崩溃信息来看,我们触发的应该是第3种情况(对cancel_list做两次删除操作)。</p>
<ul>
<li>第一次删除entry-&gt;prev被设置为了LIST_POISON2(0x00200200),因为属于正常删除,所以此时系统并没有崩溃,</li>
<li>第二次删除在__list_del_entry中取entry_prev指向地址(0x00200200)的值，因为0x00200200该地址未映射,导致访问异常，系统崩溃<br>  因为两次删除的是同一个结构体,而第一次把结构体的entry_prev设置为了0x00200200,当第二次进行取值的时候就出现了访问异常。</li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>ctx-&gt;clist增删调用链:用户层的系统调用timerfd_settime()</p>
<pre><code>timerfd_settime()                                       ---&gt; 增加链
            \__do_timerfd_settime()
                        \__timerfd_setup_cancel()
                                    \__list_add_rcu()
timerfd_settime()                                       ---&gt; 删除链
            \__do_timerfd_settime()
                        \__timerfd_setup_cancel()
                                    \__timerfd_remove_cancel()
                                                \__list_del_rcu()
</code></pre><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>我们可以把条件竞争漏洞进阶为Use_After_Free漏洞,也就是前面提到的3种情况中的第2种情况,该情况会对cancel_list添加两次,那时的ctx-&gt;prev == ctx-&gt;next,然后释放掉ctx-&gt;prev指向的内存—也就是节点本身,但是ctx-&gt;next却对该内存还存在引用,这就给了我们后面的利用思路。<br>总体可分为6步:</p>
<ul>
<li>第一步:调用timerfd_create()函数创建一个timerfd和分配ctx结构体内存</li>
<li>第二步:创建多个线程同时调用timerfd_settime函数,争取触发第2种竞争问题</li>
<li>第三步:调用close函数触发释放结构体内存<pre><code>kfree_rcu(ctx) --&gt; timerfd_release --&gt; timerfd_remove_cancel(ctx)
</code></pre></li>
<li>第四步:通过Heap spray技术对ctx结构体进行喷射,填充释放的ctx结构体</li>
<li>第五步:通过调用settimeofday函数,触发释放后重引用漏洞,从而控制”PC”</li>
<li>第六步:使用gadget对address_limit进行修改,并绕过PXN保护机制</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let_go_timerfd_setup_cancel list_add_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt;  ctx = c5c9b240 prev=200200,next=c5c9b388</div><div class="line">let_go_timerfd_setup_cancel list_add_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt;  ctx = c5c9b240 prev=c049c244,next=c5c9b388</div><div class="line">let_go_timerfd_release &gt;&gt;&gt;&gt;&gt;&gt;&gt;  ctx = c5c9b240 prev=c5c9b2c8,next=c5c9b2c8</div><div class="line">let_go_timerfd_remove_cancel list_del_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt;  ctx = c5c9b240 prev=c5c9b2c8,next=c5c9b2c8    /*第一次删除,此时前后指针已经指向同一地址 0xc5c9b2c8*/</div><div class="line">/*-----------------------------------喷射时机----------------------------------------------- ----*/</div><div class="line">结束时</div><div class="line">let_go_timerfd_release &gt;&gt;&gt;&gt;&gt;&gt;&gt;  ctx = c5c9b300 prev=c5c9b2c8,next=c92891c8                       </div><div class="line">let_go_timerfd_remove_cancel list_del_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt;  ctx = c5c9b300 prev=c5c9b2c8,next=c92891c8    /*第二次删除*/</div></pre></td></tr></table></figure>
<p>首先通过竞争条件对cancel_list链表添加了两次同一地址的结构体,第一次释放结构体时会把ctx-&gt;prev指向的内存释放掉,却并没有操作ctx-&gt;next变量的值,因为ctx-&gt;next == ctx-&gt;prev,ctx-&gt;next还指向自身,所以该ctx内存虽然被释放,但还存在cancel_list链表中,紧接着我们通过喷射，填充之前释放的结构体内存。</p>
<p>然后在用户层触发重引用(settimerofday()),settimerofday底层实现函数timerfd_clock_was_set会对cancel_list链表进行遍历,并且取遍历出的ctx结构体成员wqh的地址作为wake_up_locked()函数的参数传入。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_was_set</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGH_RES_TIMERS</span></div><div class="line">    <span class="comment">/* Retrigger the CPU local events everywhere */</span></div><div class="line">    on_each_cpu(retrigger_next_event, <span class="literal">NULL</span>, <span class="number">1</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    timerfd_clock_was_set();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">timerfd_clock_was_set</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">ktime_t</span> moffs = ktime_mono_to_real((<span class="keyword">ktime_t</span>)&#123; .tv64 = <span class="number">0</span> &#125;);</div><div class="line">    <span class="keyword">struct</span> timerfd_ctx *ctx;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">    rcu_read_lock();</div><div class="line">    list_for_each_entry_rcu(ctx, &amp;cancel_list, clist) &#123;            <span class="comment">/* 遍历喷射ctx结构体 */</span></div><div class="line">        <span class="keyword">if</span> (!ctx-&gt;might_cancel)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        spin_lock_irqsave(&amp;ctx-&gt;wqh.lock, flags);</div><div class="line">        <span class="keyword">if</span> (ctx-&gt;moffs.tv64 != moffs.tv64) &#123;</div><div class="line">            ctx-&gt;moffs.tv64 = KTIME_MAX;</div><div class="line">            ctx-&gt;ticks++;</div><div class="line">            wake_up_locked(&amp;ctx-&gt;wqh);                            <span class="comment">/* 传入喷射结构体 */</span></div><div class="line">        &#125;</div><div class="line">        spin_unlock_irqrestore(&amp;ctx-&gt;wqh.lock, flags);</div><div class="line">    &#125;</div><div class="line">    rcu_read_unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再来看看wake_up_locked函数内部实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_locked(x)       __wake_up_locked((x), TASK_NORMAL, 1)</span></div><div class="line"><span class="keyword">void</span> __wake_up_locked(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode, <span class="keyword">int</span> nr)&#123;</div><div class="line">    __wake_up_common(q, mode, nr, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">            <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)&#123;</div><div class="line">    <span class="keyword">wait_queue_t</span> *curr, *next;</div><div class="line"></div><div class="line">    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</div><div class="line">        <span class="keyword">unsigned</span> flags = curr-&gt;flags;</div><div class="line">        <span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;            <span class="comment">/* 控制内核执行流*/</span></div><div class="line">                (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __wait_queue_head &#123;</div><div class="line">    <span class="keyword">spinlock_t</span>      lock;</div><div class="line">    <span class="keyword">struct</span> list_head    task_list;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __wait_queue <span class="keyword">wait_queue_t</span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>; <span class="comment">/* 函数指针原型 */</span></div><div class="line"><span class="keyword">struct</span> __wait_queue &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        flags;</div><div class="line">    <span class="keyword">void</span>            *<span class="keyword">private</span>;</div><div class="line">    <span class="keyword">wait_queue_func_t</span>   func;           <span class="comment">/* 函数指针 */</span></div><div class="line">    <span class="keyword">struct</span> list_head    task_list;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看到在该函数内部存在一个函数指针(curr-&gt;func)的间接调用,而这个func属于curr的成员,curr又是通过使用list_for_each_entry_safe宏把q-&gt;task_list的next赋值过来的,q又是wake_up_locked函数的参数1,也就是遍历到的ctx成员wqh。</p>
<p>因为cancel_list链表中还存在之前被释放的ctx结构体,所以这里遍历到的ctx结构体也就是我们喷射的ctx结构体,这样看来所有的一切我们似乎都可以控制,只要通过内核源码,精心构造喷射的ctx结构体,绕过内核的一些检测控制内核的执行流还是很容易的。不过构造数据时需要注意一下list_for_each_entry_safe这个宏,不然可能会进入死循环,导致内核崩溃。<br>list_for_each_entry_safe宏</p>
<pre><code>list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list)
    #define list_for_each_entry_safe(pos, n, head, member)          \
    for (pos = list_entry((head)-&gt;next, typeof(*pos), member),  \           /* curr赋值*/
        n = list_entry(pos-&gt;member.next, typeof(*pos), member); \           /* 初始化pos */
         &amp;pos-&gt;member != (head);                    \                       /* 结束条件 */
         pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))       /* 改变条件 */
</code></pre><h3 id="喷射结构体信息"><a href="#喷射结构体信息" class="headerlink" title="喷射结构体信息"></a>喷射结构体信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> timerfd_ctx &#123;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> hrtimer tmr;</div><div class="line">        <span class="keyword">struct</span> alarm alarm;</div><div class="line">    &#125; t;</div><div class="line">    <span class="keyword">ktime_t</span> tintv;</div><div class="line">    <span class="keyword">ktime_t</span> moffs;</div><div class="line">    <span class="keyword">wait_queue_head_t</span> wqh;          <span class="comment">/*&gt;&gt;&gt;&gt;&gt;*/</span></div><div class="line">    u64 ticks;</div><div class="line">    <span class="keyword">int</span> clockid;</div><div class="line">    <span class="keyword">short</span> <span class="keyword">unsigned</span> expired;</div><div class="line">    <span class="keyword">short</span> <span class="keyword">unsigned</span> settime_flags;   <span class="comment">/* to show in fdinfo */</span></div><div class="line">    <span class="keyword">struct</span> rcu_head rcu;</div><div class="line">    <span class="keyword">struct</span> list_head clist;</div><div class="line">    <span class="keyword">bool</span> might_cancel;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<pre><code>32位
(gdb) p &amp;((struct timerfd_ctx*)0)-&gt;might_cancel
$1 = (bool *) 0x90

64位
(gdb) p &amp;((struct timerfd_ctx*)0)-&gt;might_cancel
$1 = (bool *) 0xf0
不同的内核,编译出来的大小也会不一样
</code></pre><h3 id="触发链"><a href="#触发链" class="headerlink" title="触发链"></a>触发链</h3><p>在内核中找到了几条触发链:<br>比较无语的就是这些系统调用函数都会判断当前进程是否有<code>CAP_SYS_TIME</code>权限,如果有该权限才会执行后面的函数,不然就会中途退出</p>
<ul>
<li>sys_stime() -&gt; do_settimeofday() -&gt; clock_was_set() -&gt; timerfd_clock_was_set()</li>
<li>adjtimex() -&gt; do_adjtimex() -&gt; clock_was_set() -&gt; timerfd_clock_was_set()</li>
<li>settimeofday() -&gt; do_sys_settimeofday -&gt; do_settimeofday() -&gt; clock_was_set() -&gt; timerfd_clock_was_set()</li>
</ul>
<p>看了下android中的系统进程(SystemServer)是存在该权限的,所以我也可以结合别的AOSP漏洞,先拿到SystemServer进程的执行权限,然后再利用该内核漏洞进行提权,不过感觉好鸡肋啊￣□￣｜｜</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2017/12/29/CVE-2017-10661/">http://github.com/2017/12/29/CVE-2017-10661/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/" title="Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric"><span>< PreviousPost</span><br><span class="prevTitle">Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric</span></a><a class="nextSlogan" href="/2017/09/20/CVE-2017-9077/" title="CVE-2017-9077"><span>NextPost ></span><br><span class="nextTitle">CVE-2017-9077</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2018-10661"><span class="toc-number">1.</span> <span class="toc-text">CVE-2018-10661</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试内核"><span class="toc-number">1.1.1.</span> <span class="toc-text">测试内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞描述"><span class="toc-number">1.1.2.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Google修复链接"><span class="toc-number">1.1.3.</span> <span class="toc-text">Google修复链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存在漏洞的Nexus内核版本"><span class="toc-number">1.1.4.</span> <span class="toc-text">存在漏洞的Nexus内核版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞复现"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞复现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#红米4A-崩溃日志"><span class="toc-number">1.2.1.</span> <span class="toc-text">红米4A_崩溃日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MI-5C崩溃日志"><span class="toc-number">1.2.2.</span> <span class="toc-text">MI 5C崩溃日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞成因"><span class="toc-number">1.3.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.4.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用思路"><span class="toc-number">1.4.1.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#喷射结构体信息"><span class="toc-number">1.4.2.</span> <span class="toc-text">喷射结构体信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发链"><span class="toc-number">1.4.3.</span> <span class="toc-text">触发链</span></a></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>