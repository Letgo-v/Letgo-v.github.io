<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2017-7533 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2017-7533</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2018/03/25</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Android_Kernel"> Android_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="CVE-2017-7533"><a href="#CVE-2017-7533" class="headerlink" title="CVE-2017-7533"></a>CVE-2017-7533</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h3><ul>
<li>实验环境：Pixel XL [google/marlin/marlin:7.1.1/NMF26U/3562008:user/release-keys]</li>
<li>漏洞类型：条件竞争–&gt;堆溢出，申请堆时使用的字符串长度通过条件竞争改变，导致拷贝时堆内存不够，破坏slab数据</li>
<li>Linux补丁链接：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=49d31c2f389acfe83417083e1208422b4091cd9e" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=49d31c2f389acfe83417083e1208422b4091cd9e</a></li>
<li>Android补丁链接：无(披露信息:<a href="https://source.android.com/security/bulletin/2017-12-01" target="_blank" rel="external">https://source.android.com/security/bulletin/2017-12-01</a>)</li>
<li>漏洞成因：<a href="http://seclists.org/oss-sec/2017/q3/240" target="_blank" rel="external">http://seclists.org/oss-sec/2017/q3/240</a></li>
<li>相关信息：Linux_kernel &lt;= 4.12.4版本,fsnotify实现中存在竞争条件漏洞，发生在inotify_handle_event( )和vfs_rename( )函数之间,因为内核通过这两个函数对同一个文件同时做重命名操作和打开操作时并没有加锁,所以会存在条件竞争漏洞,会导致释放后重引用和堆溢出漏洞。如果本地用户通过构造恶意的数据,可用作本地权限提升和造成拒绝服务。</li>
</ul>
<h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p><a href="https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-7533/exploit.c">https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-7533/exploit.c</a></p>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>首先了解下漏洞涉及到的Inotify机制(文件系统变化通知机制)。<br>为了更好的管理设备，给用户提供更好的服务，如hotplug，udev和inotify就是这类需求催生的，Hotplug是一种内核想用户态应用通报关于热插拔设备事件发生的机制，udev动态维护/dev下的设备文件，inotify是一种文件系统变化通知机制，如文件增加、删除、重命名等事件可以立刻让用户态获得。<br>Inotify API用于检测文件系统变化的机制，可用于检测单个文件，也可以用于检测整个目录，该机制出现的目的是当内核空间发生某种事件之后，可以立即通知用户空间，方便用户做出具体的操作，该漏洞就出现在inotify机制相关的函数中。<br>Inotify即可以监视文件，也可以监视目录<br>Inotify使用系统调用而非SIGIO来通知文件系统时间<br>Inotify使用文件描述符作为接口，因而可以使用通常的I/O操作select和poll来监视文件系统的变化。<br>用户层接口:<br>    inotify_init（void）：用于创建一个inotify的实例，返回inotify事件队列的文件描述符<br>    inotify_add_watch（int fd，const char* pathname，uint32_t mask）：用于添加”watch list（检测列表）”，成功返回一个unique的watch描述符<br>    inotify_rm_watch（int fd，int wd）：用于从watch list中移除检测的对象<br>可以通过read函数获取监听到的事件:<br>    size_t len = read (fd, buf, BUF_LEN); :fd指向inotify实例的文件描述符<br>数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> inotify_event &#123;</div><div class="line">   <span class="keyword">int</span>      wd;           <span class="comment">/* Watch descriptor */</span></div><div class="line">   <span class="keyword">uint32_t</span> mask;     <span class="comment">/* Mask of events */</span></div><div class="line">   <span class="keyword">uint32_t</span> cookie;   <span class="comment">/* Unique cookie associating related events (for rename(2)) */</span></div><div class="line">   <span class="keyword">uint32_t</span> len;        <span class="comment">/* Size of name field */</span></div><div class="line">   <span class="keyword">char</span>     name[];   <span class="comment">/* Optional null-terminated name */</span></div><div class="line">&#125;;</div><div class="line">.wd     : 检测对象的watch descriptor</div><div class="line">.mask   : 检测事件的mask</div><div class="line">.cookie : 和rename事件相关</div><div class="line">.len    : name字段的长度</div><div class="line">.name   : 检测对象的name</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> inotify_event_info &#123;</div><div class="line">    <span class="keyword">struct</span> fsnotify_event fse;</div><div class="line">    <span class="keyword">int</span> wd;</div><div class="line">    u32 sync_cookie;</div><div class="line">    <span class="keyword">int</span> name_len;</div><div class="line">    <span class="keyword">char</span> name[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Inotify 可以监视的文件系统事件包括：</div><div class="line">- IN_ACCESS，即文件被访问</div><div class="line">- IN_MODIFY，文件被 write</div><div class="line">- IN_ATTRIB，文件属性被修改，如 chmod、chown、touch 等</div><div class="line">- IN_CLOSE_WRITE，可写文件被 close</div><div class="line">- IN_CLOSE_NOWRITE，不可写文件被 close</div><div class="line">- IN_OPEN，文件被 open</div><div class="line">- IN_MOVED_FROM，文件被移走,如 mv</div><div class="line">- IN_MOVED_TO，文件被移来，如 mv、cp</div><div class="line">- IN_CREATE，创建新文件</div><div class="line">- IN_DELETE，文件被删除，如 rm</div><div class="line">- IN_DELETE_SELF，自删除，即一个可执行文件在执行时删除自己</div><div class="line">- IN_MOVE_SELF，自移动，即一个可执行文件在执行时移动自己</div><div class="line">- IN_UNMOUNT，宿主文件系统被 umount</div><div class="line">- IN_CLOSE，文件被关闭，等同于(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)</div><div class="line">- IN_MOVE，文件被移动，等同于(IN_MOVED_FROM | IN_MOVED_TO)</div></pre></td></tr></table></figure>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因:"></a>漏洞成因:</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>缓冲区溢出链:<code>open -&gt; SyS_open -&gt; do_sys_open -&gt; fsnotify_open -&gt; fsnotify_parent -&gt; __fsnotify_parent -&gt; fsnotify -&gt; send_to_group -&gt; inotify_handle_event</code><br>来看看inotify机制中的一个堆溢出漏洞，当监控文件被打开时会调用到下面这个函数<br>Heap-Overflow:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_handle_event</span><span class="params">(<span class="keyword">struct</span> fsnotify_group *group,</span></span></div><div class="line">             <span class="keyword">struct</span> inode *inode,</div><div class="line">             <span class="keyword">struct</span> fsnotify_mark *inode_mark,</div><div class="line">             <span class="keyword">struct</span> fsnotify_mark *vfsmount_mark,</div><div class="line">             u32 mask, <span class="keyword">void</span> *data, <span class="keyword">int</span> data_type,</div><div class="line">             <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *file_name, u32 cookie)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> inotify_inode_mark *i_mark;</div><div class="line">    <span class="keyword">struct</span> inotify_event_info *event;</div><div class="line">    <span class="keyword">struct</span> fsnotify_event *fsn_event;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> alloc_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inotify_event_info);    <span class="comment">/* 计算inotify_event_info结构体大小 */</span></div><div class="line">    BUG_ON(vfsmount_mark);</div><div class="line">    <span class="keyword">if</span> ((inode_mark-&gt;mask &amp; FS_EXCL_UNLINK) &amp;&amp;</div><div class="line">        (data_type == FSNOTIFY_EVENT_PATH)) &#123;</div><div class="line">        <span class="keyword">struct</span> path *path = data;</div><div class="line">        <span class="keyword">if</span> (d_unlinked(path-&gt;dentry))</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (file_name) &#123;</div><div class="line">        len = <span class="built_in">strlen</span>(file_name);            <span class="comment">/* 如果文件名为真,则计算文件名长度 */</span></div><div class="line">        alloc_len += len + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    pr_debug(<span class="string">"%s: group=%p inode=%p mask=%x\n"</span>, __func__, group, inode,</div><div class="line">         mask);</div><div class="line">    i_mark = container_of(inode_mark, <span class="keyword">struct</span> inotify_inode_mark,</div><div class="line">                  fsn_mark);</div><div class="line">    event = kmalloc(alloc_len, GFP_KERNEL);    <span class="comment">/* 分配内存大小等于 sizeof(inotify_event_info) + sizeof(file_name) */</span></div><div class="line">    <span class="keyword">if</span> (unlikely(!event))</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    fsn_event = &amp;event-&gt;fse;</div><div class="line">    fsnotify_init_event(fsn_event, inode, mask);</div><div class="line">    event-&gt;wd = i_mark-&gt;wd;</div><div class="line">    event-&gt;sync_cookie = cookie;</div><div class="line">    event-&gt;name_len = len;</div><div class="line">    <span class="keyword">if</span> (len)</div><div class="line">        <span class="built_in">strcpy</span>(event-&gt;name, file_name);        <span class="comment">/* 溢出点 把file_name拷贝到之前分配的内存中 */</span></div><div class="line">    ret = fsnotify_add_event(group, fsn_event, inotify_merge);</div><div class="line">    <span class="keyword">if</span> (ret) &#123;</div><div class="line">        <span class="comment">/* Our event wasn't used in the end. Free it. */</span></div><div class="line">        fsnotify_destroy_event(group, fsn_event);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (inode_mark-&gt;mask &amp; IN_ONESHOT)</div><div class="line">        fsnotify_destroy_mark(inode_mark, group);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">溢出结构体</div><div class="line"><span class="keyword">struct</span> inotify_event_info &#123;</div><div class="line">    <span class="keyword">struct</span> fsnotify_event fse;</div><div class="line">    <span class="keyword">int</span> wd;</div><div class="line">    u32 sync_cookie;</div><div class="line">    <span class="keyword">int</span> name_len;</div><div class="line">    <span class="keyword">char</span> name[];                    <span class="comment">/* 拷贝时存在溢出 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们来看看这个函数，首先计算inotify_event_info结构体的大小，然后计算目标文件名的长度，通过前面计算的值使用kmalloc分配出来一块内存，如果file_name的长度不为0，那么就使用strcpy函数把file_name拷贝到event-&gt;name处，也就是之前通过计算file_name长度申请的内存中。<br>问题就出在这个函数中，仔细看会发现这里存在一个堆溢出漏洞(HeapOverflow)，实际上这个HeapOverflow是因为竞争条件(Race-condition)产生的。<br>在访问file_name资源时未做加锁操作，存在一种情况是第一次计算长度时的file_name与第二次strcpt拷贝时的file_name内容不一致，因为strcpy的目标内存是通过计算第一次file_name的长度申请的内存，并且使用的还是strcpy不安全的拷贝函数，所以如果第二次的file_name内容的长度大于第一次计算的长度，那么这里就存在一个堆溢出漏洞。<br>这种情况很好触发的，只需要再开启一个线程，当线程A执行完strlen(file_name)和kmalloc(alloc_len, GFP_KERNEL)操作后，线程B去修改file_name的内容，当线程A再返回去执行strcpy时就会出现前面说到的堆溢出情况。<br><img src="heapoverflow.png" alt=""><br>Race-condition:<br>常见的竞争条件漏洞分为两种:<br>第1种属于time-of-check-to-time-of-use漏洞,程序先检查对象的某个特征,后续的动作是假设这些特征一直保持的情况下作出的,但是这时的特征可能已经不具备了,导致信息不同步问题。<br>第2种是因为程序的编写者考虑不周全,操作某些关键数据时未对数据做多线程/进程保护,导致多线程/进程访问同一资源时产生资源未及时更新的问题,可以通过这个冲突来对系统进行攻击。<br>避免出现竞争条件可以通过对关键数据做加锁操作。<br><a href="http://xueshu.baidu.com/s?wd=paperuri%3A%28b62cc2d4ee50ac57561ecefd73bfe81a%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http%3A%2F%2Fwww.doc88.com%2Fp-0989083125147.html&amp;ie=utf-8&amp;sc_us=417778369346449954" target="_blank" rel="external">竞争条件漏洞模式及其检测</a></p>
<p>条件竞争模式:<br>具备的条件:</p>
<ol>
<li>存在两个(或两个以上)时间发生,两个事件存在一定的间隔时间,两个事件存在一定的关系,即第二个事件(及其后的事件)依赖于第一个事件。</li>
<li>攻击者能够改变第一个事件所产生的,为第二个事件所依赖的假设。<br>两事件之间是否存在间隔称为”编程条件”,间隔本身称为”编程间隔”,攻击者不但要发现这个间隔,还需要能够影响由第一个事件所产生的假设,这一条件称为”环境条件”。</li>
</ol>
<p>该漏洞分为长文件名与短文件名两种溢出方式</p>
<ul>
<li>长文件名使用kmalloc_256溢出</li>
<li>短文件名使用kmalloc_64溢出,不过现在的Android手机貌似已经去除了kmalloc_64分配<br>要理解这两种溢出方式我们需要先来看看内核是如何存储溢出字符串的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> dentry &#123;</div><div class="line">    <span class="comment">/* RCU lookup touched fields */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;        <span class="comment">/* protected by d_lock */</span></div><div class="line">    <span class="keyword">seqcount_t</span> d_seq;        <span class="comment">/* per dentry seqlock */</span></div><div class="line">    <span class="keyword">struct</span> hlist_bl_node d_hash;    <span class="comment">/* lookup hash list */</span></div><div class="line">    <span class="keyword">struct</span> dentry *d_parent;    <span class="comment">/* parent directory */</span>    <span class="comment">/* 父目录的目录项对象 */</span></div><div class="line">    <span class="keyword">struct</span> qstr d_name;                    <span class="comment">/* qstr结构体中的name元素指向真正的文件名字符串 */</span></div><div class="line">    <span class="keyword">struct</span> inode *d_inode;        <span class="comment">/* Where the name belongs to - NULL is</span></div><div class="line">                     * negative */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];    <span class="comment">/* small names */</span>    <span class="comment">/* 文件名长度&lt;32时会使用该数组存放文件名 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Ref lookup also touches following */</span></div><div class="line">    <span class="keyword">struct</span> lockref d_lockref;    <span class="comment">/* per-dentry lock and refcount */</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> dentry_operations *d_op;</div><div class="line">    <span class="keyword">struct</span> super_block *d_sb;    <span class="comment">/* The root of the dentry tree */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;        <span class="comment">/* used by d_revalidate */</span></div><div class="line">    <span class="keyword">void</span> *d_fsdata;            <span class="comment">/* fs-specific data */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head d_lru;        <span class="comment">/* LRU list */</span></div><div class="line">    <span class="keyword">struct</span> list_head d_child;    <span class="comment">/* child of parent list */</span></div><div class="line">    <span class="keyword">struct</span> list_head d_subdirs;    <span class="comment">/* our children */</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * d_alias and d_rcu can share memory</div><div class="line">     */</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node d_alias;    <span class="comment">/* inode alias list */</span></div><div class="line">         <span class="keyword">struct</span> rcu_head d_rcu;</div><div class="line">    &#125; d_u;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>dentry(directory entry):目录项<br>进程每次open一个文件，就会有一个file对象与之对应，同一个文件可以打开多次从而得到不同的file对象，file对象描述了被打开文件的属性，读写的偏移指针等信息。<br>不同的file对象可以对应同一个dentry结构。dentry结构体保存则目录项和对应的文件inode信息。<br>inode中不存储文件名字，只存储节点号，而dentry则保存文件名和预期对应的节点号，所以可以通过不同的dentry访问同一个inode。<br>再来看一下dentry结构体是怎么分配的<br>内存申请链:<code>rename -&gt; sys_renameat2 -&gt; lookup_hash -&gt; __lookup_hash -&gt; lookup_dcache -&gt; d_alloc -&gt; __d_alloc</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> dentry *__d_alloc(<span class="keyword">struct</span> super_block *sb, <span class="keyword">const</span> <span class="keyword">struct</span> qstr *name)&#123;</div><div class="line">    <span class="keyword">struct</span> dentry *dentry;</div><div class="line">    <span class="keyword">char</span> *dname;</div><div class="line"></div><div class="line">    dentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);<span class="comment">/* 创建一个dentry结构体 */</span></div><div class="line">    <span class="keyword">if</span> (!dentry)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    dentry-&gt;d_iname[DNAME_INLINE_LEN<span class="number">-1</span>] = <span class="number">0</span>;            <span class="comment">/* d_iname数组末尾填上0结尾 */</span></div><div class="line">    <span class="keyword">if</span> (name-&gt;len &gt; DNAME_INLINE_LEN<span class="number">-1</span>) &#123;                <span class="comment">/* 判断文件名的长度是否大于d_iname数组的大小 DNAME_INLINE_LEN == 32 */</span></div><div class="line">        <span class="keyword">size_t</span> size = offsetof(<span class="keyword">struct</span> external_name, name[<span class="number">1</span>]);    <span class="comment">/* 进入文件名长度 &gt; 32的处理流程 */</span></div><div class="line">        <span class="keyword">struct</span> external_name *p = kmalloc(size + name-&gt;len, GFP_KERNEL);<span class="comment">/* 分配内存 大小等于external_name结构体大小 + 字符串长度 */</span></div><div class="line">        <span class="keyword">if</span> (!p) &#123;</div><div class="line">            kmem_cache_free(dentry_cache, dentry);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        atomic_set(&amp;p-&gt;u.count, <span class="number">1</span>);                <span class="comment">/* external_name结构体的u.count元素为引用计数 并设置为1 */</span></div><div class="line">        dname = p-&gt;name;                    <span class="comment">/* 让dname指针指向external_name结构体的name元素 */</span></div><div class="line">        <span class="keyword">if</span> (IS_ENABLED(CONFIG_DCACHE_WORD_ACCESS))</div><div class="line">            kasan_unpoison_shadow(dname,</div><div class="line">                round_up(name-&gt;len + <span class="number">1</span>,    <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)));</div><div class="line">    &#125; <span class="keyword">else</span>  &#123;                            <span class="comment">/* 如果文件名长度小于DNAME_INLINE_LEN(32个字符)那么直接让dname指向dentry结构体的d_iname数组元素 */</span></div><div class="line">        dname = dentry-&gt;d_iname;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dentry-&gt;d_name.len = name-&gt;len;                    <span class="comment">/* 初始化dentry结构体中代表文件名长度的元素 */</span></div><div class="line">    dentry-&gt;d_name.hash = name-&gt;hash;</div><div class="line">    <span class="built_in">memcpy</span>(dname, name-&gt;name, name-&gt;len);                <span class="comment">/* 把实际的文件名拷贝到dname指针指向的内存 如果文件名长度&lt;32就拷贝到dentry-&gt;d_iname,如果长度&gt;32就拷贝到external_name-&gt;name */</span></div><div class="line">    dname[name-&gt;len] = <span class="number">0</span>;                        <span class="comment">/* 添加0字符结尾 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Make sure we always see the terminating NUL character */</span></div><div class="line">    smp_wmb();</div><div class="line">    dentry-&gt;d_name.name = dname;                    <span class="comment">/* 让dentry结构体的d_name.name元素指向dname的位置(实际文件名)*/</span></div><div class="line"></div><div class="line">    dentry-&gt;d_lockref.count = <span class="number">1</span>;</div><div class="line">    dentry-&gt;d_flags = <span class="number">0</span>;</div><div class="line">    spin_lock_init(&amp;dentry-&gt;d_lock);</div><div class="line">    seqcount_init(&amp;dentry-&gt;d_seq);</div><div class="line">    dentry-&gt;d_inode = <span class="literal">NULL</span>;</div><div class="line">    dentry-&gt;d_parent = dentry;</div><div class="line">    dentry-&gt;d_sb = sb;</div><div class="line">    dentry-&gt;d_op = <span class="literal">NULL</span>;</div><div class="line">    dentry-&gt;d_fsdata = <span class="literal">NULL</span>;</div><div class="line">    INIT_HLIST_BL_NODE(&amp;dentry-&gt;d_hash);</div><div class="line">    INIT_LIST_HEAD(&amp;dentry-&gt;d_lru);</div><div class="line">    INIT_LIST_HEAD(&amp;dentry-&gt;d_subdirs);</div><div class="line">    INIT_HLIST_NODE(&amp;dentry-&gt;d_u.d_alias);</div><div class="line">    INIT_LIST_HEAD(&amp;dentry-&gt;d_child);</div><div class="line">    d_set_d_op(dentry, dentry-&gt;d_sb-&gt;s_d_op);</div><div class="line">    this_cpu_inc(nr_dentry);</div><div class="line">    <span class="keyword">return</span> dentry;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> external_name &#123;                                <span class="comment">/* 如果文件名大于32,那么内核会创建一个该结构体用来存放新文件名 */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">atomic_t</span> count;                                <span class="comment">/* 引用计数 */</span></div><div class="line">        <span class="keyword">struct</span> rcu_head head;</div><div class="line">    &#125; u;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[];                                <span class="comment">/* 文件名 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>首先根据文件名的长度判断属于长文件还是短文件</p>
<ul>
<li>如果大于32个字符就属于长文件，申请一片空间，申请的空间大小等于external_name结构体大小加文件名长度，分配成功后就把文件名拷贝到申请的内存中，其实这就相当于创建了一个external_name结构体，然后把文件名拷贝到external_name结构体后面。</li>
<li>如果小于等于32个字符那么就属于短文件，直接把文件名拷贝到dentry结构体变量的d_iname数组中。</li>
</ul>
<p>不管是长文件还是短文件，最后都会把dentry结构体中的d_name.name指向最终存放文件名的位置，这就是文件名两种不同的存放方式。</p>
<p>再来看下rename时是如何把oldname改为newname的<br>重命名链: <code>rename -&gt; sys_renameat2 -&gt; vfs_rename -&gt; d_move -&gt; __d_move -&gt; copy_name</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE2(rename, <span class="keyword">const</span> <span class="keyword">char</span> __user *, oldname, <span class="keyword">const</span> <span class="keyword">char</span> __user *, newname)&#123;</div><div class="line">    <span class="keyword">return</span> sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">SYSCALL_DEFINE5(renameat2, <span class="keyword">int</span>, olddfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *, oldname,</div><div class="line">        <span class="keyword">int</span>, newdfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *, newname, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</div></pre></td></tr></table></figure></p>
<p>Use-After-Free:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_name</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> dentry *target)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> external_name *old_name = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (unlikely(dname_external(dentry)))            <span class="comment">/* 判断old文件名是长文件名还是短文件名 */</span></div><div class="line">        old_name = external_name(dentry);            <span class="comment">/* 如果为长文件名,就备份一下old_name 后续做释放 */</span></div><div class="line">    <span class="keyword">if</span> (unlikely(dname_external(target))) &#123;            <span class="comment">/* 判断新文件名长度是否大于32,大于32进入*/</span></div><div class="line">        atomic_inc(&amp;external_name(target)-&gt;u.count);    <span class="comment">/* 引用计数-1*/</span></div><div class="line">        dentry-&gt;d_name = target-&gt;d_name;        <span class="comment">/* 让旧文件名dentry的d_name元素直接指向新文件名dentry的d_name */</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">memcpy</span>(dentry-&gt;d_iname, target-&gt;d_name.name,    <span class="comment">/* 否则表示新文件名长度小于32,直接把newname拷贝到栈中的dentry-&gt;d_iname处 */</span></div><div class="line">                target-&gt;d_name.len + <span class="number">1</span>);</div><div class="line">        dentry-&gt;d_name.name = dentry-&gt;d_iname;</div><div class="line">        dentry-&gt;d_name.hash_len = target-&gt;d_name.hash_len;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (old_name &amp;&amp; likely(atomic_dec_and_test(&amp;old_name-&gt;u.count)))<span class="comment">/* 如果老文件名长度&gt;64 并且结构体引用计数为0,那么就把老文件名做释放操作 */</span></div><div class="line">        kfree_rcu(old_name, u.head);            <span class="comment">/* old_name -&gt; UAF结构体 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dname_external</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> dentry *dentry)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> dentry-&gt;d_name.name != dentry-&gt;d_iname;        <span class="comment">/* 检查dentry的d_name.name 与 dentry-&gt;d_iname是否指向同一块内存 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> external_name *<span class="title">external_name</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span>    <span class="comment">/* 获取文件名的位置 */</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> container_of(dentry-&gt;d_name.name, <span class="keyword">struct</span> external_name, name[<span class="number">0</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一样的，首先还是判断old文件属于长文件还是短文件。如果是短文件，直接把新文件名直接拷贝到旧dentry变量中的d_iname数组中,然后让旧dentry-&gt;d_name指向dentry-&gt;d_iname。如果是长文件名那么就把odl_name指针指向旧dentry-&gt;d_name指向的结构体方便后面释放时索引，然后把旧dentry-&gt;d_name指向新dentry-&gt;d_name,接着判断old_name结构体中的引用计数是否为0,如果为0那么就使用kfree_rcu释放掉old_name这个结构体。<br>这里还存在一个UAF漏洞，因为这里被释放的old_name-&gt;name在inotify_handle_event函数中存在释放后重引用的情况，后面的漏洞利用会用到这个UAF漏洞。</p>
<h3 id="触发模型"><a href="#触发模型" class="headerlink" title="触发模型"></a>触发模型</h3><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="随机地址写任意值-gt-可控地址写任意值"><a href="#随机地址写任意值-gt-可控地址写任意值" class="headerlink" title="随机地址写任意值 -&gt; 可控地址写任意值"></a>随机地址写任意值 -&gt; 可控地址写任意值</h4><p>1.因为最终触发的是一个堆溢出，会对溢出对象后面的内存进行写数据操作，不过这里被写的地址是我们不可控的，因为我们不知道被溢出的那个event对象会被分配在内存的什么位置，如果想要在指定的地址上写任意值的话还需要做一些别的操作。</p>
<p>在对内存进行布局之前我们先来看看pipe subsystem中存在的一个TOCTTOU（time of check to time of user）检查时间到使用时间的问题，就是检查值的操作与使用值的操作之间存在间隔，可以在这间隔时间去修改检查后的值，这就会导致使用时的值实际上已经不是检查时的值了。这也属于竞争条件漏洞的一种，这和7533的竞争条件原理差不多。不过在pipe中的time of use是我们可控的。</p>
<p>通过readv和writev来控制检查/使用时间<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">do_readv_writev</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">struct</span> file *file,</span></span></div><div class="line">                   <span class="keyword">const</span> <span class="keyword">struct</span> iovec __user * uvector,</div><div class="line">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">loff_t</span> *pos)&#123;</div><div class="line">    <span class="keyword">size_t</span> tot_len;</div><div class="line">    <span class="keyword">struct</span> iovec iovstack[UIO_FASTIOV];</div><div class="line">    <span class="keyword">struct</span> iovec *iov = iovstack;</div><div class="line">    <span class="keyword">ssize_t</span> ret;</div><div class="line">    <span class="keyword">io_fn_t</span> fn;</div><div class="line">    <span class="keyword">iov_fn_t</span> fnv;</div><div class="line">    <span class="keyword">iter_fn_t</span> iter_fn;</div><div class="line">    ret = rw_copy_check_uvector(type, uvector, nr_segs,                        <span class="comment">/* rw_copy_check_uvector对传入的用户层的iovec做校验，并拷贝到内核态 */</span></div><div class="line">                    ARRAY_SIZE(iovstack), iovstack, &amp;iov);</div><div class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    tot_len = ret;</div><div class="line">    ret = rw_verify_area(type, file, pos, tot_len);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    fnv = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (type == READ) &#123;                                                        <span class="comment">/* read */</span></div><div class="line">        fn = file-&gt;f_op-&gt;read;</div><div class="line">        fnv = file-&gt;f_op-&gt;aio_read;</div><div class="line">        iter_fn = file-&gt;f_op-&gt;read_iter;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;                                                                <span class="comment">/* write */</span></div><div class="line">        fn = (<span class="keyword">io_fn_t</span>)file-&gt;f_op-&gt;write;</div><div class="line">        fnv = file-&gt;f_op-&gt;aio_write;</div><div class="line">        iter_fn = file-&gt;f_op-&gt;write_iter;</div><div class="line">        file_start_write(file);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (iter_fn)</div><div class="line">        ret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len,</div><div class="line">                        pos, iter_fn);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fnv)</div><div class="line">        ret = do_sync_readv_writev(file, iov, nr_segs, tot_len,</div><div class="line">                        pos, fnv);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ret = do_loop_readv_writev(file, iov, nr_segs, pos, fn);</div><div class="line">    <span class="keyword">if</span> (type != READ)</div><div class="line">        file_end_write(file);</div><div class="line">out:</div><div class="line">    <span class="keyword">if</span> (iov != iovstack)</div><div class="line">        kfree(iov);</div><div class="line">    <span class="keyword">if</span> ((ret + (type == READ)) &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (type == READ)</div><div class="line">            fsnotify_access(file);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            fsnotify_modify(file);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> rw_copy_check_uvector(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">struct</span> iovec __user * uvector,</div><div class="line">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">unsigned</span> <span class="keyword">long</span> fast_segs,</div><div class="line">                  <span class="keyword">struct</span> iovec *fast_pointer,</div><div class="line">                  <span class="keyword">struct</span> iovec **ret_pointer)&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seg;</div><div class="line">    <span class="keyword">ssize_t</span> ret;</div><div class="line">    <span class="keyword">struct</span> iovec *iov = fast_pointer;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nr_segs == <span class="number">0</span>) &#123;                            <span class="comment">/* nr_segs表示iovec的个数       等于0就退出*/</span></div><div class="line">        ret = <span class="number">0</span>;</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nr_segs &gt; UIO_MAXIOV) &#123;                    <span class="comment">/* nr_segs不能大于UIO_MAXIOV（1024） */</span></div><div class="line">        ret = -EINVAL;</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (nr_segs &gt; fast_segs) &#123;                    <span class="comment">/* 如果nr_segs 大于8(ARRAY_SIZE(iovstack))  那么就重新申请内存进行存储,小于8就直接放在开始申请的栈中的数组里面 */</span></div><div class="line">        iov = kmalloc(nr_segs*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec), GFP_KERNEL);</div><div class="line">        <span class="keyword">if</span> (iov == <span class="literal">NULL</span>) &#123;</div><div class="line">            ret = -ENOMEM;</div><div class="line">            <span class="keyword">goto</span> out;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (copy_from_user(iov, uvector, nr_segs*<span class="keyword">sizeof</span>(*uvector))) &#123;    <span class="comment">/* 把应用层的数据拷贝新内核层中 */</span></div><div class="line">        ret = -EFAULT;</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (seg = <span class="number">0</span>; seg &lt; nr_segs; seg++) &#123;    <span class="comment">/* 对iovec中的iov_base与iov_len做合法性检查，iov_base必须指向用户态且iov_len不存在溢出*/</span></div><div class="line">        <span class="keyword">void</span> __user *buf = iov[seg].iov_base;</div><div class="line">        <span class="keyword">ssize_t</span> len = (<span class="keyword">ssize_t</span>)iov[seg].iov_len;</div><div class="line"></div><div class="line">        <span class="comment">/* see if we we're about to use an invalid len or if</span></div><div class="line">         * it's about to overflow ssize_t */</div><div class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> out;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (type &gt;= <span class="number">0</span></div><div class="line">            &amp;&amp; unlikely(!access_ok(vrfy_dir(type), buf, len))) &#123;</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> out;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (len &gt; MAX_RW_COUNT - ret) &#123;</div><div class="line">            len = MAX_RW_COUNT - ret;</div><div class="line">            iov[seg].iov_len = len;</div><div class="line">        &#125;</div><div class="line">        ret += len;</div><div class="line">    &#125;</div><div class="line">out:</div><div class="line">    *ret_pointer = iov;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rw_copy_check_uvector函数主要是判断iovec的个数是否为零和是否大于1024，如果都不成立的话就使用copy_from_user函数把用户态的iovec数据拷贝到内核态的中，如果传入的iovec个数大于8个就使用kmalloc在内核态申请一片内存进行存放用户态的iovecarray数据，如果小于等于8个那么就直接使用内核栈存放iovec array数据，接着遍历判断每个iovec结构体中的iov_base是否属于用户态地址并且iov_len是否不会出现溢出。这里的检测就是前面说的TOCTTOU中的time of check操作。<br>iovec array在内核中存放的样子<br><img src="no_write_iovec.png" alt=""></p>
<p>检查完毕后通过判断type来区分是readv还是writev，如果是readv函数调用进来的，会走到pipe_read函数中，pipe_read函数会检查iovec中的iov_base指向的地址是否可写，pipe写端是否有数据，如果此时写端没有数据该函数就进入到等待模式，等待witev对pipe进行写入，当我们在用户态调用writev对pipe进行写入的时候，pipe_read就会把我们写入到pipe中的数据写入对应的iov_base指向的地址中。这里就属于TOCTTOU中的time of use操作。因为写入时间通过用户态调用writev来触发的，所以写入的值和写入的时机都是我们可控的。</p>
<p>如果我们能够在第一次检查iov_base指向地址是否为用户态地址后把iov_base指向的地址改为内核地址，当在第二次检查时因为只检查了是否可写而没检查是否为用户态地址，所以后续pipe_read会直接把我们writev传入的值写入到iov_base指向的内核地址中，这就达到了一个内核地址写操作。<br><img src="write_iovec.png" alt=""></p>
<p>引用一下少仲大佬的流程图<br><img src="iii.png" alt=""></p>
<p>结合前面的堆溢出漏洞，可以把需要写入的内核地址溢出到iov_base上，这样写入地址，写入值都由我们控制了，不过写入地址有一个限制，因为是strcpy函数导致的溢出，所以写入地址中不能带有0字符不然就会存在截断问题。</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>现在的问题是如何把iovec结构体数组布局到受害对象event结构体后面？<br>我们需要想办法对堆内存进行布局，促使溢出结构体后面是我们可控的数据（iovec结构体数组），这样在触发堆溢出的时候才能完成对iovec-&gt;iov_base值的非正常修改。<br>为了更容易让堆布局到我们理想的状态，我们可以先使用event对象把内核中slab空洞填满，然后内核会分配新的slab内存块，接着申请大量的iovec数组，然后间隔释放iovec数组同时再次创建event对象去填充间隔释放的iovec数组与触发堆溢出漏洞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Event object / Payload / Victim object</div><div class="line"></div><div class="line">Event object    （监听事件对象）</div><div class="line">Payload == 喷射数据(也就是<span class="built_in">strcpy</span>操作的数据，Event对象中的name指向)</div><div class="line">Victim object   （pipe受害对象）</div></pre></td></tr></table></figure></p>
<p>理想的内存布局<br><img src="heap.png" alt=""></p>
<p>竞争条件 -&gt; 释放后重引用 -&gt; 堆溢出</p>
<h4 id="构造溢出数据"><a href="#构造溢出数据" class="headerlink" title="构造溢出数据"></a>构造溢出数据</h4><p>这里需要注意网上公布的poc是基于短文件名的，但是android默认好像已经没有使用kmalloc-64了，在kmalloc时最少都会使用kmalloc-128，这样就导致文件名太短无法溢出到下一个slab，所以在android上运行poc每次都只是检测到了溢出但是并没有导致设备崩溃，下面是通过构造长文件名来触发溢出kmalloc-256。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inotify_event_info结构体大小为<span class="number">0x2c</span>，也就是说最起码都有<span class="number">0x2c</span>大小</div><div class="line">(gdb) p &amp;((<span class="keyword">struct</span> inotify_event_info*)<span class="number">0</span>)-&gt;name</div><div class="line">$<span class="number">1</span> = (<span class="keyword">char</span> (*)[]) <span class="number">0x2c</span>  &lt;-- <span class="number">44</span></div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">264</span> - <span class="number">256</span> = <span class="number">8</span>  需要溢出<span class="number">8</span>个字节</div><div class="line">事件结构体: <span class="number">44</span> + <span class="number">200</span> = <span class="number">244</span></div><div class="line"><span class="number">264</span> - <span class="number">244</span> = <span class="number">20</span>(喷射字符串必须比实际字符串多<span class="number">20</span>)</div><div class="line">喷射结构体：<span class="number">44</span> + <span class="number">200</span> + <span class="number">20</span> = <span class="number">264</span></div><div class="line">实际拷贝字符串长度：<span class="number">200</span> + <span class="number">20</span> = <span class="number">220</span> (拷贝的长度)</div><div class="line">喷射构造:<span class="number">16</span> + <span class="number">220</span> = <span class="number">236</span>(实际喷射字节 <span class="number">16</span>的UAF结构体头部,<span class="number">220</span>的实际字符串拷贝)</div><div class="line"><span class="number">16</span> + <span class="number">220</span> = <span class="number">16</span> + <span class="number">212</span> + <span class="number">8</span> = 头部(<span class="number">16</span>) + 填充值(<span class="number">212</span>) + 写入地址(<span class="number">8</span>)</div></pre></td></tr></table></figure>
<p>构造好了一个任意地址读写，那么提权就只是套路了。</p>
<h3 id="思考短文件名"><a href="#思考短文件名" class="headerlink" title="思考短文件名"></a>思考短文件名</h3><p>如果内核支持kmalloc-64的话短文件名其实也可以利用，比如HUAWEI Mate9，可以通过spray ipv6_mc_socklist，触发堆溢出对rcu进行覆盖，通过rcu回调来控制内核执行流程，只是猜想并没有验证，以后有时间再看看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ipv6_mc_socklist &#123;</div><div class="line">	<span class="keyword">struct</span> in6_addr		addr;</div><div class="line">	<span class="keyword">int</span>			ifindex;</div><div class="line">	<span class="keyword">struct</span> ipv6_mc_socklist __rcu *next;	<span class="comment">/* &lt;&lt;&lt;&lt;&lt;&lt;&lt; Overflow &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; */</span></div><div class="line">	<span class="keyword">rwlock_t</span>		sflock;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sfmode;		<span class="comment">/* MCAST_&#123;INCLUDE,EXCLUDE&#125; */</span></div><div class="line">	<span class="keyword">struct</span> ip6_sf_socklist	*sflist;</div><div class="line">	<span class="keyword">struct</span> rcu_head		rcu;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h3><p>现在我们实现了任意地址写任意值，那么如何进行权限提升呢？</p>
<ol>
<li>通过漏洞把ptmx-&gt;check_flags改为work_for_cpu_fn</li>
<li>通过fcntl函数触发work_for_cpu_fn，间接调用register_sysctl_table函数注册新sysctl</li>
<li>通过read触发新sysctl的处理函数，间接调用kernel_sock_ioctl函数修改limit</li>
<li>通过pipe对内核进行任意读写，patch关键结构体</li>
</ol>
<h4 id="减少硬编码的方式"><a href="#减少硬编码的方式" class="headerlink" title="减少硬编码的方式"></a>减少硬编码的方式</h4><p>在kernel\sysctl.c这个文件中存在对kptr_restrict的sysctl结构体进行初始化操作，我们可以通过内存遍历获取到kptr_restrict符号的地址，然后修改为0，这样就关闭了kptr_restrict保护机制<br>用来过滤一些地址，以此避免将内核地址泄漏给攻击者，通过配置kptr_restrict的值来控制是否开启:</p>
<ul>
<li>0:完全禁止</li>
<li>1:使用”%pk”打印的内核指针被隐藏(以0替换)，除非用户存在CAP_SYSLOG权限。</li>
<li>2:所有内核使用”%pk”打印的都被隐藏</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    .procname    = <span class="string">"kptr_restrict"</span>,</div><div class="line">    .data        = &amp;kptr_restrict,</div><div class="line">    .maxlen        = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</div><div class="line">    .mode        = <span class="number">0644</span>,</div><div class="line">    .proc_handler    = proc_dointvec_minmax_sysadmin,</div><div class="line">    .extra1        = &amp;zero,</div><div class="line">    .extra2        = &amp;two,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.text:FFFFFFC001237700 aKptrRestrict   DCB <span class="string">"kptr_restrict"</span>,<span class="number">0</span></div><div class="line"></div><div class="line">.text:FFFFFFC00156D0C8                 DCQ <span class="number">0xFFFFFFC001237700</span></div><div class="line">.text:FFFFFFC00156D0D0                 DCQ <span class="number">0xFFFFFFC001760B78</span></div><div class="line">.text:FFFFFFC00156D0D8                 DCQ <span class="number">0x1A400000004</span></div><div class="line">.text:FFFFFFC00156D0E0                 DCQ <span class="number">0</span></div><div class="line"></div><div class="line">marlin:/data/local/tmp $ cat /proc/kallsyms |grep kptr_restrict</div><div class="line">ffffffc001760b78 B kptr_restrict</div></pre></td></tr></table></figure>
<h4 id="exploit编写流程"><a href="#exploit编写流程" class="headerlink" title="exploit编写流程"></a>exploit编写流程</h4><p>6.0~7.0 -&gt; root方案<br>利用步骤</p>
<ul>
<li>步骤0：准备资源并填充缓冲区</li>
<li>步骤1：产生读取线程并使用iovec对象对堆进行布局</li>
<li>步骤2：产生竞争线程</li>
<li>第3步：赢得比赛，触发溢出实现任意地址写任意值</li>
<li>fcntl（ptmx_fd，F_SETFL，0x40002000）== 0x40002000</li>
<li>第4步：覆盖uid，禁用SELinux并产生ROOT外壳</li>
</ul>
<p><img src="piexl_xl_root.png" alt=""></p>
<h3 id="修补方案"><a href="#修补方案" class="headerlink" title="修补方案"></a>修补方案</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最开始分析的时候被网上公布的poc坑了,一直以为只是简单的堆溢出漏洞,后来才发现还存在一个UAF漏洞。<br>一般的条件竞争漏洞修补是都会进行加锁，所以分析下加锁的用意可能会对理解漏洞成因有所帮助。<br>又学习了一种新的利用方法通过布局iovec实现任意读写的方式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-inotifynew/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-inotifynew/</a><br><a href="https://www.anquanke.com/post/id/129468" target="_blank" rel="external">https://www.anquanke.com/post/id/129468</a><br><a href="https://speakerdeck.com/retme7/the-art-of-exploiting-unconventional-use-after-free-bugs-in-android-kernel" target="_blank" rel="external">The-Art-of-Exploiting-Unconventional-Use-after-free-Bugs-in-Android-Kernel</a><br><a href="https://www.blackhat.com/docs/asia-18/asia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features.pdf" target="_blank" rel="external">asia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2018/03/25/CVE-2017-7533/">http://github.com/2018/03/25/CVE-2017-7533/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2018/04/30/linux内核调试环境搭建/" title="linux内核调试环境搭建"><span>< PreviousPost</span><br><span class="prevTitle">linux内核调试环境搭建</span></a><a class="nextSlogan" href="/2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/" title="Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric"><span>NextPost ></span><br><span class="nextTitle">Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2017-7533"><span class="toc-number">1.</span> <span class="toc-text">CVE-2017-7533</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞信息"><span class="toc-number">1.1.1.</span> <span class="toc-text">漏洞信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞验证"><span class="toc-number">1.1.2.</span> <span class="toc-text">漏洞验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背景知识"><span class="toc-number">1.1.3.</span> <span class="toc-text">背景知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞成因"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞成因:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相关函数"><span class="toc-number">1.2.1.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发模型"><span class="toc-number">1.2.2.</span> <span class="toc-text">触发模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用思路"><span class="toc-number">1.3.1.</span> <span class="toc-text">利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#随机地址写任意值-gt-可控地址写任意值"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">随机地址写任意值 -> 可控地址写任意值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存布局"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造溢出数据"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">构造溢出数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考短文件名"><span class="toc-number">1.3.2.</span> <span class="toc-text">思考短文件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#权限提升"><span class="toc-number">1.3.3.</span> <span class="toc-text">权限提升</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#减少硬编码的方式"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">减少硬编码的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exploit编写流程"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">exploit编写流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修补方案"><span class="toc-number">1.3.4.</span> <span class="toc-text">修补方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.5.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>