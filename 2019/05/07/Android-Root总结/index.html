<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Android-Root总结 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Android-Root总结</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2019/05/07</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Android_Kernel"> Android_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="Android-Root总结"><a href="#Android-Root总结" class="headerlink" title="Android-Root总结"></a>Android-Root总结</h1><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="Root介绍"><a href="#Root介绍" class="headerlink" title="Root介绍"></a>Root介绍</h3><h4 id="什么是Root"><a href="#什么是Root" class="headerlink" title="什么是Root"></a>什么是Root</h4><p>root在linux中是超级管理员的意思，我们常说的获取root其实就是获取系统最高权限的意思。那为什么我们要获取系统的最高权限呢？最开始是因为某些手机厂商联合运行商，在手机中预装了许多烦人的应用来打造一个封闭的生态圈，并且一般用户是没有权限卸载这些应用的，强制用户使用这些应用。后来为了让手机用户摆脱厂商的这种限制，有人就搞出了对手机进行root的工具。通过这类工具可以获取系统最高权限，让被root后的手机用起来更舒服，更自由。比如卸载手机内置的烦人的软件，禁止开机启动项，实现对手机的各种定制化，在手机空间较小的情况下还可以用来优化手机。但是这些应用在方便了用户的同时也为病毒制作者开了一扇窗，对于被root后的手机病毒可以做的各种不可告人的操作也变得更多。因此各个手机厂商和Google就对android添加了各种保护机制和检测方法，避免手机被root。导致现在想要获取手机root远没有之前那般容易了。当然现今一些手机厂商也会内置root权限的开关，不过对于现在的手机远比以前的手机内存大，运行速度快所以国内root的需求也没有以前那么大了，现在对手机root可能更多是为了满足病毒，取证方面的需求吧。不过像国外的一些国家和我们几年前的情况差不多，目前还存在一定的手机root需求的。<br><img src="HowRootworks.jpg" alt=""><br>上图为root工具工作原理</p>
<h4 id="如何获取Root"><a href="#如何获取Root" class="headerlink" title="如何获取Root"></a>如何获取Root</h4><p>目前我们比较常用的获取root方法有通过刷机获取，通过漏洞利用获取，一般刷机获取的话可能需要清空当前设备的数据在某些情况下存在局限性，所以最好就是利用漏洞去获取系统最高权限当然难度更高，然后在高权限下替换或添加权限管理程序也就是我们常说的su，比较常用的su程序包括SuperSU，Magisk。个人感觉Magisk比较好用。</p>
<h5 id="常见的提权操作"><a href="#常见的提权操作" class="headerlink" title="常见的提权操作"></a>常见的提权操作</h5><p>通过漏洞进行提权常规的套路就是利用一个低权限进程利用漏洞直接获取高权限，方法很多可以通过修改这个低权限进程内核中的关键结构体，或者直接调用内核提供的权限提升函数(commit_creds(prepare_kernel_cred(0)))，这种方法可能有时候需要patch内核代码(比如利用<a href="https://www.cnblogs.com/gm-201705/p/9863995.html" target="_blank" rel="external">setreuid函数</a>接口时)，又或者替换内核代码把内核在某种情况下要启动的可执行文件的路径改为我们自定义的路径(hotplug利用：ls -l /proc/sys/kernel/hotplug)，还有就是通过修改系统配置文件进行提权比如<a href="https://www.ms509.com/2017/07/14/Moto-bootloader-exploit/" target="_blank" rel="external">bootloader漏洞提权</a>，以及利用漏洞替换系统文件进行提权<a href="https://github.com/timwr/CVE-2016-5195">DirtyCow的一个实例</a>。在无法通过低权限提升到高权限的情况下我们也可以把目标转到已经存在高权限的进程中，通过这些高权限进程的漏洞，依然可以获取root权限。</p>
<h5 id="临时root和永久root"><a href="#临时root和永久root" class="headerlink" title="临时root和永久root"></a>临时root和永久root</h5><p>root还分为永久root和临时root，临时root就是在提权成功直到系统关机这段时间拥有root权限，每次系统重启后都需要重新进行提权。主要是Android4.4以及更高版本的系统在启动时内核会使用<a href="https://github.com/xapool/xapool.github.com/wiki/Bypass-QCOM-Secure-Boot">dm-verity</a>功能进行验证启动，验证原理是最开始会建立一条从受硬件保护的信任根到引导加载程序，再到启动分区和其他已验证分区(system,vendor和可选的OEM分区)的完整信任链(加密散列树)。设备在启动时进入下个阶段之前会先校验下个阶段的完整性和真实性。这样就有效阻止了提权时植入的拥有持久Root权限的Rootkit。<br>除了有系统完整性检查以外还内置了回滚保护机制，避免攻击者回滚到之前存在漏洞的系统进行攻击。存在回滚保护的设备只会更新到更高的Android系统。实现原理就是使用防篡改的存储空间记录最新一次android版本的信息。并在Android版本低于记录的版本时拒绝启动Android。<br>加密散列树的原理就是把数据按4k为一块，树中每个节点都是加密hash，其中叶节点包含物理数据块的hash，并且中间节点包含其子节点的hash。因为根节点中的哈希是基于所有子节点的值，所以只有根节点被信任才能验证树的其余部分，对于任何一个节点块的修改都会破坏整个加密hash。</p>
<h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h3><h4 id="一些root的检测方法"><a href="#一些root的检测方法" class="headerlink" title="一些root的检测方法"></a>一些root的检测方法</h4><p>下面列出一些用来检测手机是否被root的方法，都是一些比较简单的检测，存在各自的缺点，没有通用的检测方法，还是需要根据实际情况灵活使用。</p>
<ul>
<li><p>检查是否存在权限管理应用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">手动检查：</div><div class="line">ls -l /system/app/Superuser.apk</div><div class="line">pm <span class="built_in">list</span> packages | grep eu.chainfire.supersu</div><div class="line">pm <span class="built_in">list</span> packages | grep magisk</div><div class="line">自动检查：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">checkSuperuserApk</span><span class="params">()</span></span>&#123; </div><div class="line"><span class="keyword">try</span> &#123; </div><div class="line">    File file = <span class="keyword">new</span> File(<span class="string">"/system/app/Superuser.apk"</span>); </div><div class="line">    <span class="keyword">if</span> (file.exists()) &#123; </div><div class="line">        Log.i(LOG_TAG,<span class="string">"/system/app/Superuser.apk exist"</span>); </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </div><div class="line">    &#125; </div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; &#125; </div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>检查是否存在不需要的二进制文件，路径可能不一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">手动检查：</div><div class="line">ls -l /system/bin/su /system/xbin/su</div><div class="line">ls -l system/su /system/bin/.ext/.su</div><div class="line">ls -l /system/usr/we-need-root/su-backup</div><div class="line">find / -name <span class="string">"*su*"</span> <span class="number">2</span>&gt;/dev/null      <span class="comment">/*搜索根目录下所有文件，列出名字带su的文件路径*/</span></div><div class="line">自动检查：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">checkRootPathSU</span><span class="params">()</span> </span>&#123; </div><div class="line">    File f=null; </div><div class="line">    final String kSuSearchPaths[]=&#123;<span class="string">"/system/bin/"</span>,<span class="string">"/system/xbin/"</span>,<span class="string">"/system/sbin/"</span>,<span class="string">"/sbin/"</span>,<span class="string">"/vendor/bin/"</span>&#125;; </div><div class="line">    <span class="keyword">try</span>&#123; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;kSuSearchPaths.length;i++) &#123; </div><div class="line">            f=<span class="keyword">new</span> File(kSuSearchPaths[i]+<span class="string">"su"</span>); </div><div class="line">            <span class="keyword">if</span>(f!=null&amp;&amp;f.exists()) &#123; </div><div class="line">            Log.i(LOG_TAG,<span class="string">"find su in : "</span>+kSuSearchPaths[i]); </div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123; </div><div class="line">        e.printStackTrace(); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>检查shell权限的id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id | grep root</div><div class="line">ps | grep adbd | grep root</div></pre></td></tr></table></figure>
</li>
<li><p>检查文件系统的读写属性是否被更改(RW等)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">手动检查：</div><div class="line">bullhead:/ $ mount | grep system</div><div class="line">/dev/block/mmcblk0p41 on /system type ext4 (ro,seclabel,relatime,inode_readahead_blks=8)</div><div class="line">/dev/block/mmcblk0p41 on /sbin/.core/mirror/system type ext4 (ro,seclabel,relatime,inode_readahead_blks=8)</div><div class="line">ls -lR /system | grep -e :$ -e [r-][w-]x</div><div class="line">ls -laR /system | grep [r-][w-]s[-r' ']</div></pre></td></tr></table></figure>
</li>
</ul>
<p>检查当前设备使用的是否为自定义内核，通过设备的ro.build.tags值来区分”test-keys”表示测试版，”release-keys”表示发布版，当然这种方法也可能误报。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">walleye:/ $  getprop | grep ro.build.tags</div><div class="line">[ro.build.tags]: [release-keys]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">checkDeviceDebuggable</span><span class="params">()</span></span>&#123; </div><div class="line">    String buildTags = android.os.Build.TAGS; </div><div class="line">    <span class="keyword">if</span> (buildTags != null &amp;&amp; buildTags.contains(<span class="string">"test-keys"</span>)) &#123; </div><div class="line">        Log.i(LOG_TAG,<span class="string">"buildTags="</span>+buildTags); </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>开源的Root检查项目：<br><a href="https://github.com/scottyab/rootbeer">检测Rooot项目-RootBeer</a><br><a href="https://github.com/devadvance/rootcloak">反检测Root项目-Rootcloak</a></p>
<h4 id="内核层的缓解措施"><a href="#内核层的缓解措施" class="headerlink" title="内核层的缓解措施"></a>内核层的缓解措施</h4><h5 id="内核版本3-4："><a href="#内核版本3-4：" class="headerlink" title="内核版本3.4："></a>内核版本3.4：</h5><ul>
<li>mmap_min_addr(zero-page restrict)：限制mmap函数可映射的最低地址：缓解机制：因为没有对mmap地址范围做任何限制，应用层可以映射0页面，null pointer deref漏洞当时就是利用这个机制进行提权，后期针对这种漏洞推出了mmap_min_addr线程，限制mmap可以映射的最低地址，目前null pointer deref漏洞只能做一般的dos攻击</li>
<li><p>Kernel Address Display Restriction/dmesg restrictions：由于之前常用提权套路是从/proc/kallsyms搜索符号commit_creds和prepare_kernel_cred的地址，然后在用户态通过这两个符号构造提权函数，接着利用漏洞改写某个内核函数指针，将其函数指针替换为前面构造的提权函数，最后在用户态调用被改写的fsync函数，这样内核就直接执行用户态的提权函数完成提权，后期内核推出了该机制使得默认配置下无法从/proc/kallsyms等接口获取内核符号的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/proc/sys/kernel/dmesg_restrict</div><div class="line">/proc/sys/kernel/kptr_restrict选项:</div><div class="line">用来过滤一些地址，以此避免将内核地址泄漏给攻击者，通过配置kptr_restrict的值来控制是否开启:</div><div class="line">	* <span class="number">0</span>:完全禁止</div><div class="line">	* <span class="number">1</span>:使用<span class="string">"%pk"</span>打印的内核指针被隐藏(以<span class="number">0</span>替换)，除非用户存在CAP_SYSLOG权限。</div><div class="line">	* <span class="number">2</span>:所有内核使用<span class="string">"%pk"</span>打印的都被隐藏</div></pre></td></tr></table></figure>
</li>
<li><p>SEAndroid(MAC)：强制访问控制，比常规自主访问控制(DAC)粒度更细</p>
</li>
</ul>
<h5 id="内核版本3-10-3-18："><a href="#内核版本3-10-3-18：" class="headerlink" title="内核版本3.10~3.18："></a>内核版本3.10~3.18：</h5><ul>
<li>页面权限限制</li>
<li><ul>
<li>内核代码段不可写(R-W)</li>
</ul>
</li>
<li><ul>
<li>内核数据段不可执行(R– or RW-)</li>
</ul>
</li>
<li><ul>
<li>PXN(Privilege Execute Never)：主要是用来防止内核态执行用户态代码，因为之前的漏洞利用方式是直接劫持内核执行流到用户态的shellcode进行提权，通过该机制有效保护了内核的执行范围。</li>
</ul>
</li>
<li><a href="https://www.samsungknox.com/en/blog/knox-deep-dive-real-time-kernel-protection-rkp" target="_blank" rel="external">RKP(内核实时保护，三星KNOX保护)</a></li>
</ul>
<h5 id="内核版本4-4-："><a href="#内核版本4-4-：" class="headerlink" title="内核版本4.4+："></a>内核版本4.4+：</h5><ul>
<li><a href="https://lwn.net/Articles/666550/" target="_blank" rel="external">Post-init read-only</a>：主要用来限制利用vdso布置shellcode的措施，由于之前vdso区域可写，所以有些漏洞利用就通过patch掉这块内存把恶意代码布置到这块内存上来实现shellcode的执行。该机制通过在内核初始化后把该内存区域标记为只读来扩展内核中的现有内存保护。</li>
<li><a href="https://lwn.net/Articles/695991/" target="_blank" rel="external">Hardened usercopy</a>：之前许多漏洞都是因为在使用copy_<em><em>user时边界检查不严造成的，所以开发人员干脆直接在copy</em></em>_user类函数内部添加了对拷贝位置和拷贝长度的检查。</li>
<li><a href="http://www.wowotech.net/memory_management/454.html" target="_blank" rel="external">PAN(Privileged Access Never)</a>：其主要作用就是防止内核态去访问用户态的数据，成功防止了一些用于绕过PXN机制的技巧，让利用漏洞的难度加大。</li>
<li><a href="http://www.wowotech.net/memory_management/441.html" target="_blank" rel="external">KASLR</a>：因为漏洞利用时内核地址十分重要，所以把内核地址变为随机地址会大大增加漏洞利用难度，原理就是在bootloader启动kernel的时候，会通过FDT向内核传入一个seed，在内核启动过程中，kaslr_early_init函数利用这个seed计算出一个random size，然后内核每次加载的基址都会默认在原基址上加上random size。</li>
<li><a href="https://source.android.google.cn/devices/tech/debug/intsan" target="_blank" rel="external">Integer Overflow Sanitization(整数溢出排除)</a>：一种基于编译器的安全缓解措施，针对算术运算/指令(可能溢出)的检查，以便在实际发生溢出时安全终止进程，该类排错程序可以减少整数溢出导致的各种内存损坏和信息泄露。</li>
<li><a href="https://source.android.google.cn/devices/tech/debug/kcfi" target="_blank" rel="external">Control Flow Integrity(控制流完整性)</a>：一种基于编译器的安全缓解措施，避免攻击者利用漏洞时使用代码复用技巧(ROP/JOP)，控制流完整性实现了将原始程序的控制流限制在编译时确定的有效目标的调用图中。跳转之前先验证下目标地址是否为合法的地址，否则内核崩溃。</li>
</ul>
<p>感觉最好的缓解机制还是减少攻击面和增加访问控制：减少攻击面的好处让攻击者在受限的范围内寻找漏洞，增加访问控制后(SELinux，DAC权限控制，Capabilities)使大多数漏洞在利用时都受到了限制，无法直接进行提权。<br>解决问题最好的办法就是解决提出问题的。</p>
<h3 id="缓解措施绕过技巧"><a href="#缓解措施绕过技巧" class="headerlink" title="缓解措施绕过技巧"></a>缓解措施绕过技巧</h3><ul>
<li><p>Kernel Address Display Restriction/dmesg restrictions:<br>1.利用信息泄露漏洞获取内核地址<br>2.通过直接在内存空间搜索kptr_restrict地址，关闭Kernel Address Display Restriction<br>2.1:在kernel\sysctl.c文件中存在对kptr_restrict的sysctl结构体初始化操作，我们可以通过内存遍历获取到kptr_restrict符号的地址，然后修改为0，这样就关闭了kptr_restrict保护机制</p>
</li>
<li><p>SEAndroid：<br>1.selinux_enforcing,selinux_enable设置为0直接关闭<br>2.修改reset_security_ops()</p>
</li>
<li><p>RKP(内核实时保护机制-三星设备KNOX保护)<br>1.Bypassing KNOX</p>
</li>
<li><p>PXN(Privilege Execute Never):<br>  1.使用rop/jop等代码重用技巧绕过PXN，改写addr_limit的值，破除本进程的系统调用access_ok校验，实现对内核的任意读写。<br>  2.Ret2dir/Physmap：通过把shellcode布局到合规的地址，从而进行提权。</p>
</li>
<li><p>Kaslr：利用信息泄露类漏洞</p>
</li>
<li>PAN：任意读写类漏洞可绕过PAN保护。</li>
<li>CFI：<strong>*</strong></li>
</ul>
<h3 id="一些攻击面"><a href="#一些攻击面" class="headerlink" title="一些攻击面"></a>一些攻击面</h3><ul>
<li>常规攻击面包括浏览器，系统自带服务，第三方应用程序，<a href="https://www.anquanke.com/post/id/156149" target="_blank" rel="external">应用升级相关</a>：某些应用在升级时未对下载的升级包做验证，攻击者就可以替换官方升级包为恶意应用，这样最终安装的就是攻击者指定的应用，<a href="https://www.nowsecure.com/blog/2017/11/14/oneplus-device-root-exploit-backdoor-engineermode-app-diagnostics-mode/" target="_blank" rel="external">工程模式</a>， <a href="http://fecbob.pixnet.net/blog/post/42999397-ussd指令可遠端破壞android手機資料與sim卡" target="_blank" rel="external">USSD指令</a>：使用手机拨号输入一些预先制定的数字或者符号比如*#等，可能触发一些手机设备预留的后门操作。媒体和文档处理：一些应用在对文件处理时可能考虑的不够完善，导致处理一些畸形文件时出现问题。</li>
<li>无线通信相关GPS，基带，蓝牙，Wi-Fi，NFC。</li>
<li>本地的攻击面有linux系统调用，网络套接字协议，进程间的通讯，进程间内存共享以及第三方硬件驱动，bootloader。</li>
<li>物理攻击面有直接对设备进行拆解以后，可能存在暴露的串口允许接受调试信息，暴露的JTAG调试端口允许对设备进行调试。</li>
</ul>
<h3 id="漏洞相关"><a href="#漏洞相关" class="headerlink" title="漏洞相关"></a>漏洞相关</h3><p>最后来看两个比较有趣的提权漏洞的利用细节，首先是我们如何获取最新的漏洞信息，接着是拿到了漏洞以后如何确定漏洞是否可以利用，在可以利用的情况下如何利用，帮助大家构建一个学习Android漏洞的系统体系。</p>
<h3 id="分析漏洞流程"><a href="#分析漏洞流程" class="headerlink" title="分析漏洞流程"></a>分析漏洞流程</h3><h4 id="获取漏洞信息"><a href="#获取漏洞信息" class="headerlink" title="获取漏洞信息"></a>获取漏洞信息</h4><h5 id="漏洞的获取"><a href="#漏洞的获取" class="headerlink" title="漏洞的获取"></a>漏洞的获取</h5><p>对于漏洞的获取可以关注一些公众号比如玄武实验室的每日公告，天融信阿尔法实验室的每日公告，还有许多公众号都不错。但是一般这些公众号都会在固定的时候发。一般如果出了比较厉害的漏洞或一些新技术都会很快在各大社交应用中传播，所以平时我们还可以多关注一些国内外大佬的推特，微博，还有就是每个月的Google的<a href="https://source.android.com/security/bulletin/" target="_blank" rel="external">Android安全公告</a>。<br>如果我们想早于别人之前获取漏洞信息那么我们可以关注一些首发网站，比如<a href="https://bugs.chromium.org/p/project-zero/" target="_blank" rel="external">bugs.chromium.org</a>这网站我感觉挺不错的，会公布一些漏洞细节，并且还挺详细。还有<a href="">Android内核补丁网站</a>和<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/" target="_blank" rel="external">Linux内核补丁网站</a>获取最新的补丁信息，可以通过补丁信息推测出一些相关类型的漏洞或者通过补丁分析获取一些被偷偷修补了的洞。<br>最后就是通过结交一些相关领域的朋友组成自己的小圈子，很多消息都在一些小圈子中飞，提高自己的信息获取能力。</p>
<h5 id="通过crash-log定位内核异常"><a href="#通过crash-log定位内核异常" class="headerlink" title="通过crash log定位内核异常"></a>通过crash log定位内核异常</h5><p>当我们有了该漏洞的poc以后我们可以找一个测试机，然后在测试机上跑一下看能否崩溃，如果可以崩溃接下来就去获取崩溃日志，然后分析崩溃日志根据日志定位到崩溃代码的位置，也有可能崩溃的地方与实际漏洞的位置不在一处或者多次运行崩溃的地址都不一样，这就需要根据实际的情况详细分析了，对于内存相关的漏洞我们可以使用开启了<a href="http://www.wowotech.net/memory_management/424.html" target="_blank" rel="external">KASAN</a>选项的测试机，这样崩溃时内核给我们的信息会更多一些。</p>
<ul>
<li><p>常见的几个崩溃日志文件<br>cat /sys/fs/pstore/console-ramoops<br>cat /proc/last_kmsg<br>cat /proc/kmsg</p>
</li>
<li><p>获取内核函数的地址<br>echo 0&gt; /sys/fs/selinux/enforce<br>echo 0 &gt; /proc/sys/kernel/kptr_restrict<br>cat /proc/kallsyms |grep ptmx_fops</p>
</li>
</ul>
<h4 id="漏洞分析方法"><a href="#漏洞分析方法" class="headerlink" title="漏洞分析方法"></a>漏洞分析方法</h4><h5 id="静态分析-gt-解包固件并分析内核"><a href="#静态分析-gt-解包固件并分析内核" class="headerlink" title="静态分析-&gt;解包固件并分析内核"></a>静态分析-&gt;解包固件并分析内核</h5><h6 id="内核镜像分析"><a href="#内核镜像分析" class="headerlink" title="内核镜像分析"></a>内核镜像分析</h6><p>获取固件的方式分为两种一种是在网上找相应版本的固件包获取镜像，一种是直接dump当前手机的内核镜像。由于第二种需要root权限，所以第一种最方便也最简单，但是这里主要说下第二种，首先我们需要一个带root的手机，通过adb shell连接手机，然后使用以下命令把手机中包含内核的镜像dump出来，路径可能不一样，一般都在/dev/block/platform/目录下，多找几层就能看到。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">bullhead:/ <span class="meta"># ls -l  /dev/block/platform/soc.0/f9824900.sdhci/by-name/</span></div><div class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">21</span> <span class="number">1970</span><span class="number">-08</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">13</span> DDR -&gt; /dev/block/mmcblk0p28</div><div class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">20</span> <span class="number">1970</span><span class="number">-08</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">13</span> aboot -&gt; /dev/block/mmcblk0p8</div><div class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">21</span> <span class="number">1970</span><span class="number">-08</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">13</span> abootbak -&gt; /dev/block/mmcblk0p14</div><div class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">21</span> <span class="number">1970</span><span class="number">-08</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">13</span> apdp -&gt; /dev/block/mmcblk0p17</div><div class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">21</span> <span class="number">1970</span><span class="number">-08</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">13</span> boot -&gt; /dev/block/mmcblk0p37            <span class="comment">/*------------boot 当前内核进行指向/dev/block/mmcblk0p37---------------*/</span></div><div class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">21</span> <span class="number">1970</span><span class="number">-08</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">13</span> cache -&gt; /dev/block/mmcblk0p40</div><div class="line">[...]</div><div class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">21</span> <span class="number">1970</span><span class="number">-08</span><span class="number">-04</span> <span class="number">08</span>:<span class="number">13</span> vendor -&gt; /dev/block/mmcblk0p39</div><div class="line">bullhead:/ <span class="meta"># dd <span class="meta-keyword">if</span>=/dev/block/mmcblk0p37 of=/data/local/tmp/boot.img</span></div><div class="line"><span class="number">65536</span>+<span class="number">0</span> records in</div><div class="line"><span class="number">65536</span>+<span class="number">0</span> records out</div><div class="line"><span class="number">33554432</span> bytes transferred in <span class="number">0.575</span> secs (<span class="number">58355533</span> bytes/sec)</div><div class="line">bullhead:/ <span class="meta"># ls -l /data/local/tmp/boot.img</span></div><div class="line">-rw------- <span class="number">1</span> root root <span class="number">33554432</span> <span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">14</span>:<span class="number">26</span> /data/local/tmp/boot.img</div><div class="line">bullhead:/ <span class="meta"># chmod 755 /data/local/tmp/boot.img</span></div><div class="line">bullhead:/ <span class="meta"># ls -l /data/local/tmp/boot.img</span></div><div class="line">-rwxr-xr-x <span class="number">1</span> root root <span class="number">33554432</span> <span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">14</span>:<span class="number">26</span> /data/local/tmp/boot.img</div><div class="line">bullhead:/ <span class="meta"># exit</span></div><div class="line">bullhead:/ $ <span class="built_in">exit</span></div><div class="line">C:\Users\Administrator&gt;adb pull /data/local/tmp/boot.img</div><div class="line">/data/local/tmp/boot.img: <span class="number">1</span> file pulled. <span class="number">9.1</span> MB/s (<span class="number">33554432</span> bytes in <span class="number">3.518</span>s)</div><div class="line">C:\Users\Administrator&gt;</div></pre></td></tr></table></figure></p>
<p>OK，可以看到我们成功dump了boot进行，但这不是我们最终的内核，我们还需要使用linux下的abootimg工具对该镜像做解包处理才能获取我们最终的镜像。命令如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">abootimg -x boot.img</div></pre></td></tr></table></figure></p>
<p>该命令会把我们dump出来的boot.img解包，会生成几个文件，我们只需要其中的zImage文件就行，它有时候是一个zip包，直接通过解压工具就能解开，解开以后我们把最终的内核丢到IDA中直接就可以分析了。<br>通过前面我们定位到的崩溃地址和获取的函数符号地址，就可以在IDA中分析当时内核执行时上下文了。</p>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><p>我们还可以使用SourceInsight进行内核的源码分析，分析源码之前我们首先需要下载源码<a href="https://android.googlesource.com/kernel/" target="_blank" rel="external">Android官方源码</a>，然后再创建一个SourceInsight项目把前面下载的源码导入到该项目中即可，导入后可能需要一些时间同步函数之间的调用关系，要不了多长时间。感觉SourceInsight用来读源码还是挺好用的。还有一个understand工具用来分析源码也挺方便的，它可以列出目标函数的调用栈，在写poc的时候挺好用的。</p>
<h5 id="动态分析-gt-GDB调试模拟器"><a href="#动态分析-gt-GDB调试模拟器" class="headerlink" title="动态分析-&gt;GDB调试模拟器"></a>动态分析-&gt;GDB调试模拟器</h5><p>动态调试大概流程如下：<br>1.首先我们需要创建一个emulator模拟器，然后启动该模拟器，获取该模拟器的内核版本。<br>2.确定内核版本以后就去下载相应的android内核，并编译该源码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">64</span>位编译配置</div><div class="line"><span class="keyword">export</span> ARCH=arm64</div><div class="line"><span class="keyword">export</span> SUBARCH=arm64</div><div class="line"><span class="keyword">export</span> CROSS_COMPILE=/home/ubuntu/Desktop/work/source/kernel/android-ndk-r10e/toolchains/aarch64-linux-android<span class="number">-4.9</span>/prebuilt/linux-x86_64/bin/aarch64-linux-android-</div><div class="line">make menuconfig</div><div class="line"></div><div class="line"><span class="number">32</span>位编译配置</div><div class="line"><span class="keyword">export</span> ARCH=arm</div><div class="line"><span class="keyword">export</span> SUBARCH=arm</div><div class="line"><span class="keyword">export</span> CROSS_COMPILE=/home/ubuntu/Desktop/work/source/kernel/arm-eabi<span class="number">-4.6</span>/bin/arm-eabi-</div><div class="line">make goldfish_armv7_defconfig</div></pre></td></tr></table></figure></p>
<p>3.内核编译完毕后使用我们编译的内核去启动第一步的模拟器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emulator -kernel /work/kernel/goldfish/arch/arm/boot/zImage -show-kernel -verbose -avd 模拟器名 -qemu -s -S</div></pre></td></tr></table></figure></p>
<p>4.启动成功后内核会暂停等待GDB连接，注意在连接内核之前先用GDB加载前面编译出来的vmlinux，这样才能实现对源码的调试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aarch64-linux-android-gdb ./vmlinux</div><div class="line">target remote localhost:<span class="number">1234</span></div></pre></td></tr></table></figure></p>
<p>5.开始GDB单步调试</p>
<h3 id="提权漏洞实例讲解"><a href="#提权漏洞实例讲解" class="headerlink" title="提权漏洞实例讲解"></a>提权漏洞实例讲解</h3><h4 id="CVE-2017-7533"><a href="#CVE-2017-7533" class="headerlink" title="CVE-2017-7533"></a>CVE-2017-7533</h4><h4 id="CVE-2018-9568"><a href="#CVE-2018-9568" class="headerlink" title="CVE-2018-9568"></a>CVE-2018-9568</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>“With great power comes great responsibility” — Uncle Ben Parker</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><h5 id="android系统完整性校验"><a href="#android系统完整性校验" class="headerlink" title="android系统完整性校验"></a>android系统完整性校验</h5><p><a href="https://source.android.com/security/verifiedboot" target="_blank" rel="external">验证启动</a></p>
<h5 id="检测root的方法"><a href="#检测root的方法" class="headerlink" title="检测root的方法"></a>检测root的方法</h5><p><a href="https://blog.csdn.net/lintax/article/details/70988565" target="_blank" rel="external">Android root检测方法小结</a><br><a href="https://blog.csdn.net/tangsilian/article/details/85255929" target="_blank" rel="external">Root检测与反检测</a></p>
<h5 id="防护机制文章"><a href="#防护机制文章" class="headerlink" title="防护机制文章"></a>防护机制文章</h5><p><a href="https://lwn.net/Security/Index/" target="_blank" rel="external">https://lwn.net/Security/Index/</a><br><a href="https://hardenedlinux.github.io/system-security/2016/05/23/kernel_self_protection.html" target="_blank" rel="external">Linux内核自防护项目的初始文稿</a><br><a href="http://ne2der.com/2017/Hardening-the-Kernel-in-Android-Oreo/" target="_blank" rel="external">Android O 内核加固与缓解机制</a><br><a href="https://blog.csdn.net/Innost/article/details/19299937" target="_blank" rel="external">深入理解SELinux SEAndroid</a><br><a href="https://juejin.im/post/5c1740dcf265da614a3a66c1" target="_blank" rel="external">Android 内核控制流完整性</a><br><a href="https://android-developers.googleblog.com/2017/08/hardening-kernel-in-android-oreo.html" target="_blank" rel="external">Android O</a><br><a href="https://android-developers.googleblog.com/2018/06/compiler-based-security-mitigations-in.html" target="_blank" rel="external">Android P</a><br><a href="https://android-developers.googleblog.com/2018/10/control-flow-integrity-in-android-kernel.html" target="_blank" rel="external">Control Flow Integrity in the Android kernel</a></p>
<h5 id="绕过相关文章"><a href="#绕过相关文章" class="headerlink" title="绕过相关文章"></a>绕过相关文章</h5><p><a href="https://bbs.pediy.com/thread-220057.htm" target="_blank" rel="external">给shellcode找块福地-通过VDSO绕过PXN</a><br><a href="https://geneblue.github.io/2016/07/27/Android%20PXN绕过技术研究/" target="_blank" rel="external">Android PXN绕过技术研究</a><br><a href="https://wooyun.js.org/drops/PXN防护技术的研究与绕过.html" target="_blank" rel="external">PXN防护技术的研究与绕过</a><br><a href="https://events.linuxfoundation.jp/wp-content/uploads/2017/11/LSS2018.pdf" target="_blank" rel="external">Android Kernel Security</a></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2019/05/07/Android-Root总结/">http://github.com/2019/05/07/Android-Root总结/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/09/03/CVE-2018-18281/" title="CVE-2018-18281"><span>< PreviousPost</span><br><span class="prevTitle">CVE-2018-18281</span></a><a class="nextSlogan" href="/2019/04/29/python自动化生成Word报告/" title="python自动化生成Word报告"><span>NextPost ></span><br><span class="nextTitle">python自动化生成Word报告</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-Root总结"><span class="toc-number">1.</span> <span class="toc-text">Android-Root总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.0.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Root介绍"><span class="toc-number">1.0.2.</span> <span class="toc-text">Root介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Root"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">什么是Root</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何获取Root"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">如何获取Root</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#常见的提权操作"><span class="toc-number">1.0.2.2.1.</span> <span class="toc-text">常见的提权操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#临时root和永久root"><span class="toc-number">1.0.2.2.2.</span> <span class="toc-text">临时root和永久root</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓解措施"><span class="toc-number">1.0.3.</span> <span class="toc-text">缓解措施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一些root的检测方法"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">一些root的检测方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核层的缓解措施"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">内核层的缓解措施</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#内核版本3-4："><span class="toc-number">1.0.3.2.1.</span> <span class="toc-text">内核版本3.4：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内核版本3-10-3-18："><span class="toc-number">1.0.3.2.2.</span> <span class="toc-text">内核版本3.10~3.18：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内核版本4-4-："><span class="toc-number">1.0.3.2.3.</span> <span class="toc-text">内核版本4.4+：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓解措施绕过技巧"><span class="toc-number">1.0.4.</span> <span class="toc-text">缓解措施绕过技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一些攻击面"><span class="toc-number">1.0.5.</span> <span class="toc-text">一些攻击面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞相关"><span class="toc-number">1.0.6.</span> <span class="toc-text">漏洞相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析漏洞流程"><span class="toc-number">1.0.7.</span> <span class="toc-text">分析漏洞流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取漏洞信息"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">获取漏洞信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#漏洞的获取"><span class="toc-number">1.0.7.1.1.</span> <span class="toc-text">漏洞的获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过crash-log定位内核异常"><span class="toc-number">1.0.7.1.2.</span> <span class="toc-text">通过crash log定位内核异常</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞分析方法"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">漏洞分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#静态分析-gt-解包固件并分析内核"><span class="toc-number">1.0.7.2.1.</span> <span class="toc-text">静态分析->解包固件并分析内核</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#内核镜像分析"><span class="toc-number">1.0.7.2.1.1.</span> <span class="toc-text">内核镜像分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#源码分析"><span class="toc-number">1.0.7.2.1.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#动态分析-gt-GDB调试模拟器"><span class="toc-number">1.0.7.2.2.</span> <span class="toc-text">动态分析->GDB调试模拟器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提权漏洞实例讲解"><span class="toc-number">1.0.8.</span> <span class="toc-text">提权漏洞实例讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2017-7533"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">CVE-2017-7533</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CVE-2018-9568"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">CVE-2018-9568</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.0.9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">1.0.10.</span> <span class="toc-text">参考</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#android系统完整性校验"><span class="toc-number">1.0.10.0.1.</span> <span class="toc-text">android系统完整性校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检测root的方法"><span class="toc-number">1.0.10.0.2.</span> <span class="toc-text">检测root的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#防护机制文章"><span class="toc-number">1.0.10.0.3.</span> <span class="toc-text">防护机制文章</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#绕过相关文章"><span class="toc-number">1.0.10.0.4.</span> <span class="toc-text">绕过相关文章</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>