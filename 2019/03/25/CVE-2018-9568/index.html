<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Let_go"><meta name="renderer" content="webkit"><meta name="copyright" content="Let_go"><meta name="keywords" content="Let_go"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CVE-2018-9568 · Mr.Chen's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Let_go</div><div class="profile-signature">人生如棋,我愿为卒。行动虽慢,可谁曾见我后退一步。</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Chen's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about">About</a><a href="/archives">Archives</a><a href="/tags">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">CVE-2018-9568</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2019/03/25</span></span><span class="busuanzi-pv" id="busuanzi_container_page_pv"><i class="post-intro-calendar fa fa-user-o"></i><span id="busuanzi_value_page_pv"></span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="Android_Kernel"> Android_Kernel</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="CVE-2018-9568"><a href="#CVE-2018-9568" class="headerlink" title="CVE-2018-9568"></a>CVE-2018-9568</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h3><ul>
<li>实验环境：Nexus 5X(3.10版内核，)</li>
<li>漏洞类型：类型混淆类漏洞 –&gt; 释放后重引用</li>
<li>linux补丁：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/core/sock.c?id=9d538fa60bad4f7b23193c89e843797a1cf71ef3" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/core/sock.c?id=9d538fa60bad4f7b23193c89e843797a1cf71ef3</a></li>
<li>漏洞描述：当应用程序使用IPV6_ADDRFORM(将IPv6套接字转换为IPv4)时，sk-&gt;sk_prot和sk-&gt;sk_prot_creator可能会不同。 这就是为什么sk_prot_creator确保sk_prot_free()在正确的kmem_cache slab上执行kmem_cache_free()的原因。</li>
</ul>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>如果把一个IPV6类型的套接字句柄通过setsockopt函数使用IPV6_ADDRFORM选项转换成IPV4套接字,那么该套接字的sk-&gt;sk_prot会被改变为tcp_prot,此时套接字的sk-&gt;sk_prot和sk-&gt;sk_prot_creator就不一样了(sk-&gt;sk_prot指向tcp_prot，而sk-&gt;sk_prot_creator还是原来的tcpv6_prot，sk_prot_creator指向的proto结构体中的slab变量指向申请当前sk结构体的那块专用高速缓存)。<br>再使用accept函数去监听上面被转换成IPV4的套接字,底层函数sk_clone_lock会分配一个新的IPV4套接字，使用被监听套接字的sk-&gt;sk_prot(tcp_prot)中的slab变量指向的高速缓存申请一个新的sock结构体变量sk，再把被监听套接字的所有内容都拷贝到新的sock结构体变量sk中,由于这属于完全拷贝导致新套接字的sk-&gt;sk_prot_creator和被监听套接字的sk-&gt;sk_prot_creator一致(都指向tcpv6_prot),并且后面的代码也没有把新套接字的sk-&gt;sk_prot_createor更新为创建sock结构体时使用的sk_prot,后续关闭新套接字调用sk_prot_free函数释放sock结构体时使用的是sk_prot_creator指向的slab(也就是tcpv6_prot的slab，但实际应该使用tcp_prot的slab)，导致释放这个sock结构体时使用的高速缓存不是申请这个结构体时使用的高速缓存，存在类型混淆的问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* sk-&gt;sk_prot指向的结构体原型 */</span></div><div class="line"><span class="keyword">struct</span> proto &#123;</div><div class="line"><span class="comment">/*--------------------------skip--------------------------*/</span></div><div class="line">    <span class="keyword">int</span>         max_header;</div><div class="line">    <span class="keyword">bool</span>            no_autobind;</div><div class="line">    <span class="keyword">struct</span> kmem_cache   *slab;          <span class="comment">/* 指向当前套接字协议对应的高速缓存*/</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        obj_size;</div><div class="line">    <span class="keyword">slab_flags_t</span>        slab_flags;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        useroffset; <span class="comment">/* Usercopy region offset */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        usersize;   <span class="comment">/* Usercopy region size */</span></div><div class="line">    <span class="keyword">struct</span> percpu_counter   *orphan_count;</div><div class="line">    <span class="keyword">struct</span> request_sock_ops *rsk_prot;</div><div class="line">    <span class="keyword">struct</span> timewait_sock_ops *twsk_prot;</div><div class="line"><span class="comment">/*--------------------------skip--------------------------*/</span></div><div class="line">    <span class="keyword">char</span>            name[<span class="number">32</span>];           <span class="comment">/* TCP/TCPv6 */</span></div><div class="line">    <span class="keyword">struct</span> list_head    node;</div><div class="line">    <span class="keyword">int</span>         (*diag_destroy)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> err);</div><div class="line">&#125; __randomize_layout;</div></pre></td></tr></table></figure></p>
<p>大概的触发链如下：<br>1.首先创建一个IPV6的套接字 底层会创建一个sk结构体,在inet6_create函数中,通过sk_alloc函数调用sk_prot_alloc函数在prot-&gt;slab指向的slab中申请,并且初始化sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot; 此时使用的是IPV6的初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket()-&gt;__sys_socket()-&gt;sock_create()-&gt;__sock_create()-&gt;pf-&gt;create(__sock_create内部的函数指针)-&gt;inet6_create()-&gt;sk_alloc()-&gt;sk_prot_alloc()-&gt;kmem_cache_alloc()</div></pre></td></tr></table></figure></p>
<p>2.把IPV6套接字转换为IPV4套接字,在do_ipv6_setsockopt函数中通过选项IPV6_ADDRFORM,把第一步申请的sk-&gt;sk_prot赋值成IPV4的prot,此时该sk的prot和sk_prot_creator已经不一致了,所以可以看出为什么在释放函数kmem_cache_free中传入的是sk_prot_creator,这是为了能够在正确的kmem_cache slab上做释放<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">do_ipv6_setsockopt()-&gt;<span class="keyword">case</span> IPV6_ADDRFORM:</div></pre></td></tr></table></figure></p>
<p>3.用转换的IPV4套接字通过accept生成一个真正的IPV4套接字,在accept底层函数sk_clone_lock中会把监听套接字的sk结构体通过sock_copy拷贝到新的套接字的sk中,因为这里拷贝完成后没有对新套接字sk的sk_prot_creator变量做初始化,实际新套接字的该成员还是指向了监听套接字的sk_prot_creator,而监听套接字sk的sk_prot_creator是属于IPV6的,它的sk实际在sk_prot中的slab中申请的(newsk = sk_prot_alloc(sk-&gt;sk_prot, priority, sk-&gt;sk_family);)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sk_clone_lock()</div></pre></td></tr></table></figure></p>
<p>4.释放真正的IPV4套接字触发kmem_cache_free,错误使用sk-&gt;sk_prot_creator在错误的kmem_cache slab上释放sk<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sk_free()-&gt;__sk_free()-&gt;sk_prot_free()-&gt;kmem_cache_free()-&gt;</div></pre></td></tr></table></figure></p>
<h3 id="漏洞造成的影响"><a href="#漏洞造成的影响" class="headerlink" title="漏洞造成的影响"></a>漏洞造成的影响</h3><p>该漏洞造成的结果：由于混淆释放使用了错误的偏移值导致受害者page的freelist链表损坏，会出现重复申请的情况，一个sk对象内存被多个套接字描述符重复指向，精心构造逻辑会出现释放后重引用的问题。</p>
<h3 id="漏洞模型"><a href="#漏洞模型" class="headerlink" title="漏洞模型"></a>漏洞模型</h3><p>通过对一个结构体对象完全拷贝来生成另一个新结构体变量时，由于一时疏忽忘记对新结构体变量中的某些值做初始化，导致使用新结构体变量时错误的使用了原结构体的值。和CVE-2017-8890有些类似，只是8890没初始化的是内存指针导致了浅拷贝的问题，而这个洞是使用了不该使用的变量导致的类型混淆的问题。</p>
<h3 id="补丁用意"><a href="#补丁用意" class="headerlink" title="补丁用意"></a>补丁用意</h3><p>补丁就是在accept底层函数sk_clone_lock拷贝完成之后,对新套接字的sk_prot_creator变量初始化为sk_prot指向正确的高速缓存，避免最后释放时使用错误的缓存进行释放。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Diffstat (limited to 'net/core/sock.c')</div><div class="line">-rw-r--r--	net/core/sock.c	2	</div><div class="line">		</div><div class="line">1 files changed, 2 insertions, 0 deletions</div><div class="line">diff --git a/net/core/sock.c b/net/core/sock.c</div><div class="line">index 9b7b6bbb2a23..7d55c05f449d 100644</div><div class="line">--- a/net/core/sock.c</div><div class="line">+++ b/net/core/sock.c</div><div class="line">@@ -1654,6 +1654,8 @@ struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</div><div class="line"> </div><div class="line"> 		sock_copy(newsk, sk);</div><div class="line"> </div><div class="line">+		newsk-&gt;sk_prot_creator = sk-&gt;sk_prot;</div><div class="line">+</div><div class="line"> 		/* SANITY */</div><div class="line"> 		if (likely(newsk-&gt;sk_net_refcnt))</div><div class="line"> 			get_net(sock_net(newsk));</div></pre></td></tr></table></figure></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="Slab分配器"><a href="#Slab分配器" class="headerlink" title="Slab分配器"></a>Slab分配器</h4><h5 id="什么是Slab分配器"><a href="#什么是Slab分配器" class="headerlink" title="什么是Slab分配器"></a>什么是Slab分配器</h5><p>在linux内核中一般是通过buddy system进行物理内存的分配的，其分配单位是页。之所以引入Slab分配器就是因为buddy system只能按页对齐来分配内存，而大多数情况下内核申请的内存大小不需要一页。如果直接通过buddy system分配内存就会造成大量的内存碎片也就是分配了而没有被用到并且无法再次分配的内存。而Slab却可以满足内核的小内存分配并且不会出现过多的内存碎片，虽然Slab分配比buddy system分配灵活但是Slab分配器还是基于buddy system实现的。</p>
<h5 id="Slab分配器的优点"><a href="#Slab分配器的优点" class="headerlink" title="Slab分配器的优点"></a>Slab分配器的优点</h5><ul>
<li>不会出现过多的内存碎片</li>
<li>内存每次申请内存和释放内存都不会和伙伴系统直接打交道，提高了分配效率</li>
</ul>
<h5 id="Slab分配器的工作"><a href="#Slab分配器的工作" class="headerlink" title="Slab分配器的工作"></a>Slab分配器的工作</h5><ul>
<li>首先会向伙伴系统申请一块内存</li>
<li>然后Slab分配器将申请的内存分成相同大小的对象(slab)放到高速缓存中(通过struct kmem_cache结构体来描述一个高速缓存)</li>
<li>当内核需要申请内存时通过调用kmalloc函数向Slab分配器申请内存，Slab分配器会查找当前高速缓存中是否有可分配的内存，若没有可分配的内存则向伙伴系统索要新的内存块以供分配，否则直接返回查找到的空闲内存给内核</li>
</ul>
<p>伙伴系统，Slab管理器和内核之间的关系我感觉就像[供货商(buddySystem)-采购商(Slab管理器)-商铺(高速缓存)-商品(slab对象)-客户(内核kmalloc)]一样。</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>前面讲了Slab分配器的工作原理提到了高速缓存，那什么是高速缓存呢？<br>其实高速缓存就是一个数据结构(struct kmem_cache)，用来管理Slab分配器从buddy system那申请过来的若干大小相同的对象(object)<br>内核在系统启动初始化阶段会创建多个通用高速缓存和专用高速缓存，这两种高速缓存管理方式是一致的，只是它们的用途不一样而已。</p>
<ul>
<li>通用高速缓存：一般用于常规的内存分配，如内核需要申请一块200 byte大小的内存，Slab管理器会在通用高速缓存中匹配和申请的大小最接近的高速缓存，由于对齐问题，只会匹配到空间大于我们申请的大小的缓存块而不会小于，这里我们申请的大小是200那么会匹配到”kmalloc-256”这块高速缓存，并从中分配一个对象返回给内核以供使用。</li>
<li>专用高速缓存：一般用于存放特定的结构体对象如当内核创建一个新任务时，他会从task_struct的专用缓存中获得struct task_struct对象所需要的内存，缓存上一般会有已分配好的并标记为空闲的struct task_struct对象来满足请求。</li>
</ul>
<p>在linux上一般可以通过读取/proc/slabinfo这个文件来获取当前系统存在的一些高速缓存，不过android上一般没有该文件。</p>
<h4 id="slab申请-释放"><a href="#slab申请-释放" class="headerlink" title="slab申请/释放"></a>slab申请/释放</h4><p>在进行漏洞利用之前我们还得来了解一些slab对象的申请流程与释放流程。<br>首先我们需要了解几个内核结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_cache &#123;</div><div class="line">	<span class="keyword">struct</span> kmem_cache_cpu __percpu *cpu_slab;	<span class="comment">/*一个per cpu变量，对于每个cpu来说，相当于一个本地内存缓存池。当分配内存的时候优先从本地cpu分配内存以保证cache的命中率*/</span></div><div class="line">	<span class="comment">/* Used for retriving partial slabs etc */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;	<span class="comment">/*限制struct kmem_cache_node中的partial链表slab的数量。虽说是mini_partial，但是代码的本意告诉我这个变量是kmem_cache_node中partial链表最大slab数量，如果大于这个mini_partial的值，那么多余的slab就会被释放。*/</span></div><div class="line">	<span class="keyword">int</span> size;	 <span class="comment">/*实际分配的大小 size(按对齐的方式分配出来的)*/</span></div><div class="line">	<span class="keyword">int</span> object_size;	<span class="comment">/*申请时的大小 object size，就是创建kmem_cache时候传递进来的参数。和size的关系就是，size是各种地址对齐之后的大小。因此，size要大于等于object_size。*/</span></div><div class="line">	<span class="keyword">int</span> offset;		<span class="comment">/* Free pointer offset. */</span></div><div class="line">	<span class="keyword">int</span> cpu_partial; <span class="comment">/*per cpu partial中所有slab的free object的数量的最大值，超过这个值就会将所有的slab转移到kmem_cache_node的partial链表。*/</span></div><div class="line">	<span class="keyword">struct</span> kmem_cache_order_objects oo;</div><div class="line"></div><div class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></div><div class="line">	<span class="keyword">struct</span> kmem_cache_order_objects max;</div><div class="line">	<span class="keyword">struct</span> kmem_cache_order_objects min;</div><div class="line">	<span class="keyword">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></div><div class="line">	<span class="keyword">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></div><div class="line">	<span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *);</div><div class="line">	<span class="keyword">int</span> inuse;		<span class="comment">/*object_size按照word对齐之后的大小。*/</span></div><div class="line">	<span class="keyword">int</span> align;		<span class="comment">/*字节对齐大小。*/</span></div><div class="line">	<span class="keyword">int</span> reserved;		<span class="comment">/* Reserved bytes at the end of slabs */</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></div><div class="line">	<span class="keyword">struct</span> list_head <span class="built_in">list</span>;	<span class="comment">/*系统有一个slab_caches链表，所有的slab都会挂入此链表。*/</span></div><div class="line">	<span class="keyword">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span> </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></div><div class="line">	<span class="keyword">struct</span> kobject kobj;	<span class="comment">/* For sysfs */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></div><div class="line">	<span class="keyword">struct</span> memcg_cache_params memcg_params;</div><div class="line">	<span class="keyword">int</span> max_attr_size; <span class="comment">/* for propagation, maximum size of a stored attr */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></div><div class="line">	<span class="keyword">struct</span> kset *memcg_kset;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></div><div class="line">	<span class="keyword">int</span> remote_node_defrag_ratio;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *random_seq;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN</span></div><div class="line">	<span class="keyword">struct</span> kasan_cache kasan_info;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	<span class="keyword">struct</span> kmem_cache_node *node[MAX_NUMNODES];		<span class="comment">/*slab节点。在NUMA系统中，每个node都有一个struct kmem_cache_node数据结构*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_cache_cpu &#123;</div><div class="line">	<span class="keyword">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span>		<span class="comment">/*指向下一个可用的object。*/</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span>		<span class="comment">/*一个神奇的数字，主要用来同步作用的。*/</span></div><div class="line">	<span class="keyword">struct</span> page *page;	<span class="comment">/* The slab from which we are allocating */</span>	<span class="comment">/*slab内存的page指针。*/</span></div><div class="line">	<span class="keyword">struct</span> page *partial;	<span class="comment">/* Partially allocated frozen slabs */</span>	<span class="comment">/*本地slab partial链表。主要是一部分使用object的slab。*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_STATS</span></div><div class="line">	<span class="keyword">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_cache_node &#123;</div><div class="line">	<span class="keyword">spinlock_t</span> list_lock;		</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></div><div class="line">	<span class="keyword">struct</span> list_head slabs_partial;	<span class="comment">/* partial list first, better asm code */</span></div><div class="line">	<span class="keyword">struct</span> list_head slabs_full;</div><div class="line">	<span class="keyword">struct</span> list_head slabs_free;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></div><div class="line">	<span class="keyword">struct</span> array_cache *shared;	<span class="comment">/* shared per node */</span></div><div class="line">	<span class="keyword">struct</span> alien_cache **alien;	<span class="comment">/* on other nodes */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;	<span class="comment">/* updated without locking */</span></div><div class="line">	<span class="keyword">int</span> free_touched;		<span class="comment">/* updated without locking */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_partial;	<span class="comment">/*slab节点中slab的数量*/</span></div><div class="line">	<span class="keyword">struct</span> list_head partial;	<span class="comment">/*slab节点的slab partial链表，和struct kmem_cache_cpu的partial链表功能类似。*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></div><div class="line">	<span class="keyword">atomic_long_t</span> nr_slabs;</div><div class="line">	<span class="keyword">atomic_long_t</span> total_objects;</div><div class="line">	<span class="keyword">struct</span> list_head full;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="slab申请流程"><a href="#slab申请流程" class="headerlink" title="slab申请流程"></a>slab申请流程</h5><p>分配流程如下：优先从cpu本地高速缓存中分配，如果per cpu freelist中没有空闲的内存可供分配了，那么就从per cpu partial链表中分配，如果per cpu partial也没有可以被分配的对象那么继续查看per node partial链表中是否有可供分配的，如果很不幸也没找到可以使用的对象那Slab管理器就从伙伴系统中申请一个空闲的slab对象链表，并挂入到per cpu freelist中以供内核的申请。<br>内存申请顺序：per cpu freelist -&gt; per cpu partial -&gt; per node partial</p>
<h5 id="slab释放流程"><a href="#slab释放流程" class="headerlink" title="slab释放流程"></a>slab释放流程</h5><p>释放流程如下：如果当前被释放的slab对象所在的page和cpu本地高速缓存的page一致，那么直接通过快释放路径释放到per cpu freelist，否则进入慢释放路径，慢释放路径首先把释放对象释放到该对象所在page的freelist上，然后page的引用计数(inuse)减1，接着判断释放掉当前obj后的slab page是否为empty，如果属于empty slab(inuse为0)，那么在满足kmem_cache_node的nr_partial大于kmem_cache的min_partial的情况下，释放该slab page到伙伴系统。否则如果slab对象所属链表状态为full，那么释放之后该slab对象链表就属于partial empty链表，就从full链表中删除并且添加到per cpu partial链表中。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>前面提到过该漏洞的造成的结果就是触发漏洞时破坏了当时高速缓存的freelist指针，导致当时page空闲的所有slab对象都会被重复分配，也就是一块内存被两个sock对象同时指向，我们可以通过close第一个socket描述符去释放该内存，但是第二个socket描述符对该内存还有引用，这就把类型混淆转换成了释放后重引用问题，我们可以在第一次close之后对释放的内存进行喷射占位，第二次close的时候使用的就是我们前面喷射的数据了，从而达到控制内核执行流的效果。但由于涉及到的对象使用的是专用缓存，所以我们通过常规的堆喷射无法喷射成功，需要先通过堆风水把该对象从专用缓存转为通用缓存，然后再去喷射才能如我们所愿顺利控制内存中的内容。<br>如何把专用缓存转换为通用缓存呢？<br>通过申请大量的专用缓存，当Slab管理器发现过多的空闲缓存后会把这些空闲内存释放回伙伴系统，这样就有机会被通用缓存分配到。</p>
<h3 id="Heap-Fenshui"><a href="#Heap-Fenshui" class="headerlink" title="Heap Fenshui"></a>Heap Fenshui</h3><p>大概的一个布局流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">创建大量的酱油线程，构造full slab</div><div class="line">触发漏洞,实现双重分配</div><div class="line">释放第一重分配的sock，促使受害者slab对象对应的page的inuse变量为<span class="number">0</span></div><div class="line">    <span class="keyword">new</span>.inuse需要为<span class="number">0</span></div><div class="line">间隔释放酱油线程，构造大量的partial slab</div><div class="line">    n-&gt;nr_partial &gt;= s-&gt;min_partial(node结构体的nr_partial的数量必须大于等于keme_cache的min_partial的数量)</div><div class="line">系统会把空闲slab对象返回给buddy系统</div><div class="line">    discard_slab(s, page);</div><div class="line">然后通过kmalloc喷射占位原始的sock-A</div><div class="line">接着释放sock-B，就会触发UAF</div><div class="line">    inet_release -&gt; sk-&gt;sk_prot-&gt;close &gt;&gt;&gt;&gt;&gt;&gt; good</div></pre></td></tr></table></figure></p>
<h4 id="关键姿势"><a href="#关键姿势" class="headerlink" title="关键姿势"></a>关键姿势</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">一个kmem_cache中的一个page能够分配多少个sock变量;    ---&gt; <span class="number">0x12</span>;</div><div class="line">    keme_cache -&gt; per cpu -&gt; page</div><div class="line">    每个page 可分配多少个 slab对象(sock变量)</div><div class="line"></div><div class="line">酱油sock的个数;      ---&gt; <span class="number">50</span> * <span class="number">12</span>;  一共<span class="number">50</span>组每组<span class="number">12</span>个,这个应该只要是<span class="number">2</span>的倍数就行吧</div><div class="line">重复分配的个数;      ---&gt; <span class="number">36</span>;      为什么是<span class="number">36</span>? 一个page最多分配<span class="number">0x12</span>个slab对象,由于会出现重复分配,所以为了把稳直接使用<span class="number">0x12</span> * <span class="number">2</span> = <span class="number">0x22</span>（<span class="number">36</span>）</div><div class="line"></div><div class="line">喷射数据的大小                             slab-&gt;size的值即可</div><div class="line"></div><div class="line">第二重释放时因为sock内存被损坏，所以每释放一次需要检查一下喷射利用成功没，如果成功了  后面的sock就不能释放了不然会出现崩溃情况</div><div class="line"></div><div class="line">喷射的字符串首地址可能和内存中的sock首地址不完全重合，可以通过gef的pattern命令生成随机字符串来定位构造目标位置</div><div class="line"></div><div class="line">因为漏洞能够直接覆盖掉函数指针，并且是由用户进程调用的被修改函数，所以可以直接把修改函数设置为kernel_sock_ioctl函数来修改addr_limit</div></pre></td></tr></table></figure>
<h3 id="劫持内核执行流"><a href="#劫持内核执行流" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>基于我们喷射成功的情况下，通过close函数去关闭socket描述符会触发以下的函数链:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">应用层：close()</div><div class="line">------------------------------------------------</div><div class="line">内核层：inet_release</div><div class="line">                    \__ sk-&gt;sk_prot-&gt;close</div></pre></td></tr></table></figure></p>
<p>由于sk的内容已经被我们控制了，所以只需要简单布局下内存就能控制住内核的执行流程了。</p>
<h3 id="实现提权"><a href="#实现提权" class="headerlink" title="实现提权"></a>实现提权</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bullhead:/data/local/tmp $ ./SwAK</div><div class="line">[+] uid:<span class="number">2000</span> pid:<span class="number">6082</span></div><div class="line">_____________   _______________         _______________  ____  ______            ________.________ ________  ______</div><div class="line">\_   ___ \   \ /   /\_   _____/         \_____  \   _  \/_   |/  __  \          /   __   \   ____<span class="comment">//  _____/ /  __  \</span></div><div class="line">/    \  \/\   Y   /  |    __)_   ______  /  ____/  /_\  \|   |&gt;      &lt;   ______ \____    /____  \/   __  \  &gt;      &lt;</div><div class="line">\     \____\     /   |        \ /_____/ /       \  \_/   \   /   --   \ /_____/    /    <span class="comment">//       \  |__\  \/   --   \</span></div><div class="line">_\______  / \___/   /_______  /         \_______ \_____  /___\______  /           /____<span class="comment">//______  /\_____  /\______  /</span></div><div class="line">        \/                  \/                  \/     \/           \/                         \/       \/        \/</div><div class="line"></div><div class="line">[+] CreateHoldSock Begin</div><div class="line">[+] CreateHoldSock End</div><div class="line">[+] MaskSK:<span class="number">0x7b0ba0d000</span> : Mmap_A:<span class="number">0x7b0ba14000</span></div><div class="line">[+] Exploit Begin</div><div class="line">[+] FreeHoldSock Begin</div><div class="line">[+] FreeHoldSock End</div><div class="line">[+] close succe <span class="number">18</span> :</div><div class="line">[*] test <span class="keyword">for</span> r/w selinux_enforcing @ffffffc001b8fa8c success</div><div class="line">[*] get root,patch cred &amp;&amp; sid</div><div class="line">[+] uid:<span class="number">0</span> pid:<span class="number">6082</span></div><div class="line">bullhead:/data/local/tmp <span class="meta"># id</span></div><div class="line">uid=<span class="number">0</span>(root) gid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">1004</span>(input),<span class="number">1007</span>(<span class="built_in">log</span>),<span class="number">1011</span>(adb),<span class="number">1015</span>(sdcard_rw),<span class="number">1028</span>(sdcard_r),<span class="number">3001</span>(net_bt_admin),<span class="number">3002</span>(net_bt),<span class="number">3003</span>(inet),<span class="number">3006</span>(net_bw_stats),<span class="number">3009</span>(readproc),<span class="number">3011</span>(uhid) context=u:r:toolbox:s0</div><div class="line">bullhead:/data/local/tmp # getprop ro.vendor.build.fingerprint</div><div class="line">google/bullhead/bullhead:<span class="number">8.1</span><span class="number">.0</span>/OPM6<span class="number">.171019</span><span class="number">.030</span>.B1/<span class="number">4768815</span>:user/release-keys</div><div class="line">bullhead:/data/local/tmp #</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对Linux内核的好多机制还不够熟悉，很多漏洞都需要结合内核机制才能完成利用，还需要多看看内核源码啊。<br>该漏洞还可以发挥更大的作用比如绕过一些保护机制，不过还没想到怎么玩o(╥﹏╥)o<br>有了想法就去验证，不要嫌麻烦偷懒啊。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u014089131/article/details/72782624" target="_blank" rel="external">https://blog.csdn.net/u014089131/article/details/72782624</a>      slub释放/申请<br><a href="http://blog.chinaunix.net/uid-7494944-id-3833334.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-7494944-id-3833334.html</a>          slub/slab中的一些问题 释放/申请<br><a href="https://awakening-fong.github.io/posts/mm/slub_partial/" target="_blank" rel="external">https://awakening-fong.github.io/posts/mm/slub_partial/</a>        slub : node partial和cpu partial<br><a href="http://blog.chinaunix.net/uid-26859697-id-5512117.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26859697-id-5512117.html</a>         slub分配算法<br><a href="https://mp.weixin.qq.com/s/3eR3f8RfjCstYMqvPZayHw" target="_blank" rel="external">https://mp.weixin.qq.com/s/3eR3f8RfjCstYMqvPZayHw</a>              图解slub</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://github.com">Let_go</a></p><p> <span>Link:  </span><a href="http://github.com/2019/03/25/CVE-2018-9568/">http://github.com/2019/03/25/CVE-2018-9568/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/04/03/CVE-2018-12232-And-CVE-2019-8912/" title="CVE-2018-12232-And-CVE-2019-8912"><span>< PreviousPost</span><br><span class="prevTitle">CVE-2018-12232-And-CVE-2019-8912</span></a><a class="nextSlogan" href="/2018/08/26/CVE-2018-8120/" title="CVE-2018-8120"><span>NextPost ></span><br><span class="nextTitle">CVE-2018-8120</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2018-9568"><span class="toc-number">1.</span> <span class="toc-text">CVE-2018-9568</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞信息"><span class="toc-number">1.1.1.</span> <span class="toc-text">漏洞信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞原理"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞原理-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞造成的影响"><span class="toc-number">1.2.2.</span> <span class="toc-text">漏洞造成的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞模型"><span class="toc-number">1.2.3.</span> <span class="toc-text">漏洞模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补丁用意"><span class="toc-number">1.2.4.</span> <span class="toc-text">补丁用意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">1.3.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Slab分配器"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Slab分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是Slab分配器"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">什么是Slab分配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Slab分配器的优点"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">Slab分配器的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Slab分配器的工作"><span class="toc-number">1.3.1.1.3.</span> <span class="toc-text">Slab分配器的工作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高速缓存"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab申请-释放"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">slab申请/释放</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#slab申请流程"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">slab申请流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#slab释放流程"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">slab释放流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用思路"><span class="toc-number">1.3.2.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Fenshui"><span class="toc-number">1.3.3.</span> <span class="toc-text">Heap Fenshui</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关键姿势"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">关键姿势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#劫持内核执行流"><span class="toc-number">1.3.4.</span> <span class="toc-text">劫持内核执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现提权"><span class="toc-number">1.3.5.</span> <span class="toc-text">实现提权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.5.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>